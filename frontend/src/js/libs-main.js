(function(factory, globals) {
    var define = globals.define, require = globals.require, isAmd = typeof define === "function" && define.amd, isCmd = !isAmd && typeof exports !== "undefined";
    if (!isAmd && !define) {
        var map = {};
        function absolute(relative, base) {
            if (relative[0] !== ".") {
                return relative;
            }
            var stack = base.split("/"), parts = relative.split("/");
            stack.pop();
            for (var i = 0; i < parts.length; i++) {
                if (parts[i] == ".") continue;
                if (parts[i] == "..") stack.pop(); else stack.push(parts[i]);
            }
            return stack.join("/");
        }
        define = globals.define = function(id, deps, factory) {
            if (typeof factory == "function") {
                map[id] = {
                    factory: factory,
                    deps: deps.map(function(dep) {
                        return absolute(dep, id);
                    }),
                    exports: null
                };
                require(id);
            } else {
                map[id] = factory;
            }
        };
        require = globals.require = function(id) {
            if (!map.hasOwnProperty(id)) {
                throw new Error("Module " + id + " has not been defined");
            }
            var module = map[id];
            if (!module.exports) {
                var args = [];
                module.deps.forEach(function(dep) {
                    args.push(require(dep));
                });
                module.exports = module.factory.apply(window, args);
            }
            return module.exports;
        };
    }
    factory(define, require);
    if (isAmd) {
        require.get = function(context, id, relMap, localRequire) {
            context.intakeDefines(true);
            return context.defined[id];
        };
    }
    var jQuery = require("skylark-jquery/main");
    if (isCmd) {
        exports = jQuery;
    } else {
        globals.jQuery = globals.$ = jQuery;
    }
})(function(define, require) {
    define("skylark-langx/skylark", [], function() {
        var skylark = {};
        return skylark;
    });
    define("skylark-utils/skylark", [ "skylark-langx/skylark" ], function(skylark) {
        return skylark;
    });
    define("skylark-langx/langx", [ "./skylark" ], function(skylark) {
        "use strict";
        var toString = {}.toString, concat = Array.prototype.concat, indexOf = Array.prototype.indexOf, slice = Array.prototype.slice, filter = Array.prototype.filter, hasOwnProperty = Object.prototype.hasOwnProperty;
        var PGLISTENERS = Symbol ? Symbol() : "__pglisteners";
        function createAssigner(keysFunc, defaults) {
            return function(obj) {
                var length = arguments.length;
                if (defaults) obj = Object(obj);
                if (length < 2 || obj == null) return obj;
                for (var index = 1; index < length; index++) {
                    var source = arguments[index], keys = keysFunc(source), l = keys.length;
                    for (var i = 0; i < l; i++) {
                        var key = keys[i];
                        if (!defaults || obj[key] === void 0) obj[key] = source[key];
                    }
                }
                return obj;
            };
        }
        var eq, deepEq;
        var SymbolProto = typeof Symbol !== "undefined" ? Symbol.prototype : null;
        eq = function(a, b, aStack, bStack) {
            if (a === b) return a !== 0 || 1 / a === 1 / b;
            if (a == null || b == null) return false;
            if (a !== a) return b !== b;
            var type = typeof a;
            if (type !== "function" && type !== "object" && typeof b != "object") return false;
            return deepEq(a, b, aStack, bStack);
        };
        deepEq = function(a, b, aStack, bStack) {
            var className = toString.call(a);
            if (className !== toString.call(b)) return false;
            switch (className) {
              case "[object RegExp]":
              case "[object String]":
                return "" + a === "" + b;

              case "[object Number]":
                if (+a !== +a) return +b !== +b;
                return +a === 0 ? 1 / +a === 1 / b : +a === +b;

              case "[object Date]":
              case "[object Boolean]":
                return +a === +b;

              case "[object Symbol]":
                return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
            }
            var areArrays = className === "[object Array]";
            if (!areArrays) {
                if (typeof a != "object" || typeof b != "object") return false;
                var aCtor = a.constructor, bCtor = b.constructor;
                if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && ("constructor" in a && "constructor" in b)) {
                    return false;
                }
            }
            aStack = aStack || [];
            bStack = bStack || [];
            var length = aStack.length;
            while (length--) {
                if (aStack[length] === a) return bStack[length] === b;
            }
            aStack.push(a);
            bStack.push(b);
            if (areArrays) {
                length = a.length;
                if (length !== b.length) return false;
                while (length--) {
                    if (!eq(a[length], b[length], aStack, bStack)) return false;
                }
            } else {
                var keys = Object.keys(a), key;
                length = keys.length;
                if (Object.keys(b).length !== length) return false;
                while (length--) {
                    key = keys[length];
                    if (!(b[key] !== undefined && eq(a[key], b[key], aStack, bStack))) return false;
                }
            }
            aStack.pop();
            bStack.pop();
            return true;
        };
        var undefined, nextId = 0;
        function advise(dispatcher, type, advice, receiveArguments) {
            var previous = dispatcher[type];
            var around = type == "around";
            var signal;
            if (around) {
                var advised = advice(function() {
                    return previous.advice(this, arguments);
                });
                signal = {
                    remove: function() {
                        if (advised) {
                            advised = dispatcher = advice = null;
                        }
                    },
                    advice: function(target, args) {
                        return advised ? advised.apply(target, args) : previous.advice(target, args);
                    }
                };
            } else {
                signal = {
                    remove: function() {
                        if (signal.advice) {
                            var previous = signal.previous;
                            var next = signal.next;
                            if (!next && !previous) {
                                delete dispatcher[type];
                            } else {
                                if (previous) {
                                    previous.next = next;
                                } else {
                                    dispatcher[type] = next;
                                }
                                if (next) {
                                    next.previous = previous;
                                }
                            }
                            dispatcher = advice = signal.advice = null;
                        }
                    },
                    id: nextId++,
                    advice: advice,
                    receiveArguments: receiveArguments
                };
            }
            if (previous && !around) {
                if (type == "after") {
                    while (previous.next && (previous = previous.next)) {}
                    previous.next = signal;
                    signal.previous = previous;
                } else if (type == "before") {
                    dispatcher[type] = signal;
                    signal.next = previous;
                    previous.previous = signal;
                }
            } else {
                dispatcher[type] = signal;
            }
            return signal;
        }
        function aspect(type) {
            return function(target, methodName, advice, receiveArguments) {
                var existing = target[methodName], dispatcher;
                if (!existing || existing.target != target) {
                    target[methodName] = dispatcher = function() {
                        var executionId = nextId;
                        var args = arguments;
                        var before = dispatcher.before;
                        while (before) {
                            args = before.advice.apply(this, args) || args;
                            before = before.next;
                        }
                        if (dispatcher.around) {
                            var results = dispatcher.around.advice(this, args);
                        }
                        var after = dispatcher.after;
                        while (after && after.id < executionId) {
                            if (after.receiveArguments) {
                                var newResults = after.advice.apply(this, args);
                                results = newResults === undefined ? results : newResults;
                            } else {
                                results = after.advice.call(this, results, args);
                            }
                            after = after.next;
                        }
                        return results;
                    };
                    if (existing) {
                        dispatcher.around = {
                            advice: function(target, args) {
                                return existing.apply(target, args);
                            }
                        };
                    }
                    dispatcher.target = target;
                }
                var results = advise(dispatcher || existing, type, advice, receiveArguments);
                advice = null;
                return results;
            };
        }
        var f1 = function() {
            function extendClass(ctor, props, options) {
                var proto = ctor.prototype, _super = ctor.superclass.prototype, noOverrided = options && options.noOverrided;
                for (var name in props) {
                    if (name === "constructor") {
                        continue;
                    }
                    var prop = props[name];
                    if (typeof props[name] == "function") {
                        proto[name] = !prop._constructor && !noOverrided && typeof _super[name] == "function" ? function(name, fn, superFn) {
                            return function() {
                                var tmp = this.overrided;
                                this.overrided = superFn;
                                var ret = fn.apply(this, arguments);
                                this.overrided = tmp;
                                return ret;
                            };
                        }(name, prop, _super[name]) : prop;
                    } else if (typeof prop == "object" && prop !== null && (prop.get || prop.value !== undefined)) {
                        Object.defineProperty(proto, name, prop);
                    } else {
                        proto[name] = prop;
                    }
                }
                return ctor;
            }
            function serialMixins(ctor, mixins) {
                var result = [];
                mixins.forEach(function(mixin) {
                    if (has(mixin, "__mixins__")) {
                        throw new Error("nested mixins");
                    }
                    var clss = [];
                    while (mixin) {
                        clss.unshift(mixin);
                        mixin = mixin.superclass;
                    }
                    result = result.concat(clss);
                });
                result = uniq(result);
                result = result.filter(function(mixin) {
                    var cls = ctor;
                    while (cls) {
                        if (mixin === cls) {
                            return false;
                        }
                        if (has(cls, "__mixins__")) {
                            var clsMixines = cls["__mixins__"];
                            for (var i = 0; i < clsMixines.length; i++) {
                                if (clsMixines[i] === mixin) {
                                    return false;
                                }
                            }
                        }
                        cls = cls.superclass;
                    }
                    return true;
                });
                if (result.length > 0) {
                    return result;
                } else {
                    return false;
                }
            }
            function mergeMixins(ctor, mixins) {
                var newCtor = ctor;
                for (var i = 0; i < mixins.length; i++) {
                    var xtor = new Function();
                    xtor.prototype = Object.create(newCtor.prototype);
                    xtor.__proto__ = newCtor;
                    xtor.superclass = null;
                    mixin(xtor.prototype, mixins[i].prototype);
                    xtor.prototype.__mixin__ = mixins[i];
                    newCtor = xtor;
                }
                return newCtor;
            }
            return function createClass(props, parent, mixins, options) {
                if (isArray(parent)) {
                    options = mixins;
                    mixins = parent;
                    parent = null;
                }
                parent = parent || Object;
                if (isDefined(mixins) && !isArray(mixins)) {
                    options = mixins;
                    mixins = false;
                }
                var innerParent = parent;
                if (mixins) {
                    mixins = serialMixins(innerParent, mixins);
                }
                if (mixins) {
                    innerParent = mergeMixins(innerParent, mixins);
                }
                var _constructor = props.constructor;
                if (_constructor === Object) {
                    _constructor = function() {
                        if (this.init) {
                            return this.init.apply(this, arguments);
                        }
                    };
                }
                var klassName = props.klassName || "", ctor = new Function("return function " + klassName + "() {" + "var inst = this," + " ctor = arguments.callee;" + "if (!(inst instanceof ctor)) {" + "inst = Object.create(ctor.prototype);" + "}" + "return ctor._constructor.apply(inst, arguments) || inst;" + "}")();
                ctor._constructor = _constructor;
                ctor.prototype = Object.create(innerParent.prototype);
                ctor.prototype.constructor = ctor;
                ctor.superclass = parent;
                ctor.__proto__ = innerParent;
                if (mixins) {
                    ctor.__mixins__ = mixins;
                }
                if (!ctor.partial) {
                    ctor.partial = function(props, options) {
                        return extendClass(this, props, options);
                    };
                }
                if (!ctor.inherit) {
                    ctor.inherit = function(props, mixins, options) {
                        return createClass(props, this, mixins, options);
                    };
                }
                ctor.partial(props, options);
                return ctor;
            };
        };
        var createClass = f1();
        function allKeys(obj) {
            if (!isObject(obj)) return [];
            var keys = [];
            for (var key in obj) keys.push(key);
            return keys;
        }
        function createEvent(type, props) {
            var e = new CustomEvent(type, props);
            return safeMixin(e, props);
        }
        function debounce(fn, wait) {
            var timeout, args, later = function() {
                fn.apply(null, args);
            };
            return function() {
                args = arguments;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        var delegate = function() {
            function TMP() {}
            return function(obj, props) {
                TMP.prototype = obj;
                var tmp = new TMP();
                TMP.prototype = null;
                if (props) {
                    mixin(tmp, props);
                }
                return tmp;
            };
        }();
        function values(obj) {
            var keys = _.keys(obj);
            var length = keys.length;
            var values = Array(length);
            for (var i = 0; i < length; i++) {
                values[i] = obj[keys[i]];
            }
            return values;
        }
        function clone(src, checkCloneMethod) {
            var copy;
            if (src === undefined || src === null) {
                copy = src;
            } else if (checkCloneMethod && src.clone) {
                copy = src.clone();
            } else if (isArray(src)) {
                copy = [];
                for (var i = 0; i < src.length; i++) {
                    copy.push(clone(src[i]));
                }
            } else if (isPlainObject(src)) {
                copy = {};
                for (var key in src) {
                    copy[key] = clone(src[key]);
                }
            } else {
                copy = src;
            }
            return copy;
        }
        function compact(array) {
            return filter.call(array, function(item) {
                return item != null;
            });
        }
        function dasherize(str) {
            return str.replace(/::/g, "/").replace(/([A-Z]+)([A-Z][a-z])/g, "$1_$2").replace(/([a-z\d])([A-Z])/g, "$1_$2").replace(/_/g, "-").toLowerCase();
        }
        function deserializeValue(value) {
            try {
                return value ? value == "true" || (value == "false" ? false : value == "null" ? null : +value + "" == value ? +value : /^[\[\{]/.test(value) ? JSON.parse(value) : value) : value;
            } catch (e) {
                return value;
            }
        }
        function each(obj, callback) {
            var length, key, i, undef, value;
            if (obj) {
                length = obj.length;
                if (length === undef) {
                    for (key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            value = obj[key];
                            if (callback.call(value, key, value) === false) {
                                break;
                            }
                        }
                    }
                } else {
                    for (i = 0; i < length; i++) {
                        value = obj[i];
                        if (callback.call(value, i, value) === false) {
                            break;
                        }
                    }
                }
            }
            return this;
        }
        function flatten(array) {
            if (isArrayLike(array)) {
                var result = [];
                for (var i = 0; i < array.length; i++) {
                    var item = array[i];
                    if (isArrayLike(item)) {
                        for (var j = 0; j < item.length; j++) {
                            result.push(item[j]);
                        }
                    } else {
                        result.push(item);
                    }
                }
                return result;
            } else {
                return array;
            }
        }
        function funcArg(context, arg, idx, payload) {
            return isFunction(arg) ? arg.call(context, idx, payload) : arg;
        }
        var getAbsoluteUrl = function() {
            var a;
            return function(url) {
                if (!a) a = document.createElement("a");
                a.href = url;
                return a.href;
            };
        }();
        function getQueryParams(url) {
            var url = url || window.location.href, segs = url.split("?"), params = {};
            if (segs.length > 1) {
                segs[1].split("&").forEach(function(queryParam) {
                    var nv = queryParam.split("=");
                    params[nv[0]] = nv[1];
                });
            }
            return params;
        }
        function grep(array, callback) {
            var out = [];
            each(array, function(i, item) {
                if (callback(item, i)) {
                    out.push(item);
                }
            });
            return out;
        }
        function has(obj, path) {
            if (!isArray(path)) {
                return obj != null && hasOwnProperty.call(obj, path);
            }
            var length = path.length;
            for (var i = 0; i < length; i++) {
                var key = path[i];
                if (obj == null || !hasOwnProperty.call(obj, key)) {
                    return false;
                }
                obj = obj[key];
            }
            return !!length;
        }
        function inArray(item, array) {
            if (!array) {
                return -1;
            }
            var i;
            if (array.indexOf) {
                return array.indexOf(item);
            }
            i = array.length;
            while (i--) {
                if (array[i] === item) {
                    return i;
                }
            }
            return -1;
        }
        function inherit(ctor, base) {
            var f = function() {};
            f.prototype = base.prototype;
            ctor.prototype = new f();
        }
        function isArray(object) {
            return object && object.constructor === Array;
        }
        function isArrayLike(obj) {
            return !isString(obj) && !isHtmlNode(obj) && typeof obj.length == "number";
        }
        function isBoolean(obj) {
            return typeof obj === "boolean";
        }
        function isDocument(obj) {
            return obj != null && obj.nodeType == obj.DOCUMENT_NODE;
        }
        function isEqual(a, b) {
            return eq(a, b);
        }
        function isFunction(value) {
            return type(value) == "function";
        }
        function isObject(obj) {
            return type(obj) == "object";
        }
        function isPlainObject(obj) {
            return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype;
        }
        function isString(obj) {
            return typeof obj === "string";
        }
        function isWindow(obj) {
            return obj && obj == obj.window;
        }
        function isDefined(obj) {
            return typeof obj !== "undefined";
        }
        function isHtmlNode(obj) {
            return obj && obj instanceof Node;
        }
        function isInstanceOf(value, type) {
            if (value === undefined) {
                return false;
            } else if (value === null || type == Object) {
                return true;
            } else if (typeof value === "number") {
                return type === Number;
            } else if (typeof value === "string") {
                return type === String;
            } else if (typeof value === "boolean") {
                return type === Boolean;
            } else if (typeof value === "string") {
                return type === String;
            } else {
                return value instanceof type || (value && value.isInstanceOf ? value.isInstanceOf(type) : false);
            }
        }
        function isNumber(obj) {
            return typeof obj == "number";
        }
        function isSameOrigin(href) {
            if (href) {
                var origin = location.protocol + "//" + location.hostname;
                if (location.port) {
                    origin += ":" + location.port;
                }
                return href.startsWith(origin);
            }
        }
        function isEmptyObject(obj) {
            var name;
            for (name in obj) {
                if (obj[name] !== null) {
                    return false;
                }
            }
            return true;
        }
        function isMatch(object, attrs) {
            var keys = keys(attrs), length = keys.length;
            if (object == null) return !length;
            var obj = Object(object);
            for (var i = 0; i < length; i++) {
                var key = keys[i];
                if (attrs[key] !== obj[key] || !(key in obj)) return false;
            }
            return true;
        }
        function keys(obj) {
            if (isObject(obj)) return [];
            var keys = [];
            for (var key in obj) if (has(obj, key)) keys.push(key);
            return keys;
        }
        function makeArray(obj, offset, startWith) {
            if (isArrayLike(obj)) {
                return (startWith || []).concat(Array.prototype.slice.call(obj, offset || 0));
            }
            return [ obj ];
        }
        function map(elements, callback) {
            var value, values = [], i, key;
            if (isArrayLike(elements)) for (i = 0; i < elements.length; i++) {
                value = callback.call(elements[i], elements[i], i);
                if (value != null) values.push(value);
            } else for (key in elements) {
                value = callback.call(elements[key], elements[key], key);
                if (value != null) values.push(value);
            }
            return flatten(values);
        }
        function defer(fn) {
            if (requestAnimationFrame) {
                requestAnimationFrame(fn);
            } else {
                setTimeoutout(fn);
            }
            return this;
        }
        function noop() {}
        function proxy(fn, context) {
            var args = 2 in arguments && slice.call(arguments, 2);
            if (isFunction(fn)) {
                var proxyFn = function() {
                    return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments);
                };
                return proxyFn;
            } else if (isString(context)) {
                if (args) {
                    args.unshift(fn[context], fn);
                    return proxy.apply(null, args);
                } else {
                    return proxy(fn[context], fn);
                }
            } else {
                throw new TypeError("expected function");
            }
        }
        function toPixel(value) {
            return parseFloat(value) || 0;
        }
        var type = function() {
            var class2type = {};
            each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
                class2type["[object " + name + "]"] = name.toLowerCase();
            });
            return function type(obj) {
                return obj == null ? String(obj) : class2type[toString.call(obj)] || "object";
            };
        }();
        function trim(str) {
            return str == null ? "" : String.prototype.trim.call(str);
        }
        function removeItem(items, item) {
            if (isArray(items)) {
                var idx = items.indexOf(item);
                if (idx != -1) {
                    items.splice(idx, 1);
                }
            } else if (isPlainObject(items)) {
                for (var key in items) {
                    if (items[key] == item) {
                        delete items[key];
                        break;
                    }
                }
            }
            return this;
        }
        function _mixin(target, source, deep, safe) {
            for (var key in source) {
                if (!source.hasOwnProperty(key)) {
                    continue;
                }
                if (safe && target[key] !== undefined) {
                    continue;
                }
                if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
                    if (isPlainObject(source[key]) && !isPlainObject(target[key])) {
                        target[key] = {};
                    }
                    if (isArray(source[key]) && !isArray(target[key])) {
                        target[key] = [];
                    }
                    _mixin(target[key], source[key], deep, safe);
                } else if (source[key] !== undefined) {
                    target[key] = source[key];
                }
            }
            return target;
        }
        function _parseMixinArgs(args) {
            var params = slice.call(arguments, 0), target = params.shift(), deep = false;
            if (isBoolean(params[params.length - 1])) {
                deep = params.pop();
            }
            return {
                target: target,
                sources: params,
                deep: deep
            };
        }
        function mixin() {
            var args = _parseMixinArgs.apply(this, arguments);
            args.sources.forEach(function(source) {
                _mixin(args.target, source, args.deep, false);
            });
            return args.target;
        }
        function result(obj, path, fallback) {
            if (!isArray(path)) {
                path = [ path ];
            }
            var length = path.length;
            if (!length) {
                return isFunction(fallback) ? fallback.call(obj) : fallback;
            }
            for (var i = 0; i < length; i++) {
                var prop = obj == null ? void 0 : obj[path[i]];
                if (prop === void 0) {
                    prop = fallback;
                    i = length;
                }
                obj = isFunction(prop) ? prop.call(obj) : prop;
            }
            return obj;
        }
        function safeMixin() {
            var args = _parseMixinArgs.apply(this, arguments);
            args.sources.forEach(function(source) {
                _mixin(args.target, source, args.deep, true);
            });
            return args.target;
        }
        function substitute(template, map, transform, thisObject) {
            thisObject = thisObject || window;
            transform = transform ? proxy(thisObject, transform) : function(v) {
                return v;
            };
            function getObject(key, map) {
                if (key.match(/\./)) {
                    var retVal, getValue = function(keys, obj) {
                        var _k = keys.pop();
                        if (_k) {
                            if (!obj[_k]) return null;
                            return getValue(keys, retVal = obj[_k]);
                        } else {
                            return retVal;
                        }
                    };
                    return getValue(key.split(".").reverse(), map);
                } else {
                    return map[key];
                }
            }
            return template.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g, function(match, key, format) {
                var value = getObject(key, map);
                if (format) {
                    value = getObject(format, thisObject).call(thisObject, value, key);
                }
                return transform(value, key).toString();
            });
        }
        var _uid = 1;
        function uid(obj) {
            return obj._uid || (obj._uid = _uid++);
        }
        function uniq(array) {
            return filter.call(array, function(item, idx) {
                return array.indexOf(item) == idx;
            });
        }
        var idCounter = 0;
        function uniqueId(prefix) {
            var id = ++idCounter + "";
            return prefix ? prefix + id : id;
        }
        mixin(Promise.prototype, {
            always: function(handler) {
                this.then(handler, handler);
                return this;
            },
            done: function(handler) {
                this.then(handler);
                return this;
            },
            fail: function(handler) {
                this.catch(handler);
                return this;
            }
        });
        var Deferred = function() {
            var self = this, p = this.promise = new Promise(function(resolve, reject) {
                self._resolve = resolve;
                self._reject = reject;
            });
            wrapPromise(p, self);
            this[PGLISTENERS] = [];
        };
        function wrapPromise(p, d) {
            var added = {
                state: function() {
                    if (d.isResolved()) {
                        return "resolved";
                    }
                    if (d.isRejected()) {
                        return "rejected";
                    }
                    return "pending";
                },
                then: function(onResolved, onRejected, onProgress) {
                    if (onProgress) {
                        this.progress(onProgress);
                    }
                    return mixin(Promise.prototype.then.call(this, onResolved && function(args) {
                        if (args && args.__ctx__ !== undefined) {
                            return onResolved.apply(args.__ctx__, args);
                        } else {
                            return onResolved(args);
                        }
                    }, onRejected && function(args) {
                        if (args && args.__ctx__ !== undefined) {
                            return onRejected.apply(args.__ctx__, args);
                        } else {
                            return onRejected(args);
                        }
                    }), added);
                },
                progress: function(handler) {
                    self[PGLISTENERS].push(handler);
                    return this;
                }
            };
            added.pipe = added.then;
            return mixin(p, added);
        }
        Deferred.prototype.resolve = function(value) {
            var args = slice.call(arguments);
            return this.resolveWith(null, args);
        };
        Deferred.prototype.resolveWith = function(context, args) {
            args = args ? makeArray(args) : [];
            args.__ctx__ = context;
            this._resolve(args);
            this._resolved = true;
            return this;
        };
        Deferred.prototype.progress = function(value) {
            try {
                return this[PGLISTENERS].forEach(function(listener) {
                    return listener(value);
                });
            } catch (error) {
                this.reject(error);
            }
            return this;
        };
        Deferred.prototype.reject = function(reason) {
            var args = slice.call(arguments);
            return this.rejectWith(null, args);
        };
        Deferred.prototype.rejectWith = function(context, args) {
            args = args ? makeArray(args) : [];
            args.__ctx__ = context;
            this._reject(args);
            this._rejected = true;
            return this;
        };
        Deferred.prototype.isResolved = function() {
            return !!this._resolved;
        };
        Deferred.prototype.isRejected = function() {
            return !!this._rejected;
        };
        Deferred.prototype.then = function(callback, errback, progback) {
            var p = result(this, "promise");
            return p.then(callback, errback, progback);
        };
        Deferred.prototype.done = Deferred.prototype.then;
        Deferred.all = function(array) {
            return wrapPromise(Promise.all(array));
        };
        Deferred.first = function(array) {
            return wrapPromise(Promise.race(array));
        };
        Deferred.when = function(valueOrPromise, callback, errback, progback) {
            var receivedPromise = valueOrPromise && typeof valueOrPromise.then === "function";
            var nativePromise = receivedPromise && valueOrPromise instanceof Promise;
            if (!receivedPromise) {
                if (arguments.length > 1) {
                    return callback ? callback(valueOrPromise) : valueOrPromise;
                } else {
                    return new Deferred().resolve(valueOrPromise);
                }
            } else if (!nativePromise) {
                var deferred = new Deferred(valueOrPromise.cancel);
                valueOrPromise.then(deferred.resolve, deferred.reject, deferred.progress);
                valueOrPromise = deferred.promise;
            }
            if (callback || errback || progback) {
                return valueOrPromise.then(callback, errback, progback);
            }
            return valueOrPromise;
        };
        Deferred.reject = function(err) {
            var d = new Deferred();
            d.reject(err);
            return d.promise;
        };
        Deferred.resolve = function(data) {
            var d = new Deferred();
            d.resolve.apply(d, arguments);
            return d.promise;
        };
        Deferred.immediate = Deferred.resolve;
        var Evented = createClass({
            on: function(events, selector, data, callback, ctx, one) {
                var self = this, _hub = this._hub || (this._hub = {});
                if (isPlainObject(events)) {
                    ctx = callback;
                    each(events, function(type, fn) {
                        self.on(type, selector, data, fn, ctx, one);
                    });
                    return this;
                }
                if (!isString(selector) && !isFunction(callback)) {
                    ctx = callback;
                    callback = data;
                    data = selector;
                    selector = undefined;
                }
                if (isFunction(data)) {
                    ctx = callback;
                    callback = data;
                    data = null;
                }
                if (isString(events)) {
                    events = events.split(/\s/);
                }
                events.forEach(function(name) {
                    (_hub[name] || (_hub[name] = [])).push({
                        fn: callback,
                        selector: selector,
                        data: data,
                        ctx: ctx,
                        one: one
                    });
                });
                return this;
            },
            one: function(events, selector, data, callback, ctx) {
                return this.on(events, selector, data, callback, ctx, 1);
            },
            trigger: function(e) {
                if (!this._hub) {
                    return this;
                }
                var self = this;
                if (isString(e)) {
                    e = new CustomEvent(e);
                }
                Object.defineProperty(e, "target", {
                    value: this
                });
                var args = slice.call(arguments, 1);
                if (isDefined(args)) {
                    args = [ e ].concat(args);
                } else {
                    args = [ e ];
                }
                [ e.type || e.name, "all" ].forEach(function(eventName) {
                    var listeners = self._hub[eventName];
                    if (!listeners) {
                        return;
                    }
                    var len = listeners.length, reCompact = false;
                    for (var i = 0; i < len; i++) {
                        var listener = listeners[i];
                        if (e.data) {
                            if (listener.data) {
                                e.data = mixin({}, listener.data, e.data);
                            }
                        } else {
                            e.data = listener.data || null;
                        }
                        listener.fn.apply(listener.ctx, args);
                        if (listener.one) {
                            listeners[i] = null;
                            reCompact = true;
                        }
                    }
                    if (reCompact) {
                        self._hub[eventName] = compact(listeners);
                    }
                });
                return this;
            },
            listened: function(event) {
                var evtArr = (this._hub || (this._events = {}))[event] || [];
                return evtArr.length > 0;
            },
            listenTo: function(obj, event, callback, one) {
                if (!obj) {
                    return this;
                }
                if (isString(callback)) {
                    callback = this[callback];
                }
                if (one) {
                    obj.one(event, callback, this);
                } else {
                    obj.on(event, callback, this);
                }
                var listeningTo = this._listeningTo || (this._listeningTo = []), listening;
                for (var i = 0; i < listeningTo.length; i++) {
                    if (listeningTo[i].obj == obj) {
                        listening = listeningTo[i];
                        break;
                    }
                }
                if (!listening) {
                    listeningTo.push(listening = {
                        obj: obj,
                        events: {}
                    });
                }
                var listeningEvents = listening.events, listeningEvent = listeningEvents[event] = listeningEvents[event] || [];
                if (listeningEvent.indexOf(callback) == -1) {
                    listeningEvent.push(callback);
                }
                return this;
            },
            listenToOnce: function(obj, event, callback) {
                return this.listenTo(obj, event, callback, 1);
            },
            off: function(events, callback) {
                var _hub = this._hub || (this._hub = {});
                if (isString(events)) {
                    events = events.split(/\s/);
                }
                events.forEach(function(name) {
                    var evts = _hub[name];
                    var liveEvents = [];
                    if (evts && callback) {
                        for (var i = 0, len = evts.length; i < len; i++) {
                            if (evts[i].fn !== callback && evts[i].fn._ !== callback) liveEvents.push(evts[i]);
                        }
                    }
                    if (liveEvents.length) {
                        _hub[name] = liveEvents;
                    } else {
                        delete _hub[name];
                    }
                });
                return this;
            },
            unlistenTo: function(obj, event, callback) {
                var listeningTo = this._listeningTo;
                if (!listeningTo) {
                    return this;
                }
                for (var i = 0; i < listeningTo.length; i++) {
                    var listening = listeningTo[i];
                    if (obj && obj != listening.obj) {
                        continue;
                    }
                    var listeningEvents = listening.events;
                    for (var eventName in listeningEvents) {
                        if (event && event != eventName) {
                            continue;
                        }
                        listeningEvent = listeningEvents[eventName];
                        for (var j = 0; j < listeningEvent.length; j++) {
                            if (!callback || callback == listeningEvent[i]) {
                                listening.obj.off(eventName, listeningEvent[i], this);
                                listeningEvent[i] = null;
                            }
                        }
                        listeningEvent = listeningEvents[eventName] = compact(listeningEvent);
                        if (isEmptyObject(listeningEvent)) {
                            listeningEvents[eventName] = null;
                        }
                    }
                    if (isEmptyObject(listeningEvents)) {
                        listeningTo[i] = null;
                    }
                }
                listeningTo = this._listeningTo = compact(listeningTo);
                if (isEmptyObject(listeningTo)) {
                    this._listeningTo = null;
                }
                return this;
            }
        });
        var Stateful = Evented.inherit({
            init: function(attributes, options) {
                var attrs = attributes || {};
                options || (options = {});
                this.cid = uniqueId(this.cidPrefix);
                this.attributes = {};
                if (options.collection) this.collection = options.collection;
                if (options.parse) attrs = this.parse(attrs, options) || {};
                var defaults = result(this, "defaults");
                attrs = mixin({}, defaults, attrs);
                this.set(attrs, options);
                this.changed = {};
            },
            changed: null,
            validationError: null,
            idAttribute: "id",
            cidPrefix: "c",
            toJSON: function(options) {
                return clone(this.attributes);
            },
            get: function(attr) {
                return this.attributes[attr];
            },
            has: function(attr) {
                return this.get(attr) != null;
            },
            set: function(key, val, options) {
                if (key == null) return this;
                var attrs;
                if (typeof key === "object") {
                    attrs = key;
                    options = val;
                } else {
                    (attrs = {})[key] = val;
                }
                options || (options = {});
                if (!this._validate(attrs, options)) return false;
                var unset = options.unset;
                var silent = options.silent;
                var changes = [];
                var changing = this._changing;
                this._changing = true;
                if (!changing) {
                    this._previousAttributes = clone(this.attributes);
                    this.changed = {};
                }
                var current = this.attributes;
                var changed = this.changed;
                var prev = this._previousAttributes;
                for (var attr in attrs) {
                    val = attrs[attr];
                    if (!isEqual(current[attr], val)) changes.push(attr);
                    if (!isEqual(prev[attr], val)) {
                        changed[attr] = val;
                    } else {
                        delete changed[attr];
                    }
                    unset ? delete current[attr] : current[attr] = val;
                }
                if (this.idAttribute in attrs) this.id = this.get(this.idAttribute);
                if (!silent) {
                    if (changes.length) this._pending = options;
                    for (var i = 0; i < changes.length; i++) {
                        this.trigger("change:" + changes[i], this, current[changes[i]], options);
                    }
                }
                if (changing) return this;
                if (!silent) {
                    while (this._pending) {
                        options = this._pending;
                        this._pending = false;
                        this.trigger("change", this, options);
                    }
                }
                this._pending = false;
                this._changing = false;
                return this;
            },
            unset: function(attr, options) {
                return this.set(attr, void 0, mixin({}, options, {
                    unset: true
                }));
            },
            clear: function(options) {
                var attrs = {};
                for (var key in this.attributes) attrs[key] = void 0;
                return this.set(attrs, mixin({}, options, {
                    unset: true
                }));
            },
            hasChanged: function(attr) {
                if (attr == null) return !isEmptyObject(this.changed);
                return this.changed[attr] !== undefined;
            },
            changedAttributes: function(diff) {
                if (!diff) return this.hasChanged() ? clone(this.changed) : false;
                var old = this._changing ? this._previousAttributes : this.attributes;
                var changed = {};
                for (var attr in diff) {
                    var val = diff[attr];
                    if (isEqual(old[attr], val)) continue;
                    changed[attr] = val;
                }
                return !isEmptyObject(changed) ? changed : false;
            },
            previous: function(attr) {
                if (attr == null || !this._previousAttributes) return null;
                return this._previousAttributes[attr];
            },
            previousAttributes: function() {
                return clone(this._previousAttributes);
            },
            clone: function() {
                return new this.constructor(this.attributes);
            },
            isNew: function() {
                return !this.has(this.idAttribute);
            },
            isValid: function(options) {
                return this._validate({}, mixin({}, options, {
                    validate: true
                }));
            },
            _validate: function(attrs, options) {
                if (!options.validate || !this.validate) return true;
                attrs = mixin({}, this.attributes, attrs);
                var error = this.validationError = this.validate(attrs, options) || null;
                if (!error) return true;
                this.trigger("invalid", this, error, mixin(options, {
                    validationError: error
                }));
                return false;
            }
        });
        var SimpleQueryEngine = function(query, options) {
            switch (typeof query) {
              default:
                throw new Error("Can not query with a " + typeof query);

              case "object":
              case "undefined":
                var queryObject = query;
                query = function(object) {
                    for (var key in queryObject) {
                        var required = queryObject[key];
                        if (required && required.test) {
                            if (!required.test(object[key], object)) {
                                return false;
                            }
                        } else if (required != object[key]) {
                            return false;
                        }
                    }
                    return true;
                };
                break;

              case "string":
                if (!this[query]) {
                    throw new Error("No filter function " + query + " was found in store");
                }
                query = this[query];

              case "function":            }
            function filter(arr, callback, thisObject) {
                var i = 0, l = arr && arr.length || 0, out = [], value;
                if (l && typeof arr == "string") arr = arr.split("");
                if (typeof callback == "string") callback = cache[callback] || buildFn(callback);
                if (thisObject) {
                    for (;i < l; ++i) {
                        value = arr[i];
                        if (callback.call(thisObject, value, i, arr)) {
                            out.push(value);
                        }
                    }
                } else {
                    for (;i < l; ++i) {
                        value = arr[i];
                        if (callback(value, i, arr)) {
                            out.push(value);
                        }
                    }
                }
                return out;
            }
            function execute(array) {
                var results = filter(array, query);
                var sortSet = options && options.sort;
                if (sortSet) {
                    results.sort(typeof sortSet == "function" ? sortSet : function(a, b) {
                        for (var sort, i = 0; sort = sortSet[i]; i++) {
                            var aValue = a[sort.attribute];
                            var bValue = b[sort.attribute];
                            aValue = aValue != null ? aValue.valueOf() : aValue;
                            bValue = bValue != null ? bValue.valueOf() : bValue;
                            if (aValue != bValue) {
                                return !!sort.descending == (aValue == null || aValue > bValue) ? -1 : 1;
                            }
                        }
                        return 0;
                    });
                }
                if (options && (options.start || options.count)) {
                    var total = results.length;
                    results = results.slice(options.start || 0, (options.start || 0) + (options.count || Infinity));
                    results.total = total;
                }
                return results;
            }
            execute.matches = query;
            return execute;
        };
        var QueryResults = function(results) {
            if (!results) {
                return results;
            }
            var isPromise = !!results.then;
            if (isPromise) {
                results = Object.delegate(results);
            }
            function addIterativeMethod(method) {
                results[method] = function() {
                    var args = arguments;
                    var result = Deferred.when(results, function(results) {
                        return QueryResults(Array.prototype[method].apply(results, args));
                    });
                    if (method !== "forEach" || isPromise) {
                        return result;
                    }
                };
            }
            addIterativeMethod("forEach");
            addIterativeMethod("filter");
            addIterativeMethod("map");
            if (results.total == null) {
                results.total = Deferred.when(results, function(results) {
                    return results.length;
                });
            }
            return results;
        };
        var ArrayStore = createClass({
            "klassName-": "ArrayStore",
            queryEngine: SimpleQueryEngine,
            idProperty: "id",
            get: function(id) {
                return this.data[this.index[id]];
            },
            getIdentity: function(object) {
                return object[this.idProperty];
            },
            put: function(object, options) {
                var data = this.data, index = this.index, idProperty = this.idProperty;
                var id = object[idProperty] = options && "id" in options ? options.id : idProperty in object ? object[idProperty] : Math.random();
                if (id in index) {
                    if (options && options.overwrite === false) {
                        throw new Error("Object already exists");
                    }
                    data[index[id]] = object;
                } else {
                    index[id] = data.push(object) - 1;
                }
                return id;
            },
            add: function(object, options) {
                (options = options || {}).overwrite = false;
                return this.put(object, options);
            },
            remove: function(id) {
                var index = this.index;
                var data = this.data;
                if (id in index) {
                    data.splice(index[id], 1);
                    this.setData(data);
                    return true;
                }
            },
            query: function(query, options) {
                return QueryResults(this.queryEngine(query, options)(this.data));
            },
            setData: function(data) {
                if (data.items) {
                    this.idProperty = data.identifier || this.idProperty;
                    data = this.data = data.items;
                } else {
                    this.data = data;
                }
                this.index = {};
                for (var i = 0, l = data.length; i < l; i++) {
                    this.index[data[i][this.idProperty]] = i;
                }
            },
            init: function(options) {
                for (var i in options) {
                    this[i] = options[i];
                }
                this.setData(this.data || []);
            }
        });
        var Xhr = function() {
            var jsonpID = 0, document = window.document, key, name, rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, scriptTypeRE = /^(?:text|application)\/javascript/i, xmlTypeRE = /^(?:text|application)\/xml/i, jsonType = "application/json", htmlType = "text/html", blankRE = /^\s*$/;
            var XhrDefaultOptions = {
                async: true,
                type: "GET",
                beforeSend: noop,
                success: noop,
                error: noop,
                complete: noop,
                context: null,
                global: true,
                accepts: {
                    script: "text/javascript, application/javascript, application/x-javascript",
                    json: "application/json",
                    xml: "application/xml, text/xml",
                    html: "text/html",
                    text: "text/plain"
                },
                crossDomain: false,
                timeout: 0,
                processData: true,
                cache: true,
                xhrFields: {
                    withCredentials: true
                }
            };
            function mimeToDataType(mime) {
                if (mime) {
                    mime = mime.split(";", 2)[0];
                }
                if (mime) {
                    if (mime == htmlType) {
                        return "html";
                    } else if (mime == jsonType) {
                        return "json";
                    } else if (scriptTypeRE.test(mime)) {
                        return "script";
                    } else if (xmlTypeRE.test(mime)) {
                        return "xml";
                    }
                }
                return "text";
            }
            function appendQuery(url, query) {
                if (query == "") return url;
                return (url + "&" + query).replace(/[&?]{1,2}/, "?");
            }
            function serializeData(options) {
                options.data = options.data || options.query;
                if (options.processData && options.data && type(options.data) != "string") {
                    options.data = param(options.data, options.traditional);
                }
                if (options.data && (!options.type || options.type.toUpperCase() == "GET")) {
                    options.url = appendQuery(options.url, options.data);
                    options.data = undefined;
                }
            }
            function serialize(params, obj, traditional, scope) {
                var t, array = isArray(obj), hash = isPlainObject(obj);
                each(obj, function(key, value) {
                    t = type(value);
                    if (scope) key = traditional ? scope : scope + "[" + (hash || t == "object" || t == "array" ? key : "") + "]";
                    if (!scope && array) params.add(value.name, value.value); else if (t == "array" || !traditional && t == "object") serialize(params, value, traditional, key); else params.add(key, value);
                });
            }
            var param = function(obj, traditional) {
                var params = [];
                params.add = function(key, value) {
                    if (isFunction(value)) value = value();
                    if (value == null) value = "";
                    this.push(escape(key) + "=" + escape(value));
                };
                serialize(params, obj, traditional);
                return params.join("&").replace(/%20/g, "+");
            };
            var Xhr = Evented.inherit({
                klassName: "Xhr",
                _request: function(args) {
                    var _ = this._, self = this, options = mixin({}, XhrDefaultOptions, _.options, args), xhr = _.xhr = new XMLHttpRequest();
                    serializeData(options);
                    var dataType = options.dataType || options.handleAs, mime = options.mimeType || options.accepts[dataType], headers = options.headers, xhrFields = options.xhrFields, isFormData = options.data && options.data instanceof FormData, basicAuthorizationToken = options.basicAuthorizationToken, type = options.type, url = options.url, async = options.async, user = options.user, password = options.password, deferred = new Deferred(), contentType = isFormData ? false : "application/x-www-form-urlencoded";
                    if (xhrFields) {
                        for (name in xhrFields) {
                            xhr[name] = xhrFields[name];
                        }
                    }
                    if (mime && mime.indexOf(",") > -1) {
                        mime = mime.split(",", 2)[0];
                    }
                    if (mime && xhr.overrideMimeType) {
                        xhr.overrideMimeType(mime);
                    }
                    var finish = function() {
                        xhr.onloadend = noop;
                        xhr.onabort = noop;
                        xhr.onprogress = noop;
                        xhr.ontimeout = noop;
                        xhr = null;
                    };
                    var onloadend = function() {
                        var result, error = false;
                        if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304 || xhr.status == 0 && url.startsWith("file:")) {
                            dataType = dataType || mimeToDataType(options.mimeType || xhr.getResponseHeader("content-type"));
                            result = xhr.responseText;
                            try {
                                if (dataType == "script") {
                                    eval(result);
                                } else if (dataType == "xml") {
                                    result = xhr.responseXML;
                                } else if (dataType == "json") {
                                    result = blankRE.test(result) ? null : JSON.parse(result);
                                } else if (dataType == "blob") {
                                    result = Blob([ xhrObj.response ]);
                                } else if (dataType == "arraybuffer") {
                                    result = xhr.reponse;
                                }
                            } catch (e) {
                                error = e;
                            }
                            if (error) {
                                deferred.reject(error, xhr.status, xhr);
                            } else {
                                deferred.resolve(result, xhr.status, xhr);
                            }
                        } else {
                            deferred.reject(new Error(xhr.statusText), xhr.status, xhr);
                        }
                        finish();
                    };
                    var onabort = function() {
                        if (deferred) {
                            deferred.reject(new Error("abort"), xhr.status, xhr);
                        }
                        finish();
                    };
                    var ontimeout = function() {
                        if (deferred) {
                            deferred.reject(new Error("timeout"), xhr.status, xhr);
                        }
                        finish();
                    };
                    var onprogress = function(evt) {
                        if (deferred) {
                            deferred.progress(evt, xhr.status, xhr);
                        }
                    };
                    xhr.onloadend = onloadend;
                    xhr.onabort = onabort;
                    xhr.ontimeout = ontimeout;
                    xhr.onprogress = onprogress;
                    xhr.open(type, url, async, user, password);
                    if (headers) {
                        for (var key in headers) {
                            var value = headers[key];
                            if (key.toLowerCase() === "content-type") {
                                contentType = headers[hdr];
                            } else {
                                xhr.setRequestHeader(key, value);
                            }
                        }
                    }
                    if (contentType && contentType !== false) {
                        xhr.setRequestHeader("Content-Type", contentType);
                    }
                    if (!headers || !("X-Requested-With" in headers)) {
                        xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
                    }
                    if (basicAuthorizationToken) {
                        xhr.setRequestHeader("Authorization", basicAuthorizationToken);
                    }
                    xhr.send(options.data ? options.data : null);
                    return deferred.promise;
                },
                abort: function() {
                    var _ = this._, xhr = _.xhr;
                    if (xhr) {
                        xhr.abort();
                    }
                },
                request: function(args) {
                    return this._request(args);
                },
                get: function(args) {
                    args = args || {};
                    args.type = "GET";
                    return this._request(args);
                },
                post: function(args) {
                    args = args || {};
                    args.type = "POST";
                    return this._request(args);
                },
                patch: function(args) {
                    args = args || {};
                    args.type = "PATCH";
                    return this._request(args);
                },
                put: function(args) {
                    args = args || {};
                    args.type = "PUT";
                    return this._request(args);
                },
                del: function(args) {
                    args = args || {};
                    args.type = "DELETE";
                    return this._request(args);
                },
                init: function(options) {
                    this._ = {
                        options: options || {}
                    };
                }
            });
            [ "request", "get", "post", "put", "del", "patch" ].forEach(function(name) {
                Xhr[name] = function(url, args) {
                    var xhr = new Xhr({
                        url: url
                    });
                    return xhr[name](args);
                };
            });
            Xhr.defaultOptions = XhrDefaultOptions;
            Xhr.param = param;
            return Xhr;
        }();
        var Restful = Evented.inherit({
            klassName: "Restful",
            idAttribute: "id",
            getBaseUrl: function(args) {
                var baseEndpoint = String.substitute(this.baseEndpoint, args), baseUrl = this.server + this.basePath + baseEndpoint;
                if (args[this.idAttribute] !== undefined) {
                    baseUrl = baseUrl + "/" + args[this.idAttribute];
                }
                return baseUrl;
            },
            _head: function(args) {},
            _get: function(args) {
                return Xhr.get(this.getBaseUrl(args), args);
            },
            _post: function(args, verb) {
                var url = this.getBaseUrl(args);
                if (verb) {
                    url = url + "/" + verb;
                }
                return Xhr.post(url, args);
            },
            _put: function(args, verb) {
                var url = this.getBaseUrl(args);
                if (verb) {
                    url = url + "/" + verb;
                }
                return Xhr.put(url, args);
            },
            _delete: function(args) {
                var url = this.getBaseUrl(args);
                return Xhr.del(url);
            },
            _patch: function(args) {
                var url = this.getBaseUrl(args);
                return Xhr.patch(url, args);
            },
            query: function(params) {
                return this._post(params);
            },
            retrieve: function(params) {
                return this._get(params);
            },
            create: function(params) {
                return this._post(params);
            },
            update: function(params) {
                return this._put(params);
            },
            "delete": function(params) {
                return this._delete(params);
            },
            patch: function(params) {
                return this._patch(params);
            },
            init: function(params) {
                mixin(this, params);
            }
        });
        function langx() {
            return langx;
        }
        mixin(langx, {
            after: aspect("after"),
            allKeys: allKeys,
            around: aspect("around"),
            ArrayStore: ArrayStore,
            before: aspect("before"),
            camelCase: function(str) {
                return str.replace(/-([\da-z])/g, function(a) {
                    return a.toUpperCase().replace("-", "");
                });
            },
            clone: clone,
            compact: compact,
            createEvent: createEvent,
            dasherize: dasherize,
            debounce: debounce,
            defaults: createAssigner(allKeys, true),
            delegate: delegate,
            Deferred: Deferred,
            Evented: Evented,
            defer: defer,
            deserializeValue: deserializeValue,
            each: each,
            first: function(items, n) {
                if (n) {
                    return items.slice(0, n);
                } else {
                    return items[0];
                }
            },
            flatten: flatten,
            funcArg: funcArg,
            getQueryParams: getQueryParams,
            has: has,
            inArray: inArray,
            isArray: isArray,
            isArrayLike: isArrayLike,
            isBoolean: isBoolean,
            isDefined: function(v) {
                return v !== undefined;
            },
            isDocument: isDocument,
            isEmptyObject: isEmptyObject,
            isEqual: isEqual,
            isFunction: isFunction,
            isHtmlNode: isHtmlNode,
            isMatch: isMatch,
            isNumber: isNumber,
            isObject: isObject,
            isPlainObject: isPlainObject,
            isString: isString,
            isSameOrigin: isSameOrigin,
            isWindow: isWindow,
            keys: keys,
            klass: function(props, parent, mixins, options) {
                return createClass(props, parent, mixins, options);
            },
            lowerFirst: function(str) {
                return str.charAt(0).toLowerCase() + str.slice(1);
            },
            makeArray: makeArray,
            map: map,
            mixin: mixin,
            noop: noop,
            proxy: proxy,
            removeItem: removeItem,
            Restful: Restful,
            result: result,
            returnTrue: function() {
                return true;
            },
            returnFalse: function() {
                return false;
            },
            safeMixin: safeMixin,
            serializeValue: function(value) {
                return JSON.stringify(value);
            },
            Stateful: Stateful,
            substitute: substitute,
            toPixel: toPixel,
            trim: trim,
            type: type,
            uid: uid,
            uniq: uniq,
            uniqueId: uniqueId,
            upperFirst: function(str) {
                return str.charAt(0).toUpperCase() + str.slice(1);
            },
            URL: typeof window !== "undefined" ? window.URL || window.webkitURL : null,
            values: values,
            Xhr: Xhr
        });
        return skylark.langx = langx;
    });
    define("skylark-utils/langx", [ "skylark-langx/langx" ], function(langx) {
        return langx;
    });
    define("skylark-utils/browser", [ "./skylark", "./langx" ], function(skylark, langx) {
        var checkedCssProperties = {
            transitionproperty: "TransitionProperty"
        };
        var css3PropPrefix = "", css3StylePrefix = "", css3EventPrefix = "", cssStyles = {}, cssProps = {}, vendorPrefix, vendorPrefixRE, vendorPrefixesRE = /^(Webkit|webkit|O|Moz|moz|ms)(.*)$/, document = window.document, testEl = document.createElement("div"), matchesSelector = testEl.webkitMatchesSelector || testEl.mozMatchesSelector || testEl.oMatchesSelector || testEl.matchesSelector, testStyle = testEl.style;
        for (var name in testStyle) {
            var matched = name.match(vendorPrefixRE || vendorPrefixesRE);
            if (matched) {
                if (!vendorPrefixRE) {
                    vendorPrefix = matched[1];
                    vendorPrefixRE = new RegExp("^(" + vendorPrefix + ")(.*)$");
                    css3StylePrefix = vendorPrefix;
                    css3PropPrefix = "-" + vendorPrefix.toLowerCase() + "-";
                    css3EventPrefix = vendorPrefix.toLowerCase();
                }
                cssStyles[langx.lowerFirst(matched[2])] = name;
                var cssPropName = langx.dasherize(matched[2]);
                cssProps[cssPropName] = css3PropPrefix + cssPropName;
            }
        }
        function normalizeCssEvent(name) {
            return css3EventPrefix ? css3EventPrefix + name : name.toLowerCase();
        }
        function normalizeCssProperty(name) {
            return cssProps[name] || name;
        }
        function normalizeStyleProperty(name) {
            return cssStyles[name] || name;
        }
        function browser() {
            return browser;
        }
        langx.mixin(browser, {
            css3PropPrefix: css3PropPrefix,
            normalizeStyleProperty: normalizeStyleProperty,
            normalizeCssProperty: normalizeCssProperty,
            normalizeCssEvent: normalizeCssEvent,
            matchesSelector: matchesSelector,
            location: function() {
                return window.location;
            },
            support: {}
        });
        testEl = null;
        return skylark.browser = browser;
    });
    define("skylark-utils/styler", [ "./skylark", "./langx" ], function(skylark, langx) {
        var every = Array.prototype.every, forEach = Array.prototype.forEach, camelCase = langx.camelCase, dasherize = langx.dasherize;
        function maybeAddPx(name, value) {
            return typeof value == "number" && !cssNumber[dasherize(name)] ? value + "px" : value;
        }
        var cssNumber = {
            "column-count": 1,
            columns: 1,
            "font-weight": 1,
            "line-height": 1,
            opacity: 1,
            "z-index": 1,
            zoom: 1
        }, classReCache = {};
        function classRE(name) {
            return name in classReCache ? classReCache[name] : classReCache[name] = new RegExp("(^|\\s)" + name + "(\\s|$)");
        }
        function className(node, value) {
            var klass = node.className || "", svg = klass && klass.baseVal !== undefined;
            if (value === undefined) return svg ? klass.baseVal : klass;
            svg ? klass.baseVal = value : node.className = value;
        }
        var elementDisplay = {};
        function defaultDisplay(nodeName) {
            var element, display;
            if (!elementDisplay[nodeName]) {
                element = document.createElement(nodeName);
                document.body.appendChild(element);
                display = getComputedStyle(element, "").getPropertyValue("display");
                element.parentNode.removeChild(element);
                display == "none" && (display = "block");
                elementDisplay[nodeName] = display;
            }
            return elementDisplay[nodeName];
        }
        function show(elm) {
            styler.css(elm, "display", "");
            if (styler.css(elm, "display") == "none") {
                styler.css(elm, "display", defaultDisplay(elm.nodeName));
            }
            return this;
        }
        function isInvisible(elm) {
            return styler.css(elm, "display") == "none" || styler.css(elm, "opacity") == 0;
        }
        function hide(elm) {
            styler.css(elm, "display", "none");
            return this;
        }
        function addClass(elm, name) {
            if (!name) return this;
            var cls = className(elm), names;
            if (langx.isString(name)) {
                names = name.split(/\s+/g);
            } else {
                names = name;
            }
            names.forEach(function(klass) {
                var re = classRE(klass);
                if (!cls.match(re)) {
                    cls += (cls ? " " : "") + klass;
                }
            });
            className(elm, cls);
            return this;
        }
        function css(elm, property, value) {
            if (arguments.length < 3) {
                var computedStyle, computedStyle = getComputedStyle(elm, "");
                if (langx.isString(property)) {
                    return elm.style[camelCase(property)] || computedStyle.getPropertyValue(property);
                } else if (langx.isArrayLike(property)) {
                    var props = {};
                    forEach.call(property, function(prop) {
                        props[prop] = elm.style[camelCase(prop)] || computedStyle.getPropertyValue(prop);
                    });
                    return props;
                }
            }
            var css = "";
            if (typeof property == "string") {
                if (!value && value !== 0) {
                    elm.style.removeProperty(dasherize(property));
                } else {
                    css = dasherize(property) + ":" + maybeAddPx(property, value);
                }
            } else {
                for (key in property) {
                    if (property[key] === undefined) {
                        continue;
                    }
                    if (!property[key] && property[key] !== 0) {
                        elm.style.removeProperty(dasherize(key));
                    } else {
                        css += dasherize(key) + ":" + maybeAddPx(key, property[key]) + ";";
                    }
                }
            }
            elm.style.cssText += ";" + css;
            return this;
        }
        function hasClass(elm, name) {
            var re = classRE(name);
            return elm.className && elm.className.match(re);
        }
        function removeClass(elm, name) {
            if (name) {
                var cls = className(elm), names;
                if (langx.isString(name)) {
                    names = name.split(/\s+/g);
                } else {
                    names = name;
                }
                names.forEach(function(klass) {
                    var re = classRE(klass);
                    if (cls.match(re)) {
                        cls = cls.replace(re, " ");
                    }
                });
                className(elm, cls.trim());
            } else {
                className(elm, "");
            }
            return this;
        }
        function toggleClass(elm, name, when) {
            var self = this;
            name.split(/\s+/g).forEach(function(klass) {
                if (when === undefined) {
                    when = !self.hasClass(elm, klass);
                }
                if (when) {
                    self.addClass(elm, klass);
                } else {
                    self.removeClass(elm, klass);
                }
            });
            return self;
        }
        var styler = function() {
            return styler;
        };
        langx.mixin(styler, {
            autocssfix: true,
            cssHooks: {},
            addClass: addClass,
            className: className,
            css: css,
            hasClass: hasClass,
            hide: hide,
            isInvisible: isInvisible,
            removeClass: removeClass,
            show: show,
            toggleClass: toggleClass
        });
        return skylark.styler = styler;
    });
    define("skylark-utils/noder", [ "./skylark", "./langx", "./styler" ], function(skylark, langx, styler) {
        var isIE = !!navigator.userAgent.match(/Trident/g) || !!navigator.userAgent.match(/MSIE/g), fragmentRE = /^\s*<(\w+|!)[^>]*>/, singleTagRE = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, div = document.createElement("div"), table = document.createElement("table"), tableBody = document.createElement("tbody"), tableRow = document.createElement("tr"), containers = {
            tr: tableBody,
            tbody: table,
            thead: table,
            tfoot: table,
            td: tableRow,
            th: tableRow,
            "*": div
        }, rootNodeRE = /^(?:body|html)$/i, map = Array.prototype.map, slice = Array.prototype.slice;
        function ensureNodes(nodes, copyByClone) {
            if (!langx.isArrayLike(nodes)) {
                nodes = [ nodes ];
            }
            if (copyByClone) {
                nodes = map.call(nodes, function(node) {
                    return node.cloneNode(true);
                });
            }
            return langx.flatten(nodes);
        }
        function nodeName(elm, chkName) {
            var name = elm.nodeName && elm.nodeName.toLowerCase();
            if (chkName !== undefined) {
                return name === chkName.toLowerCase();
            }
            return name;
        }
        function contents(elm) {
            if (nodeName(elm, "iframe")) {
                return elm.contentDocument;
            }
            return elm.childNodes;
        }
        function html(node, html) {
            if (html === undefined) {
                return node.innerHTML;
            } else {
                this.empty(node);
                html = html || "";
                if (langx.isString(html) || langx.isNumber(html)) {
                    node.innerHTML = html;
                } else if (langx.isArrayLike(html)) {
                    for (var i = 0; i < html.length; i++) {
                        node.appendChild(html[i]);
                    }
                } else {
                    node.appendChild(html);
                }
            }
        }
        function clone(node, deep) {
            var self = this, clone;
            if (!isIE || node.nodeType !== 1 || deep) {
                return node.cloneNode(deep);
            }
            if (!deep) {
                clone = document.createElement(node.nodeName);
                each(self.getAttribs(node), function(attr) {
                    self.setAttrib(clone, attr.nodeName, self.getAttrib(node, attr.nodeName));
                });
                return clone;
            }
        }
        function createElement(tag, props, parent) {
            var node = document.createElement(tag);
            if (props) {
                for (var name in props) {
                    node.setAttribute(name, props[name]);
                }
            }
            if (parent) {
                append(parent, node);
            }
            return node;
        }
        function createFragment(html) {
            html = langx.trim(html);
            if (singleTagRE.test(html)) {
                return [ createElement(RegExp.$1) ];
            }
            var name = fragmentRE.test(html) && RegExp.$1;
            if (!(name in containers)) {
                name = "*";
            }
            var container = containers[name];
            container.innerHTML = "" + html;
            dom = slice.call(container.childNodes);
            dom.forEach(function(node) {
                container.removeChild(node);
            });
            return dom;
        }
        function contains(node, child) {
            return isChildOf(child, node);
        }
        function createTextNode(text) {
            return document.createTextNode(text);
        }
        function doc() {
            return document;
        }
        function empty(node) {
            while (node.hasChildNodes()) {
                var child = node.firstChild;
                node.removeChild(child);
            }
            return this;
        }
        function isChildOf(node, parent, directly) {
            if (directly) {
                return node.parentNode === parent;
            }
            if (document.documentElement.contains) {
                return parent.contains(node);
            }
            while (node) {
                if (parent === node) {
                    return true;
                }
                node = node.parentNode;
            }
            return false;
        }
        function isDoc(node) {
            return node != null && node.nodeType == node.DOCUMENT_NODE;
        }
        function ownerDoc(elm) {
            if (!elm) {
                return document;
            }
            if (elm.nodeType == 9) {
                return elm;
            }
            return elm.ownerDocument;
        }
        function ownerWindow(elm) {
            var doc = ownerDoc(elm);
            return doc.defaultView || doc.parentWindow;
        }
        function after(node, placing, copyByClone) {
            var refNode = node, parent = refNode.parentNode;
            if (parent) {
                var nodes = ensureNodes(placing, copyByClone), refNode = refNode.nextSibling;
                for (var i = 0; i < nodes.length; i++) {
                    if (refNode) {
                        parent.insertBefore(nodes[i], refNode);
                    } else {
                        parent.appendChild(nodes[i]);
                    }
                }
            }
            return this;
        }
        function before(node, placing, copyByClone) {
            var refNode = node, parent = refNode.parentNode;
            if (parent) {
                var nodes = ensureNodes(placing, copyByClone);
                for (var i = 0; i < nodes.length; i++) {
                    parent.insertBefore(nodes[i], refNode);
                }
            }
            return this;
        }
        function prepend(node, placing, copyByClone) {
            var parentNode = node, refNode = parentNode.firstChild, nodes = ensureNodes(placing, copyByClone);
            for (var i = 0; i < nodes.length; i++) {
                if (refNode) {
                    parentNode.insertBefore(nodes[i], refNode);
                } else {
                    parentNode.appendChild(nodes[i]);
                }
            }
            return this;
        }
        function append(node, placing, copyByClone) {
            var parentNode = node, nodes = ensureNodes(placing, copyByClone);
            for (var i = 0; i < nodes.length; i++) {
                parentNode.appendChild(nodes[i]);
            }
            return this;
        }
        function overlay(elm, params) {
            var overlayDiv = createElement("div", params);
            styler.css(overlayDiv, {
                position: "absolute",
                top: 0,
                left: 0,
                width: "100%",
                height: "100%",
                zIndex: 2147483647,
                opacity: .7
            });
            elm.appendChild(overlayDiv);
            return overlayDiv;
        }
        function remove(node) {
            if (node && node.parentNode) {
                try {
                    node.parentNode.removeChild(node);
                } catch (e) {
                    console.warn("The node is already removed", e);
                }
            }
            return this;
        }
        function replace(node, oldNode) {
            oldNode.parentNode.replaceChild(node, oldNode);
            return this;
        }
        function throb(elm, params) {
            params = params || {};
            var self = this, text = params.text, style = params.style, time = params.time, callback = params.callback, timer, throbber = this.createElement("div", {
                className: params.className || "throbber",
                style: style
            }), _overlay = overlay(throbber, {
                className: "overlay fade"
            }), throb = this.createElement("div", {
                className: "throb"
            }), textNode = this.createTextNode(text || ""), remove = function() {
                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                }
                if (throbber) {
                    self.remove(throbber);
                    throbber = null;
                }
            }, update = function(params) {
                if (params && params.text && throbber) {
                    textNode.nodeValue = params.text;
                }
            };
            throb.appendChild(textNode);
            throbber.appendChild(throb);
            elm.appendChild(throbber);
            var end = function() {
                remove();
                if (callback) callback();
            };
            if (time) {
                timer = setTimeout(end, time);
            }
            return {
                remove: remove,
                update: update
            };
        }
        function traverse(node, fn) {
            fn(node);
            for (var i = 0, len = node.childNodes.length; i < len; i++) {
                traverse(node.childNodes[i], fn);
            }
            return this;
        }
        function reverse(node) {
            var firstChild = node.firstChild;
            for (var i = node.children.length - 1; i > 0; i--) {
                if (i > 0) {
                    var child = node.children[i];
                    node.insertBefore(child, firstChild);
                }
            }
        }
        function wrapper(node, wrapperNode) {
            if (langx.isString(wrapperNode)) {
                wrapperNode = this.createFragment(wrapperNode).firstChild;
            }
            node.parentNode.insertBefore(wrapperNode, node);
            wrapperNode.appendChild(node);
        }
        function wrapperInner(node, wrapperNode) {
            var childNodes = slice.call(node.childNodes);
            node.appendChild(wrapperNode);
            for (var i = 0; i < childNodes.length; i++) {
                wrapperNode.appendChild(childNodes[i]);
            }
            return this;
        }
        function unwrap(node) {
            var child, parent = node.parentNode;
            if (parent) {
                if (this.isDoc(parent.parentNode)) return;
                parent.parentNode.insertBefore(node, parent);
            }
        }
        function noder() {
            return noder;
        }
        langx.mixin(noder, {
            clone: clone,
            contents: contents,
            createElement: createElement,
            createFragment: createFragment,
            contains: contains,
            createTextNode: createTextNode,
            doc: doc,
            empty: empty,
            html: html,
            isChildOf: isChildOf,
            isDoc: isDoc,
            ownerDoc: ownerDoc,
            ownerWindow: ownerWindow,
            after: after,
            before: before,
            prepend: prepend,
            append: append,
            remove: remove,
            replace: replace,
            throb: throb,
            traverse: traverse,
            reverse: reverse,
            wrapper: wrapper,
            wrapperInner: wrapperInner,
            unwrap: unwrap
        });
        return skylark.noder = noder;
    });
    define("skylark-utils/finder", [ "./skylark", "./langx", "./browser", "./noder" ], function(skylark, langx, browser, noder, velm) {
        var local = {}, filter = Array.prototype.filter, slice = Array.prototype.slice, nativeMatchesSelector = browser.matchesSelector;
        (function() {
            var parsed, separatorIndex, combinatorIndex, reversed, cache = {}, reverseCache = {}, reUnescape = /\\/g;
            var parse = function(expression, isReversed) {
                if (expression == null) return null;
                if (expression.Slick === true) return expression;
                expression = ("" + expression).replace(/^\s+|\s+$/g, "");
                reversed = !!isReversed;
                var currentCache = reversed ? reverseCache : cache;
                if (currentCache[expression]) return currentCache[expression];
                parsed = {
                    Slick: true,
                    expressions: [],
                    raw: expression,
                    reverse: function() {
                        return parse(this.raw, true);
                    }
                };
                separatorIndex = -1;
                while (expression != (expression = expression.replace(regexp, parser))) ;
                parsed.length = parsed.expressions.length;
                return currentCache[parsed.raw] = reversed ? reverse(parsed) : parsed;
            };
            var reverseCombinator = function(combinator) {
                if (combinator === "!") return " "; else if (combinator === " ") return "!"; else if (/^!/.test(combinator)) return combinator.replace(/^!/, ""); else return "!" + combinator;
            };
            var reverse = function(expression) {
                var expressions = expression.expressions;
                for (var i = 0; i < expressions.length; i++) {
                    var exp = expressions[i];
                    var last = {
                        parts: [],
                        tag: "*",
                        combinator: reverseCombinator(exp[0].combinator)
                    };
                    for (var j = 0; j < exp.length; j++) {
                        var cexp = exp[j];
                        if (!cexp.reverseCombinator) cexp.reverseCombinator = " ";
                        cexp.combinator = cexp.reverseCombinator;
                        delete cexp.reverseCombinator;
                    }
                    exp.reverse().push(last);
                }
                return expression;
            };
            var escapeRegExp = function() {
                var from = /(?=[\-\[\]{}()*+?.\\\^$|,#\s])/g, to = "\\";
                return function(string) {
                    return string.replace(from, to);
                };
            }();
            var regexp = new RegExp("^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:([\"'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)".replace(/<combinator>/, "[" + escapeRegExp(">+~`!@$%^&={}\\;</") + "]").replace(/<unicode>/g, "(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])").replace(/<unicode1>/g, "(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])"));
            function parser(rawMatch, separator, combinator, combinatorChildren, tagName, id, className, attributeKey, attributeOperator, attributeQuote, attributeValue, pseudoMarker, pseudoClass, pseudoQuote, pseudoClassQuotedValue, pseudoClassValue) {
                if (separator || separatorIndex === -1) {
                    parsed.expressions[++separatorIndex] = [];
                    combinatorIndex = -1;
                    if (separator) return "";
                }
                if (combinator || combinatorChildren || combinatorIndex === -1) {
                    combinator = combinator || " ";
                    var currentSeparator = parsed.expressions[separatorIndex];
                    if (reversed && currentSeparator[combinatorIndex]) currentSeparator[combinatorIndex].reverseCombinator = reverseCombinator(combinator);
                    currentSeparator[++combinatorIndex] = {
                        combinator: combinator,
                        tag: "*"
                    };
                }
                var currentParsed = parsed.expressions[separatorIndex][combinatorIndex];
                if (tagName) {
                    currentParsed.tag = tagName.replace(reUnescape, "");
                } else if (id) {
                    currentParsed.id = id.replace(reUnescape, "");
                } else if (className) {
                    className = className.replace(reUnescape, "");
                    if (!currentParsed.classList) currentParsed.classList = [];
                    if (!currentParsed.classes) currentParsed.classes = [];
                    currentParsed.classList.push(className);
                    currentParsed.classes.push({
                        value: className,
                        regexp: new RegExp("(^|\\s)" + escapeRegExp(className) + "(\\s|$)")
                    });
                } else if (pseudoClass) {
                    pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue;
                    pseudoClassValue = pseudoClassValue ? pseudoClassValue.replace(reUnescape, "") : null;
                    if (!currentParsed.pseudos) currentParsed.pseudos = [];
                    currentParsed.pseudos.push({
                        key: pseudoClass.replace(reUnescape, ""),
                        value: pseudoClassValue,
                        type: pseudoMarker.length == 1 ? "class" : "element"
                    });
                } else if (attributeKey) {
                    attributeKey = attributeKey.replace(reUnescape, "");
                    attributeValue = (attributeValue || "").replace(reUnescape, "");
                    var test, regexp;
                    switch (attributeOperator) {
                      case "^=":
                        regexp = new RegExp("^" + escapeRegExp(attributeValue));
                        break;

                      case "$=":
                        regexp = new RegExp(escapeRegExp(attributeValue) + "$");
                        break;

                      case "~=":
                        regexp = new RegExp("(^|\\s)" + escapeRegExp(attributeValue) + "(\\s|$)");
                        break;

                      case "|=":
                        regexp = new RegExp("^" + escapeRegExp(attributeValue) + "(-|$)");
                        break;

                      case "=":
                        test = function(value) {
                            return attributeValue == value;
                        };
                        break;

                      case "*=":
                        test = function(value) {
                            return value && value.indexOf(attributeValue) > -1;
                        };
                        break;

                      case "!=":
                        test = function(value) {
                            return attributeValue != value;
                        };
                        break;

                      default:
                        test = function(value) {
                            return !!value;
                        };
                    }
                    if (attributeValue == "" && /^[*$^]=$/.test(attributeOperator)) test = function() {
                        return false;
                    };
                    if (!test) test = function(value) {
                        return value && regexp.test(value);
                    };
                    if (!currentParsed.attributes) currentParsed.attributes = [];
                    currentParsed.attributes.push({
                        key: attributeKey,
                        operator: attributeOperator,
                        value: attributeValue,
                        test: test
                    });
                }
                return "";
            }
            var Slick = this.Slick || {};
            Slick.parse = function(expression) {
                return parse(expression);
            };
            Slick.escapeRegExp = escapeRegExp;
            if (!this.Slick) this.Slick = Slick;
        }).apply(local);
        var simpleClassSelectorRE = /^\.([\w-]*)$/, simpleIdSelectorRE = /^#([\w-]*)$/, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, slice = Array.prototype.slice;
        local.parseSelector = local.Slick.parse;
        var pseudos = local.pseudos = {
            button: function(elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === "button" || name === "button";
            },
            checked: function(elm) {
                return !!elm.checked;
            },
            contains: function(elm, idx, nodes, text) {
                if ($(this).text().indexOf(text) > -1) return this;
            },
            disabled: function(elm) {
                return !!elm.disabled;
            },
            enabled: function(elm) {
                return !elm.disabled;
            },
            eq: function(elm, idx, nodes, value) {
                return idx == value;
            },
            even: function(elm, idx, nodes, value) {
                return idx % 2 === 1;
            },
            focus: function(elm) {
                return document.activeElement === elm && (elm.href || elm.type || elm.tabindex);
            },
            first: function(elm, idx) {
                return idx === 0;
            },
            gt: function(elm, idx, nodes, value) {
                return idx > value;
            },
            has: function(elm, idx, nodes, sel) {
                return find(elm, sel);
            },
            header: function(elem) {
                return rheader.test(elem.nodeName);
            },
            hidden: function(elm) {
                return !local.pseudos["visible"](elm);
            },
            input: function(elem) {
                return rinputs.test(elem.nodeName);
            },
            last: function(elm, idx, nodes) {
                return idx === nodes.length - 1;
            },
            lt: function(elm, idx, nodes, value) {
                return idx < value;
            },
            not: function(elm, idx, nodes, sel) {
                return !matches(elm, sel);
            },
            odd: function(elm, idx, nodes, value) {
                return idx % 2 === 0;
            },
            parent: function(elm) {
                return !!elm.parentNode;
            },
            selected: function(elm) {
                return !!elm.selected;
            },
            text: function(elm) {
                return elm.type === "text";
            },
            visible: function(elm) {
                return elm.offsetWidth && elm.offsetWidth;
            }
        };
        [ "first", "eq", "last" ].forEach(function(item) {
            pseudos[item].isArrayFilter = true;
        });
        pseudos["nth"] = pseudos["eq"];
        function createInputPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === type;
            };
        }
        function createButtonPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === "input" || name === "button") && elem.type === type;
            };
        }
        for (i in {
            radio: true,
            checkbox: true,
            file: true,
            password: true,
            image: true
        }) {
            pseudos[i] = createInputPseudo(i);
        }
        for (i in {
            submit: true,
            reset: true
        }) {
            pseudos[i] = createButtonPseudo(i);
        }
        local.divide = function(cond) {
            var nativeSelector = "", customPseudos = [], tag, id, classes, attributes, pseudos;
            if (id = cond.id) {
                nativeSelector += "#" + id;
            }
            if (classes = cond.classes) {
                for (var i = classes.length; i--; ) {
                    nativeSelector += "." + classes[i].value;
                }
            }
            if (attributes = cond.attributes) {
                for (var i = 0; i < attributes.length; i++) {
                    if (attributes[i].operator) {
                        nativeSelector += "[" + attributes[i].key + attributes[i].operator + JSON.stringify(attributes[i].value) + "]";
                    } else {
                        nativeSelector += "[" + attributes[i].key + "]";
                    }
                }
            }
            if (pseudos = cond.pseudos) {
                for (i = pseudos.length; i--; ) {
                    part = pseudos[i];
                    if (this.pseudos[part.key]) {
                        customPseudos.push(part);
                    } else {
                        if (part.value !== undefined) {
                            nativeSelector += ":" + part.key + "(" + JSON.stringify(part);
                        }
                    }
                }
            }
            if (tag = cond.tag) {
                nativeSelector = tag.toUpperCase() + nativeSelector;
            }
            if (!nativeSelector) {
                nativeSelector = "*";
            }
            return {
                nativeSelector: nativeSelector,
                customPseudos: customPseudos
            };
        };
        local.check = function(node, cond, idx, nodes, arrayFilte) {
            var tag, id, classes, attributes, pseudos, i, part, cls, pseudo;
            if (!arrayFilte) {
                if (tag = cond.tag) {
                    var nodeName = node.nodeName.toUpperCase();
                    if (tag == "*") {
                        if (nodeName < "@") return false;
                    } else {
                        if (nodeName != (tag || "").toUpperCase()) return false;
                    }
                }
                if (id = cond.id) {
                    if (node.getAttribute("id") != id) {
                        return false;
                    }
                }
                if (classes = cond.classes) {
                    for (i = classes.length; i--; ) {
                        cls = node.getAttribute("class");
                        if (!(cls && classes[i].regexp.test(cls))) return false;
                    }
                }
                if (attributes = cond.attributes) {
                    for (i = attributes.length; i--; ) {
                        part = attributes[i];
                        if (part.operator ? !part.test(node.getAttribute(part.key)) : !node.hasAttribute(part.key)) return false;
                    }
                }
            }
            if (pseudos = cond.pseudos) {
                for (i = pseudos.length; i--; ) {
                    part = pseudos[i];
                    if (pseudo = this.pseudos[part.key]) {
                        if (arrayFilte && pseudo.isArrayFilter || !arrayFilte && !pseudo.isArrayFilter) {
                            if (!pseudo(node, idx, nodes, part.value)) {
                                return false;
                            }
                        }
                    } else {
                        if (!arrayFilte && !nativeMatchesSelector.call(node, part.key)) {
                            return false;
                        }
                    }
                }
            }
            return true;
        };
        local.match = function(node, selector) {
            var parsed;
            if (langx.isString(selector)) {
                parsed = local.Slick.parse(selector);
            } else {
                parsed = selector;
            }
            if (!parsed) {
                return true;
            }
            var expressions = parsed.expressions, simpleExpCounter = 0, i, currentExpression;
            for (i = 0; currentExpression = expressions[i]; i++) {
                if (currentExpression.length == 1) {
                    var exp = currentExpression[0];
                    if (this.check(node, exp)) {
                        return true;
                    }
                    simpleExpCounter++;
                }
            }
            if (simpleExpCounter == parsed.length) {
                return false;
            }
            var nodes = this.query(document, parsed), item;
            for (i = 0; item = nodes[i++]; ) {
                if (item === node) {
                    return true;
                }
            }
            return false;
        };
        local.filterSingle = function(nodes, exp) {
            var matchs = filter.call(nodes, function(node, idx) {
                return local.check(node, exp, idx, nodes, false);
            });
            matchs = filter.call(matchs, function(node, idx) {
                return local.check(node, exp, idx, matchs, true);
            });
            return matchs;
        };
        local.filter = function(nodes, selector) {
            var parsed;
            if (langx.isString(selector)) {
                parsed = local.Slick.parse(selector);
            } else {
                return local.filterSingle(nodes, selector);
            }
            var expressions = parsed.expressions, i, currentExpression, ret = [];
            for (i = 0; currentExpression = expressions[i]; i++) {
                if (currentExpression.length == 1) {
                    var exp = currentExpression[0];
                    var matchs = local.filterSingle(nodes, exp);
                    ret = langx.uniq(ret.concat(matchs));
                } else {
                    throw new Error("not supported selector:" + selector);
                }
            }
            return ret;
        };
        local.combine = function(elm, bit) {
            var op = bit.combinator, cond = bit, node1, nodes = [];
            switch (op) {
              case ">":
                nodes = children(elm, cond);
                break;

              case "+":
                node1 = nextSibling(elm, cond, true);
                if (node1) {
                    nodes.push(node1);
                }
                break;

              case "^":
                node1 = firstChild(elm, cond, true);
                if (node1) {
                    nodes.push(node1);
                }
                break;

              case "~":
                nodes = nextSiblings(elm, cond);
                break;

              case "++":
                var prev = previousSibling(elm, cond, true), next = nextSibling(elm, cond, true);
                if (prev) {
                    nodes.push(prev);
                }
                if (next) {
                    nodes.push(next);
                }
                break;

              case "~~":
                nodes = siblings(elm, cond);
                break;

              case "!":
                nodes = ancestors(elm, cond);
                break;

              case "!>":
                node1 = parent(elm, cond);
                if (node1) {
                    nodes.push(node1);
                }
                break;

              case "!+":
                nodes = previousSibling(elm, cond, true);
                break;

              case "!^":
                node1 = lastChild(elm, cond, true);
                if (node1) {
                    nodes.push(node1);
                }
                break;

              case "!~":
                nodes = previousSiblings(elm, cond);
                break;

              default:
                var divided = this.divide(bit);
                nodes = slice.call(elm.querySelectorAll(divided.nativeSelector));
                if (divided.customPseudos) {
                    for (var i = divided.customPseudos.length - 1; i >= 0; i--) {
                        nodes = filter.call(nodes, function(item, idx) {
                            return local.check(item, {
                                pseudos: [ divided.customPseudos[i] ]
                            }, idx, nodes, false);
                        });
                        nodes = filter.call(nodes, function(item, idx) {
                            return local.check(item, {
                                pseudos: [ divided.customPseudos[i] ]
                            }, idx, nodes, true);
                        });
                    }
                }
                break;
            }
            return nodes;
        };
        local.query = function(node, selector, single) {
            var parsed = this.Slick.parse(selector);
            var founds = [], currentExpression, currentBit, expressions = parsed.expressions;
            for (var i = 0; currentExpression = expressions[i]; i++) {
                var currentItems = [ node ], found;
                for (var j = 0; currentBit = currentExpression[j]; j++) {
                    found = langx.map(currentItems, function(item, i) {
                        return local.combine(item, currentBit);
                    });
                    if (found) {
                        currentItems = found;
                    }
                }
                if (found) {
                    founds = founds.concat(found);
                }
            }
            return founds;
        };
        function ancestor(node, selector, root) {
            var rootIsSelector = root && langx.isString(root);
            while (node = node.parentNode) {
                if (matches(node, selector)) {
                    return node;
                }
                if (root) {
                    if (rootIsSelector) {
                        if (matches(node, root)) {
                            break;
                        }
                    } else if (node == root) {
                        break;
                    }
                }
            }
            return null;
        }
        function ancestors(node, selector, root) {
            var ret = [], rootIsSelector = root && langx.isString(root);
            while ((node = node.parentNode) && node.nodeType !== 9) {
                ret.push(node);
                if (root) {
                    if (rootIsSelector) {
                        if (matches(node, root)) {
                            break;
                        }
                    } else if (node == root) {
                        break;
                    }
                }
            }
            if (selector) {
                ret = local.filter(ret, selector);
            }
            return ret;
        }
        function byId(id, doc) {
            doc = doc || noder.doc();
            return doc.getElementById(id);
        }
        function children(node, selector) {
            var childNodes = node.childNodes, ret = [];
            for (var i = 0; i < childNodes.length; i++) {
                var node = childNodes[i];
                if (node.nodeType == 1) {
                    ret.push(node);
                }
            }
            if (selector) {
                ret = local.filter(ret, selector);
            }
            return ret;
        }
        function closest(node, selector) {
            while (node && !matches(node, selector)) {
                node = node.parentNode;
            }
            return node;
        }
        function descendants(elm, selector) {
            try {
                return slice.call(elm.querySelectorAll(selector));
            } catch (matchError) {}
            return local.query(elm, selector);
        }
        function descendant(elm, selector) {
            try {
                return elm.querySelector(selector);
            } catch (matchError) {}
            var nodes = local.query(elm, selector);
            if (nodes.length > 0) {
                return nodes[0];
            } else {
                return null;
            }
        }
        function find(elm, selector) {
            if (!selector) {
                selector = elm;
                elm = document.body;
            }
            if (matches(elm, selector)) {
                return elm;
            } else {
                return descendant(elm, selector);
            }
        }
        function findAll(elm, selector) {
            if (!selector) {
                selector = elm;
                elm = document.body;
            }
            return descendants(elm, selector);
        }
        function firstChild(elm, selector, first) {
            var childNodes = elm.childNodes, node = childNodes[0];
            while (node) {
                if (node.nodeType == 1) {
                    if (!selector || matches(node, selector)) {
                        return node;
                    }
                    if (first) {
                        break;
                    }
                }
                node = node.nextSibling;
            }
            return null;
        }
        function lastChild(elm, selector, last) {
            var childNodes = elm.childNodes, node = childNodes[childNodes.length - 1];
            while (node) {
                if (node.nodeType == 1) {
                    if (!selector || matches(node, selector)) {
                        return node;
                    }
                    if (last) {
                        break;
                    }
                }
                node = node.previousSibling;
            }
            return null;
        }
        function matches(elm, selector) {
            if (!selector || !elm || elm.nodeType !== 1) {
                return false;
            }
            if (langx.isString(selector)) {
                try {
                    return nativeMatchesSelector.call(elm, selector.replace(/\[([^=]+)=\s*([^'"\]]+?)\s*\]/g, '[$1="$2"]'));
                } catch (matchError) {}
                return local.match(elm, selector);
            } else if (langx.isArrayLike(selector)) {
                return langx.inArray(elm, selector) > -1;
            } else if (langx.isPlainObject(selector)) {
                return local.check(elm, selector);
            } else {
                return elm === selector;
            }
        }
        function nextSibling(elm, selector, adjacent) {
            var node = elm.nextSibling;
            while (node) {
                if (node.nodeType == 1) {
                    if (!selector || matches(node, selector)) {
                        return node;
                    }
                    if (adjacent) {
                        break;
                    }
                }
                node = node.nextSibling;
            }
            return null;
        }
        function nextSiblings(elm, selector) {
            var node = elm.nextSibling, ret = [];
            while (node) {
                if (node.nodeType == 1) {
                    if (!selector || matches(node, selector)) {
                        ret.push(node);
                    }
                }
                node = node.nextSibling;
            }
            return ret;
        }
        function parent(elm, selector) {
            var node = elm.parentNode;
            if (node && (!selector || matches(node, selector))) {
                return node;
            }
            return null;
        }
        function previousSibling(elm, selector, adjacent) {
            var node = elm.previousSibling;
            while (node) {
                if (node.nodeType == 1) {
                    if (!selector || matches(node, selector)) {
                        return node;
                    }
                    if (adjacent) {
                        break;
                    }
                }
                node = node.previousSibling;
            }
            return null;
        }
        function previousSiblings(elm, selector) {
            var node = elm.previousSibling, ret = [];
            while (node) {
                if (node.nodeType == 1) {
                    if (!selector || matches(node, selector)) {
                        ret.push(node);
                    }
                }
                node = node.previousSibling;
            }
            return ret;
        }
        function siblings(elm, selector) {
            var node = elm.parentNode.firstChild, ret = [];
            while (node) {
                if (node.nodeType == 1 && node !== elm) {
                    if (!selector || matches(node, selector)) {
                        ret.push(node);
                    }
                }
                node = node.nextSibling;
            }
            return ret;
        }
        var finder = function() {
            return finder;
        };
        langx.mixin(finder, {
            ancestor: ancestor,
            ancestors: ancestors,
            byId: byId,
            children: children,
            closest: closest,
            descendant: descendant,
            descendants: descendants,
            find: find,
            findAll: findAll,
            firstChild: firstChild,
            lastChild: lastChild,
            matches: matches,
            nextSibling: nextSibling,
            nextSiblings: nextSiblings,
            parent: parent,
            previousSibling: previousSibling,
            previousSiblings: previousSiblings,
            pseudos: local.pseudos,
            siblings: siblings
        });
        return skylark.finder = finder;
    });
    define("skylark-utils/datax", [ "./skylark", "./langx", "./finder" ], function(skylark, langx, finder) {
        var map = Array.prototype.map, filter = Array.prototype.filter, camelCase = langx.camelCase, deserializeValue = langx.deserializeValue, capitalRE = /([A-Z])/g, propMap = {
            tabindex: "tabIndex",
            readonly: "readOnly",
            "for": "htmlFor",
            "class": "className",
            maxlength: "maxLength",
            cellspacing: "cellSpacing",
            cellpadding: "cellPadding",
            rowspan: "rowSpan",
            colspan: "colSpan",
            usemap: "useMap",
            frameborder: "frameBorder",
            contenteditable: "contentEditable"
        };
        function setAttribute(elm, name, value) {
            if (value == null) {
                elm.removeAttribute(name);
            } else {
                elm.setAttribute(name, value);
            }
        }
        function aria(elm, name, value) {
            return this.attr(elm, "aria-" + name, value);
        }
        function attr(elm, name, value) {
            if (value === undefined) {
                if (typeof name === "object") {
                    for (var attrName in name) {
                        attr(elm, attrName, name[attrName]);
                    }
                    return this;
                } else {
                    if (elm.hasAttribute(name)) {
                        return elm.getAttribute(name);
                    }
                }
            } else {
                elm.setAttribute(name, value);
                return this;
            }
        }
        function _attributeData(elm) {
            var store = {};
            langx.each(elm.attributes || [], function(i, attr) {
                if (attr.name.indexOf("data-") == 0) {
                    store[camelCase(attr.name.replace("data-", ""))] = deserializeValue(attr.value);
                }
            });
            return store;
        }
        function _store(elm, confirm) {
            var store = elm["_$_store"];
            if (!store && confirm) {
                store = elm["_$_store"] = _attributeData(elm);
            }
            return store;
        }
        function _getData(elm, name) {
            if (name === undefined) {
                return _store(elm, true);
            } else {
                var store = _store(elm);
                if (store) {
                    if (name in store) {
                        return store[name];
                    }
                    var camelName = camelCase(name);
                    if (camelName in store) {
                        return store[camelName];
                    }
                }
                var attrName = "data-" + name.replace(capitalRE, "-$1").toLowerCase();
                return attr(elm, attrName);
            }
        }
        function _setData(elm, name, value) {
            var store = _store(elm, true);
            store[camelCase(name)] = value;
        }
        function data(elm, name, value) {
            if (value === undefined) {
                if (typeof name === "object") {
                    for (var dataAttrName in name) {
                        _setData(elm, dataAttrName, name[dataAttrName]);
                    }
                    return this;
                } else {
                    return _getData(elm, name);
                }
            } else {
                _setData(elm, name, value);
                return this;
            }
        }
        function cleanData(elm) {
            if (elm["_$_store"]) {
                delete elm["_$_store"];
            }
        }
        function removeData(elm, names) {
            if (langx.isString(names)) {
                names = names.split(/\s+/);
            }
            var store = _store(elm, true);
            names.forEach(function(name) {
                delete store[name];
            });
            return this;
        }
        function pluck(nodes, property) {
            return map.call(nodes, function(elm) {
                return elm[property];
            });
        }
        function prop(elm, name, value) {
            name = propMap[name] || name;
            if (value === undefined) {
                return elm[name];
            } else {
                elm[name] = value;
                return this;
            }
        }
        function removeAttr(elm, name) {
            name.split(" ").forEach(function(attr) {
                setAttribute(elm, attr);
            });
            return this;
        }
        function removeProp(elm, name) {
            name.split(" ").forEach(function(prop) {
                delete elm[prop];
            });
            return this;
        }
        function text(elm, txt) {
            if (txt === undefined) {
                return elm.textContent;
            } else {
                elm.textContent = txt == null ? "" : "" + txt;
                return this;
            }
        }
        function val(elm, value) {
            if (value === undefined) {
                if (elm.multiple) {
                    var selectedOptions = filter.call(finder.find(elm, "option"), function(option) {
                        return option.selected;
                    });
                    return pluck(selectedOptions, "value");
                } else {
                    return elm.value;
                }
            } else {
                elm.value = value;
                return this;
            }
        }
        function datax() {
            return datax;
        }
        langx.mixin(datax, {
            aria: aria,
            attr: attr,
            cleanData: cleanData,
            data: data,
            pluck: pluck,
            prop: prop,
            removeAttr: removeAttr,
            removeData: removeData,
            removeProp: removeProp,
            text: text,
            val: val
        });
        return skylark.datax = datax;
    });
    define("skylark-utils/eventer", [ "./skylark", "./langx", "./browser", "./finder", "./noder", "./datax" ], function(skylark, langx, browser, finder, noder, datax) {
        var mixin = langx.mixin, each = langx.each, slice = Array.prototype.slice, uid = langx.uid, ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$)/, eventMethods = {
            preventDefault: "isDefaultPrevented",
            stopImmediatePropagation: "isImmediatePropagationStopped",
            stopPropagation: "isPropagationStopped"
        }, readyRE = /complete|loaded|interactive/;
        function compatible(event, source) {
            if (source || !event.isDefaultPrevented) {
                if (!source) {
                    source = event;
                }
                langx.each(eventMethods, function(name, predicate) {
                    var sourceMethod = source[name];
                    event[name] = function() {
                        this[predicate] = langx.returnTrue;
                        return sourceMethod && sourceMethod.apply(source, arguments);
                    };
                    event[predicate] = langx.returnFalse;
                });
            }
            return event;
        }
        function parse(event) {
            var segs = ("" + event).split(".");
            return {
                type: segs[0],
                ns: segs.slice(1).sort().join(" ")
            };
        }
        var createEvent = function() {
            var EventCtors = [ window["CustomEvent"], window["CompositionEvent"], window["DragEvent"], window["Event"], window["FocusEvent"], window["KeyboardEvent"], window["MessageEvent"], window["MouseEvent"], window["MouseScrollEvent"], window["MouseWheelEvent"], window["MutationEvent"], window["ProgressEvent"], window["TextEvent"], window["TouchEvent"], window["UIEvent"], window["WheelEvent"] ], NativeEvents = {
                compositionstart: 1,
                compositionend: 1,
                compositionupdate: 1,
                beforecopy: 2,
                beforecut: 2,
                beforepaste: 2,
                copy: 2,
                cut: 2,
                paste: 2,
                drag: 2,
                dragend: 2,
                dragenter: 2,
                dragexit: 2,
                dragleave: 2,
                dragover: 2,
                dragstart: 2,
                drop: 2,
                abort: 3,
                change: 3,
                error: 3,
                selectionchange: 3,
                submit: 3,
                reset: 3,
                focus: 4,
                blur: 4,
                focusin: 4,
                focusout: 4,
                keydown: 5,
                keypress: 5,
                keyup: 5,
                message: 6,
                click: 7,
                contextmenu: 7,
                dblclick: 7,
                mousedown: 7,
                mouseup: 7,
                mousemove: 7,
                mouseover: 7,
                mouseout: 7,
                mouseenter: 7,
                mouseleave: 7,
                textInput: 12,
                touchstart: 13,
                touchmove: 13,
                touchend: 13,
                load: 14,
                resize: 14,
                select: 14,
                scroll: 14,
                unload: 14,
                wheel: 15
            };
            function getEventCtor(type) {
                var idx = NativeEvents[type];
                if (!idx) {
                    idx = 0;
                }
                return EventCtors[idx];
            }
            return function(type, props) {
                if (langx.isString(type)) {
                    props = props || {};
                } else {
                    props = type || {};
                    type = props.type || "";
                }
                var parsed = parse(type);
                type = parsed.type;
                props = langx.mixin({
                    bubbles: true,
                    cancelable: true
                }, props);
                if (parsed.ns) {
                    props.namespace = parsed.ns;
                }
                var ctor = getEventCtor(type), e = new ctor(type, props);
                langx.safeMixin(e, props);
                return compatible(e);
            };
        }();
        function createProxy(src, props) {
            var key, proxy = {
                originalEvent: src
            };
            for (key in src) {
                if (key !== "keyIdentifier" && !ignoreProperties.test(key) && src[key] !== undefined) {
                    proxy[key] = src[key];
                }
            }
            if (props) {
                langx.mixin(proxy, props);
            }
            return compatible(proxy, src);
        }
        var specialEvents = {}, focusinSupported = "onfocusin" in window, focus = {
            focus: "focusin",
            blur: "focusout"
        }, hover = {
            mouseenter: "mouseover",
            mouseleave: "mouseout"
        }, realEvent = function(type) {
            return hover[type] || focusinSupported && focus[type] || type;
        }, handlers = {}, EventBindings = langx.klass({
            init: function(target, event) {
                this._target = target;
                this._event = event;
                this._bindings = [];
            },
            add: function(fn, options) {
                var bindings = this._bindings, binding = {
                    fn: fn,
                    options: langx.mixin({}, options)
                };
                bindings.push(binding);
                var self = this;
                if (!self._listener) {
                    self._listener = function(domEvt) {
                        var elm = this, e = createProxy(domEvt), args = domEvt._args, bindings = self._bindings, ns = e.namespace;
                        if (langx.isDefined(args)) {
                            args = [ e ].concat(args);
                        } else {
                            args = [ e ];
                        }
                        langx.each(bindings, function(idx, binding) {
                            var match = elm;
                            if (e.isImmediatePropagationStopped && e.isImmediatePropagationStopped()) {
                                return false;
                            }
                            var fn = binding.fn, options = binding.options || {}, selector = options.selector, one = options.one, data = options.data;
                            if (ns && ns != options.ns && options.ns.indexOf(ns) === -1) {
                                return;
                            }
                            if (selector) {
                                match = finder.closest(e.target, selector);
                                if (match && match !== elm) {
                                    langx.mixin(e, {
                                        currentTarget: match,
                                        liveFired: elm
                                    });
                                } else {
                                    return;
                                }
                            }
                            var originalEvent = self._event;
                            if (originalEvent in hover) {
                                var related = e.relatedTarget;
                                if (related && (related === match || noder.contains(match, related))) {
                                    return;
                                }
                            }
                            if (langx.isDefined(data)) {
                                e.data = data;
                            }
                            if (one) {
                                self.remove(fn, options);
                            }
                            var result = fn.apply(match, args);
                            if (result === false) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                        });
                    };
                    var event = self._event;
                    if (self._target.addEventListener) {
                        self._target.addEventListener(realEvent(event), self._listener, false);
                    } else {
                        console.warn("invalid eventer object", self._target);
                    }
                }
            },
            remove: function(fn, options) {
                options = langx.mixin({}, options);
                function matcherFor(ns) {
                    return new RegExp("(?:^| )" + ns.replace(" ", " .* ?") + "(?: |$)");
                }
                var matcher;
                if (options.ns) {
                    matcher = matcherFor(options.ns);
                }
                this._bindings = this._bindings.filter(function(binding) {
                    var removing = (!fn || fn === binding.fn) && (!matcher || matcher.test(binding.options.ns)) && (!options.selector || options.selector == binding.options.selector);
                    return !removing;
                });
                if (this._bindings.length == 0) {
                    if (this._target.removeEventListener) {
                        this._target.removeEventListener(realEvent(this._event), this._listener, false);
                    }
                    this._listener = null;
                }
            }
        }), EventsHandler = langx.klass({
            init: function(elm) {
                this._target = elm;
                this._handler = {};
            },
            register: function(event, callback, options) {
                var parsed = parse(event), event = parsed.type, specialEvent = specialEvents[event], bindingEvent = specialEvent && (specialEvent.bindType || specialEvent.bindEventName);
                var events = this._handler;
                if (events[event] === undefined) {
                    events[event] = new EventBindings(this._target, bindingEvent || event);
                }
                events[event].add(callback, langx.mixin({
                    ns: parsed.ns
                }, options));
            },
            unregister: function(event, fn, options) {
                var events = this._handler, parsed = parse(event);
                event = parsed.type;
                if (event) {
                    var listener = events[event];
                    if (listener) {
                        listener.remove(fn, langx.mixin({
                            ns: parsed.ns
                        }, options));
                    }
                } else {
                    for (event in events) {
                        var listener = events[event];
                        listener.remove(fn, langx.mixin({
                            ns: parsed.ns
                        }, options));
                    }
                }
            }
        }), findHandler = function(elm) {
            var id = uid(elm), handler = handlers[id];
            if (!handler) {
                handler = handlers[id] = new EventsHandler(elm);
            }
            return handler;
        };
        function off(elm, events, selector, callback) {
            var $this = this;
            if (langx.isPlainObject(events)) {
                langx.each(events, function(type, fn) {
                    off(elm, type, selector, fn);
                });
                return $this;
            }
            if (!langx.isString(selector) && !langx.isFunction(callback) && callback !== false) {
                callback = selector;
                selector = undefined;
            }
            if (callback === false) {
                callback = langx.returnFalse;
            }
            if (typeof events == "string") {
                if (events.indexOf(",") > -1) {
                    events = events.split(",");
                } else {
                    events = events.split(/\s/);
                }
            }
            var handler = findHandler(elm);
            if (events) events.forEach(function(event) {
                handler.unregister(event, callback, {
                    selector: selector
                });
            });
            return this;
        }
        function on(elm, events, selector, data, callback, one) {
            var autoRemove, delegator;
            if (langx.isPlainObject(events)) {
                langx.each(events, function(type, fn) {
                    on(elm, type, selector, data, fn, one);
                });
                return this;
            }
            if (!langx.isString(selector) && !langx.isFunction(callback)) {
                callback = data;
                data = selector;
                selector = undefined;
            }
            if (langx.isFunction(data)) {
                callback = data;
                data = undefined;
            }
            if (callback === false) {
                callback = langx.returnFalse;
            }
            if (typeof events == "string") {
                if (events.indexOf(",") > -1) {
                    events = events.split(",");
                } else {
                    events = events.split(/\s/);
                }
            }
            var handler = findHandler(elm);
            events.forEach(function(event) {
                if (event == "ready") {
                    return ready(callback);
                }
                handler.register(event, callback, {
                    data: data,
                    selector: selector,
                    one: !!one
                });
            });
            return this;
        }
        function one(elm, events, selector, data, callback) {
            on(elm, events, selector, data, callback, 1);
            return this;
        }
        function stop(event) {
            if (window.document.all) {
                event.keyCode = 0;
            }
            if (event.preventDefault) {
                event.preventDefault();
                event.stopPropagation();
            }
            return this;
        }
        function trigger(evented, type, args) {
            var e;
            if (type instanceof Event) {
                e = type;
            } else {
                e = createEvent(type, args);
            }
            e._args = args;
            var fn = evented.dispatchEvent || evented.trigger;
            if (fn) {
                fn.call(evented, e);
            } else {
                console.warn("The evented parameter is not a eventable object");
            }
            return this;
        }
        function ready(callback) {
            if (readyRE.test(document.readyState) && document.body) {
                langx.defer(callback);
            } else {
                document.addEventListener("DOMContentLoaded", callback, false);
            }
            return this;
        }
        var keyCodeLookup = {
            "delete": 46
        };
        function shortcuts(elm) {
            var registry = datax.data(elm, "shortcuts");
            if (!registry) {
                registry = {};
                datax.data(elm, "shortcuts", registry);
                var run = function(shortcut, event) {
                    var n = event.metaKey || event.ctrlKey;
                    if (shortcut.ctrl == n && shortcut.alt == event.altKey && shortcut.shift == event.shiftKey) {
                        if (event.keyCode == shortcut.keyCode || event.charCode && event.charCode == shortcut.charCode) {
                            event.preventDefault();
                            if ("keydown" == event.type) {
                                shortcut.fn(event);
                            }
                            return true;
                        }
                    }
                };
                on(elm, "keyup keypress keydown", function(event) {
                    if (!/INPUT|TEXTAREA/.test(event.target.nodeName)) {
                        for (var key in registry) {
                            run(registry[key], event);
                        }
                    }
                });
            }
            return {
                add: function(pattern, fn) {
                    var shortcutKeys;
                    if (pattern.indexOf(",") > -1) {
                        shortcutKeys = pattern.toLowerCase().split(",");
                    } else {
                        shortcutKeys = pattern.toLowerCase().split(" ");
                    }
                    shortcutKeys.forEach(function(shortcutKey) {
                        var setting = {
                            fn: fn,
                            alt: false,
                            ctrl: false,
                            shift: false
                        };
                        shortcutKey.split("+").forEach(function(key) {
                            switch (key) {
                              case "alt":
                              case "ctrl":
                              case "shift":
                                setting[key] = true;
                                break;

                              default:
                                setting.charCode = key.charCodeAt(0);
                                setting.keyCode = keyCodeLookup[key] || key.toUpperCase().charCodeAt(0);
                            }
                        });
                        var regKey = (setting.ctrl ? "ctrl" : "") + "," + (setting.alt ? "alt" : "") + "," + (setting.shift ? "shift" : "") + "," + setting.keyCode;
                        registry[regKey] = setting;
                    });
                }
            };
        }
        function eventer() {
            return eventer;
        }
        langx.mixin(eventer, {
            create: createEvent,
            off: off,
            on: on,
            one: one,
            proxy: createProxy,
            ready: ready,
            shortcuts: shortcuts,
            special: specialEvents,
            stop: stop,
            trigger: trigger
        });
        return skylark.eventer = eventer;
    });
    define("skylark-utils/geom", [ "./skylark", "./langx", "./styler" ], function(skylark, langx, styler) {
        var rootNodeRE = /^(?:body|html)$/i, px = langx.toPixel;
        function offsetParent(elm) {
            var parent = elm.offsetParent || document.body;
            while (parent && !rootNodeRE.test(parent.nodeName) && styler.css(parent, "position") == "static") {
                parent = parent.offsetParent;
            }
            return parent;
        }
        function borderExtents(elm) {
            var s = getComputedStyle(elm);
            return {
                left: px(s.borderLeftWidth, elm),
                top: px(s.borderTopWidth, elm),
                right: px(s.borderRightWidth, elm),
                bottom: px(s.borderBottomWidth, elm)
            };
        }
        function boundingPosition(elm, coords) {
            if (coords === undefined) {
                return rootNodeRE.test(elm.nodeName) ? {
                    top: 0,
                    left: 0
                } : elm.getBoundingClientRect();
            } else {
                var parent = offsetParent(elm), parentOffset = boundingPosition(parent), mex = marginExtents(elm), pbex = borderExtents(parent);
                relativePosition(elm, {
                    top: coords.top - parentOffset.top - mex.top - pbex.top,
                    left: coords.left - parentOffset.left - mex.left - pbex.left
                });
                return this;
            }
        }
        function boundingRect(elm, coords) {
            if (coords === undefined) {
                return elm.getBoundingClientRect();
            } else {
                boundingPosition(elm, coords);
                size(elm, coords);
                return this;
            }
        }
        function clientHeight(elm, value) {
            if (value == undefined) {
                return clientSize(elm).height;
            } else {
                return clientSize(elm, {
                    height: value
                });
            }
        }
        function clientSize(elm, dimension) {
            if (dimension == undefined) {
                return {
                    width: elm.clientWidth,
                    height: elm.clientHeight
                };
            } else {
                var isBorderBox = styler.css(elm, "box-sizing") === "border-box", props = {
                    width: dimension.width,
                    height: dimension.height
                };
                if (!isBorderBox) {
                    var pex = paddingExtents(elm);
                    if (props.width !== undefined) {
                        props.width = props.width - pex.left - pex.right;
                    }
                    if (props.height !== undefined) {
                        props.height = props.height - pex.top - pex.bottom;
                    }
                } else {
                    var bex = borderExtents(elm);
                    if (props.width !== undefined) {
                        props.width = props.width + bex.left + bex.right;
                    }
                    if (props.height !== undefined) {
                        props.height = props.height + bex.top + bex.bottom;
                    }
                }
                styler.css(elm, props);
                return this;
            }
            return {
                width: elm.clientWidth,
                height: elm.clientHeight
            };
        }
        function clientWidth(elm, value) {
            if (value == undefined) {
                return clientSize(elm).width;
            } else {
                clientSize(elm, {
                    width: value
                });
                return this;
            }
        }
        function contentRect(elm) {
            var cs = clientSize(elm), pex = paddingExtents(elm);
            return {
                left: pex.left,
                top: pex.top,
                width: cs.width - pex.left - pex.right,
                height: cs.height - pex.top - pex.bottom
            };
        }
        function getDocumentSize(doc) {
            var documentElement = doc.documentElement, body = doc.body, max = Math.max, scrollWidth = max(documentElement.scrollWidth, body.scrollWidth), clientWidth = max(documentElement.clientWidth, body.clientWidth), offsetWidth = max(documentElement.offsetWidth, body.offsetWidth), scrollHeight = max(documentElement.scrollHeight, body.scrollHeight), clientHeight = max(documentElement.clientHeight, body.clientHeight), offsetHeight = max(documentElement.offsetHeight, body.offsetHeight);
            return {
                width: scrollWidth < offsetWidth ? clientWidth : scrollWidth,
                height: scrollHeight < offsetHeight ? clientHeight : scrollHeight
            };
        }
        function height(elm, value) {
            if (value == undefined) {
                return size(elm).height;
            } else {
                size(elm, {
                    height: value
                });
                return this;
            }
        }
        function marginExtents(elm) {
            var s = getComputedStyle(elm);
            return {
                left: px(s.marginLeft),
                top: px(s.marginTop),
                right: px(s.marginRight),
                bottom: px(s.marginBottom)
            };
        }
        function marginRect(elm) {
            var obj = this.relativeRect(elm), me = this.marginExtents(elm);
            return {
                left: obj.left,
                top: obj.top,
                width: obj.width + me.left + me.right,
                height: obj.height + me.top + me.bottom
            };
        }
        function paddingExtents(elm) {
            var s = getComputedStyle(elm);
            return {
                left: px(s.paddingLeft),
                top: px(s.paddingTop),
                right: px(s.paddingRight),
                bottom: px(s.paddingBottom)
            };
        }
        function pagePosition(elm, coords) {
            if (coords === undefined) {
                var obj = elm.getBoundingClientRect();
                return {
                    left: obj.left + window.pageXOffset,
                    top: obj.top + window.pageYOffset
                };
            } else {
                var parent = offsetParent(elm), parentOffset = pagePosition(parent), mex = marginExtents(elm), pbex = borderExtents(parent);
                relativePosition(elm, {
                    top: coords.top - parentOffset.top - mex.top - pbex.top,
                    left: coords.left - parentOffset.left - mex.left - pbex.left
                });
                return this;
            }
        }
        function pageRect(elm, coords) {
            if (coords === undefined) {
                var obj = elm.getBoundingClientRect();
                return {
                    left: obj.left + window.pageXOffset,
                    top: obj.top + window.pageYOffset,
                    width: Math.round(obj.width),
                    height: Math.round(obj.height)
                };
            } else {
                pagePosition(elm, coords);
                size(elm, coords);
                return this;
            }
        }
        function relativePosition(elm, coords) {
            if (coords == undefined) {
                var parent = offsetParent(elm), offset = boundingPosition(elm), parentOffset = boundingPosition(parent), mex = marginExtents(elm), pbex = borderExtents(parent);
                return {
                    top: offset.top - parentOffset.top - pbex.top,
                    left: offset.left - parentOffset.left - pbex.left
                };
            } else {
                var props = {
                    top: coords.top,
                    left: coords.left
                };
                if (styler.css(elm, "position") == "static") {
                    props["position"] = "relative";
                }
                styler.css(elm, props);
                return this;
            }
        }
        function relativeRect(elm, coords) {
            if (coords === undefined) {
                var parent = offsetParent(elm), offset = boundingRect(elm), parentOffset = boundingPosition(parent), mex = marginExtents(elm), pbex = borderExtents(parent);
                return {
                    top: offset.top - parentOffset.top - pbex.top,
                    left: offset.left - parentOffset.left - pbex.left,
                    width: offset.width,
                    height: offset.height
                };
            } else {
                relativePosition(elm, coords);
                size(elm, coords);
                return this;
            }
        }
        function scrollIntoView(elm, align) {
            function getOffset(elm, rootElm) {
                var x, y, parent = elm;
                x = y = 0;
                while (parent && parent != rootElm && parent.nodeType) {
                    x += parent.offsetLeft || 0;
                    y += parent.offsetTop || 0;
                    parent = parent.offsetParent;
                }
                return {
                    x: x,
                    y: y
                };
            }
            var parentElm = elm.parentNode;
            var x, y, width, height, parentWidth, parentHeight;
            var pos = getOffset(elm, parentElm);
            x = pos.x;
            y = pos.y;
            width = elm.offsetWidth;
            height = elm.offsetHeight;
            parentWidth = parentElm.clientWidth;
            parentHeight = parentElm.clientHeight;
            if (align == "end") {
                x -= parentWidth - width;
                y -= parentHeight - height;
            } else if (align == "center") {
                x -= parentWidth / 2 - width / 2;
                y -= parentHeight / 2 - height / 2;
            }
            parentElm.scrollLeft = x;
            parentElm.scrollTop = y;
            return this;
        }
        function scrollLeft(elm, value) {
            var hasScrollLeft = "scrollLeft" in elm;
            if (value === undefined) {
                return hasScrollLeft ? elm.scrollLeft : elm.pageXOffset;
            } else {
                if (hasScrollLeft) {
                    elm.scrollLeft = value;
                } else {
                    elm.scrollTo(value, elm.scrollY);
                }
                return this;
            }
        }
        function scrollTop(elm, value) {
            var hasScrollTop = "scrollTop" in elm;
            if (value === undefined) {
                return hasScrollTop ? elm.scrollTop : elm.pageYOffset;
            } else {
                if (hasScrollTop) {
                    elm.scrollTop = value;
                } else {
                    elm.scrollTo(elm.scrollX, value);
                }
                return this;
            }
        }
        function size(elm, dimension) {
            if (dimension == undefined) {
                if (langx.isWindow(elm)) {
                    return {
                        width: elm.innerWidth,
                        height: elm.innerHeight
                    };
                } else if (langx.isDocument(elm)) {
                    return getDocumentSize(document);
                } else {
                    return {
                        width: elm.offsetWidth,
                        height: elm.offsetHeight
                    };
                }
            } else {
                var isBorderBox = styler.css(elm, "box-sizing") === "border-box", props = {
                    width: dimension.width,
                    height: dimension.height
                };
                if (!isBorderBox) {
                    var pex = paddingExtents(elm), bex = borderExtents(elm);
                    if (props.width !== undefined && props.width !== "" && props.width !== null) {
                        props.width = props.width - pex.left - pex.right - bex.left - bex.right;
                    }
                    if (props.height !== undefined && props.height !== "" && props.height !== null) {
                        props.height = props.height - pex.top - pex.bottom - bex.top - bex.bottom;
                    }
                }
                styler.css(elm, props);
                return this;
            }
        }
        function width(elm, value) {
            if (value == undefined) {
                return size(elm).width;
            } else {
                size(elm, {
                    width: value
                });
                return this;
            }
        }
        function geom() {
            return geom;
        }
        langx.mixin(geom, {
            borderExtents: borderExtents,
            boundingPosition: boundingPosition,
            boundingRect: boundingRect,
            clientHeight: clientHeight,
            clientSize: clientSize,
            clientWidth: clientWidth,
            contentRect: contentRect,
            getDocumentSize: getDocumentSize,
            height: height,
            marginExtents: marginExtents,
            marginRect: marginRect,
            offsetParent: offsetParent,
            paddingExtents: paddingExtents,
            pagePosition: pagePosition,
            pageRect: pageRect,
            relativePosition: relativePosition,
            relativeRect: relativeRect,
            scrollIntoView: scrollIntoView,
            scrollLeft: scrollLeft,
            scrollTop: scrollTop,
            size: size,
            width: width
        });
        return skylark.geom = geom;
    });
    define("skylark-utils/fx", [ "./skylark", "./langx", "./browser", "./geom", "./styler", "./eventer" ], function(skylark, langx, browser, geom, styler, eventer) {
        var animationName, animationDuration, animationTiming, animationDelay, transitionProperty, transitionDuration, transitionTiming, transitionDelay, animationEnd = browser.normalizeCssEvent("AnimationEnd"), transitionEnd = browser.normalizeCssEvent("TransitionEnd"), supportedTransforms = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i, transform = browser.css3PropPrefix + "transform", cssReset = {};
        cssReset[animationName = browser.normalizeCssProperty("animation-name")] = cssReset[animationDuration = browser.normalizeCssProperty("animation-duration")] = cssReset[animationDelay = browser.normalizeCssProperty("animation-delay")] = cssReset[animationTiming = browser.normalizeCssProperty("animation-timing-function")] = "";
        cssReset[transitionProperty = browser.normalizeCssProperty("transition-property")] = cssReset[transitionDuration = browser.normalizeCssProperty("transition-duration")] = cssReset[transitionDelay = browser.normalizeCssProperty("transition-delay")] = cssReset[transitionTiming = browser.normalizeCssProperty("transition-timing-function")] = "";
        function animate(elm, properties, duration, ease, callback, delay) {
            var key, cssValues = {}, cssProperties = [], transforms = "", that = this, endEvent, wrappedCallback, fired = false, hasScrollTop = false;
            if (langx.isPlainObject(duration)) {
                ease = duration.easing;
                callback = duration.complete;
                delay = duration.delay;
                duration = duration.duration;
            }
            if (langx.isString(duration)) {
                duration = fx.speeds[duration];
            }
            if (duration === undefined) {
                duration = fx.speeds.normal;
            }
            duration = duration / 1e3;
            if (fx.off) {
                duration = 0;
            }
            if (langx.isFunction(ease)) {
                callback = ease;
                eace = "swing";
            } else {
                ease = ease || "swing";
            }
            if (delay) {
                delay = delay / 1e3;
            } else {
                delay = 0;
            }
            if (langx.isString(properties)) {
                cssValues[animationName] = properties;
                cssValues[animationDuration] = duration + "s";
                cssValues[animationTiming] = ease;
                endEvent = animationEnd;
            } else {
                for (key in properties) {
                    if (supportedTransforms.test(key)) {
                        transforms += key + "(" + properties[key] + ") ";
                    } else {
                        if (key === "scrollTop") {
                            hasScrollTop = true;
                        }
                        cssValues[key] = properties[key];
                        cssProperties.push(langx.dasherize(key));
                    }
                }
                endEvent = transitionEnd;
            }
            if (transforms) {
                cssValues[transform] = transforms;
                cssProperties.push(transform);
            }
            if (duration > 0 && langx.isPlainObject(properties)) {
                cssValues[transitionProperty] = cssProperties.join(", ");
                cssValues[transitionDuration] = duration + "s";
                cssValues[transitionDelay] = delay + "s";
                cssValues[transitionTiming] = ease;
            }
            wrappedCallback = function(event) {
                fired = true;
                if (event) {
                    if (event.target !== event.currentTarget) {
                        return;
                    }
                    eventer.off(event.target, endEvent, wrappedCallback);
                } else {
                    eventer.off(elm, animationEnd, wrappedCallback);
                }
                styler.css(elm, cssReset);
                callback && callback.call(this);
            };
            if (duration > 0) {
                eventer.on(elm, endEvent, wrappedCallback);
                langx.debounce(function() {
                    if (fired) {
                        return;
                    }
                    wrappedCallback.call(that);
                }, (duration + delay) * 1e3 + 25)();
            }
            elm.clientLeft;
            styler.css(elm, cssValues);
            if (duration <= 0) {
                langx.debounce(function() {
                    if (fired) {
                        return;
                    }
                    wrappedCallback.call(that);
                }, 0)();
            }
            if (hasScrollTop) {
                scrollToTop(elm, properties["scrollTop"], duration, callback);
            }
            return this;
        }
        function show(elm, speed, callback) {
            styler.show(elm);
            if (speed) {
                if (!callback && langx.isFunction(speed)) {
                    callback = speed;
                    speed = "normal";
                }
                styler.css(elm, "opacity", 0);
                animate(elm, {
                    opacity: 1,
                    scale: "1,1"
                }, speed, callback);
            }
            return this;
        }
        function hide(elm, speed, callback) {
            if (speed) {
                if (!callback && langx.isFunction(speed)) {
                    callback = speed;
                    speed = "normal";
                }
                animate(elm, {
                    opacity: 0,
                    scale: "0,0"
                }, speed, function() {
                    styler.hide(elm);
                    if (callback) {
                        callback.call(elm);
                    }
                });
            } else {
                styler.hide(elm);
            }
            return this;
        }
        function scrollToTop(elm, pos, speed, callback) {
            var scrollFrom = parseInt(elm.scrollTop), i = 0, runEvery = 5, freq = speed * 1e3 / runEvery, scrollTo = parseInt(pos);
            var interval = setInterval(function() {
                i++;
                if (i <= freq) elm.scrollTop = (scrollTo - scrollFrom) / freq * i + scrollFrom;
                if (i >= freq + 1) {
                    clearInterval(interval);
                    if (callback) langx.debounce(callback, 1e3)();
                }
            }, runEvery);
        }
        function toggle(elm, speed, callback) {
            if (styler.isInvisible(elm)) {
                show(elm, speed, callback);
            } else {
                hide(elm, speed, callback);
            }
            return this;
        }
        function fadeTo(elm, speed, opacity, easing, callback) {
            animate(elm, {
                opacity: opacity
            }, speed, easing, callback);
            return this;
        }
        function fadeIn(elm, speed, easing, callback) {
            var target = styler.css(elm, "opacity");
            if (target > 0) {
                styler.css(elm, "opacity", 0);
            } else {
                target = 1;
            }
            styler.show(elm);
            fadeTo(elm, speed, target, easing, callback);
            return this;
        }
        function fadeOut(elm, speed, easing, callback) {
            var _elm = elm, complete, options = {};
            if (langx.isPlainObject(speed)) {
                options.easing = speed.easing;
                options.duration = speed.duration;
                complete = speed.complete;
            } else {
                options.duration = speed;
                if (callback) {
                    complete = callback;
                    options.easing = easing;
                } else {
                    complete = easing;
                }
            }
            options.complete = function() {
                styler.hide(elm);
                if (complete) {
                    complete.call(elm);
                }
            };
            fadeTo(elm, options, 0);
            return this;
        }
        function fadeToggle(elm, speed, ceasing, allback) {
            if (styler.isInvisible(elm)) {
                fadeIn(elm, speed, easing, callback);
            } else {
                fadeOut(elm, speed, easing, callback);
            }
            return this;
        }
        function slideDown(elm, duration, callback) {
            var position = styler.css(elm, "position");
            show(elm);
            styler.css(elm, {
                position: "absolute",
                visibility: "hidden"
            });
            var marginTop = styler.css(elm, "margin-top");
            var marginBottom = styler.css(elm, "margin-bottom");
            var paddingTop = styler.css(elm, "padding-top");
            var paddingBottom = styler.css(elm, "padding-bottom");
            var height = styler.css(elm, "height");
            styler.css(elm, {
                position: position,
                visibility: "visible",
                overflow: "hidden",
                height: 0,
                marginTop: 0,
                marginBottom: 0,
                paddingTop: 0,
                paddingBottom: 0
            });
            animate(elm, {
                height: height,
                marginTop: marginTop,
                marginBottom: marginBottom,
                paddingTop: paddingTop,
                paddingBottom: paddingBottom
            }, {
                duration: duration,
                complete: function() {
                    if (callback) {
                        callback.apply(elm);
                    }
                }
            });
            return this;
        }
        function slideUp(elm, duration, callback) {
            if (geom.height(elm) > 0) {
                var position = styler.css(elm, "position");
                var height = styler.css(elm, "height");
                var marginTop = styler.css(elm, "margin-top");
                var marginBottom = styler.css(elm, "margin-bottom");
                var paddingTop = styler.css(elm, "padding-top");
                var paddingBottom = styler.css(elm, "padding-bottom");
                styler.css(elm, {
                    visibility: "visible",
                    overflow: "hidden",
                    height: height,
                    marginTop: marginTop,
                    marginBottom: marginBottom,
                    paddingTop: paddingTop,
                    paddingBottom: paddingBottom
                });
                animate(elm, {
                    height: 0,
                    marginTop: 0,
                    marginBottom: 0,
                    paddingTop: 0,
                    paddingBottom: 0
                }, {
                    duration: duration,
                    queue: false,
                    complete: function() {
                        hide(elm);
                        styler.css(elm, {
                            visibility: "visible",
                            overflow: "hidden",
                            height: height,
                            marginTop: marginTop,
                            marginBottom: marginBottom,
                            paddingTop: paddingTop,
                            paddingBottom: paddingBottom
                        });
                        if (callback) {
                            callback.apply(elm);
                        }
                    }
                });
            }
            return this;
        }
        function slideToggle(elm, duration, callback) {
            if (geom.height(elm) == 0) {
                slideDown(elm, duration, callback);
            } else {
                slideUp(elm, duration, callback);
            }
            return this;
        }
        function fx() {
            return fx;
        }
        langx.mixin(fx, {
            off: false,
            speeds: {
                normal: 400,
                fast: 200,
                slow: 600
            },
            animate: animate,
            fadeIn: fadeIn,
            fadeOut: fadeOut,
            fadeTo: fadeTo,
            fadeToggle: fadeToggle,
            hide: hide,
            scrollToTop: scrollToTop,
            slideDown: slideDown,
            slideToggle: slideToggle,
            slideUp: slideUp,
            show: show,
            toggle: toggle
        });
        return skylark.fx = fx;
    });
    define("skylark-utils/query", [ "./skylark", "./langx", "./noder", "./datax", "./eventer", "./finder", "./geom", "./styler", "./fx" ], function(skylark, langx, noder, datax, eventer, finder, geom, styler, fx) {
        var some = Array.prototype.some, push = Array.prototype.push, every = Array.prototype.every, concat = Array.prototype.concat, slice = Array.prototype.slice, map = Array.prototype.map, filter = Array.prototype.filter, forEach = Array.prototype.forEach, isQ;
        var rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/;
        var funcArg = langx.funcArg, isArrayLike = langx.isArrayLike, isString = langx.isString, uniq = langx.uniq, isFunction = langx.isFunction;
        var type = langx.type, isArray = langx.isArray, isWindow = langx.isWindow, isDocument = langx.isDocument, isObject = langx.isObject, isPlainObject = langx.isPlainObject, compact = langx.compact, flatten = langx.flatten, camelCase = langx.camelCase, dasherize = langx.dasherize, children = finder.children;
        function wrapper_map(func, context) {
            return function() {
                var self = this, params = slice.call(arguments);
                var result = $.map(self, function(elem, idx) {
                    return func.apply(context, [ elem ].concat(params));
                });
                return $(uniq(result));
            };
        }
        function wrapper_selector(func, context, last) {
            return function(selector) {
                var self = this, params = slice.call(arguments);
                var result = this.map(function(idx, elem) {
                    if (elem.querySelector) {
                        return func.apply(context, last ? [ elem ] : [ elem, selector ]);
                    }
                });
                if (last && selector) {
                    return result.filter(selector);
                } else {
                    return result;
                }
            };
        }
        function wrapper_selector_until(func, context, last) {
            return function(util, selector) {
                var self = this, params = slice.call(arguments);
                if (selector === undefined) {
                    selector = util;
                    util = undefined;
                }
                var result = this.map(function(idx, elem) {
                    if (elem.querySelector) {
                        return func.apply(context, last ? [ elem, util ] : [ elem, selector, util ]);
                    }
                });
                if (last && selector) {
                    return result.filter(selector);
                } else {
                    return result;
                }
            };
        }
        function wrapper_every_act(func, context) {
            return function() {
                var self = this, params = slice.call(arguments);
                this.each(function(idx) {
                    func.apply(context, [ this ].concat(params));
                });
                return self;
            };
        }
        function wrapper_every_act_firstArgFunc(func, context, oldValueFunc) {
            return function(arg1) {
                var self = this, params = slice.call(arguments);
                forEach.call(self, function(elem, idx) {
                    var newArg1 = funcArg(elem, arg1, idx, oldValueFunc(elem));
                    func.apply(context, [ elem, arg1 ].concat(params.slice(1)));
                });
                return self;
            };
        }
        function wrapper_some_chk(func, context) {
            return function() {
                var self = this, params = slice.call(arguments);
                return some.call(self, function(elem) {
                    return func.apply(context, [ elem ].concat(params));
                });
            };
        }
        function wrapper_name_value(func, context, oldValueFunc) {
            return function(name, value) {
                var self = this, params = slice.call(arguments);
                if (langx.isPlainObject(name) || langx.isDefined(value)) {
                    forEach.call(self, function(elem, idx) {
                        var newValue;
                        if (oldValueFunc) {
                            newValue = funcArg(elem, value, idx, oldValueFunc(elem, name));
                        } else {
                            newValue = value;
                        }
                        func.apply(context, [ elem ].concat(params));
                    });
                    return self;
                } else {
                    if (self[0]) {
                        return func.apply(context, [ self[0], name ]);
                    }
                }
            };
        }
        function wrapper_value(func, context, oldValueFunc) {
            return function(value) {
                var self = this;
                if (langx.isDefined(value)) {
                    forEach.call(self, function(elem, idx) {
                        var newValue;
                        if (oldValueFunc) {
                            newValue = funcArg(elem, value, idx, oldValueFunc(elem));
                        } else {
                            newValue = value;
                        }
                        func.apply(context, [ elem, newValue ]);
                    });
                    return self;
                } else {
                    if (self[0]) {
                        return func.apply(context, [ self[0] ]);
                    }
                }
            };
        }
        var NodeList = langx.klass({
            klassName: "SkNodeList",
            init: function(selector, context) {
                var self = this, match, nodes, node, props;
                if (selector) {
                    self.context = context = context || noder.doc();
                    if (isString(selector)) {
                        self.selector = selector;
                        if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
                            match = [ null, selector, null ];
                        } else {
                            match = rquickExpr.exec(selector);
                        }
                        if (match) {
                            if (match[1]) {
                                nodes = noder.createFragment(selector);
                                if (langx.isPlainObject(context)) {
                                    props = context;
                                }
                            } else {
                                node = finder.byId(match[2], noder.ownerDoc(context));
                                if (node) {
                                    nodes = [ node ];
                                }
                            }
                        } else {
                            nodes = finder.descendants(context, selector);
                        }
                    } else {
                        if (isArray(selector)) {
                            nodes = selector;
                        } else {
                            nodes = [ selector ];
                        }
                    }
                }
                if (nodes) {
                    push.apply(self, nodes);
                    if (props) {
                        for (var name in props) {
                            if (langx.isFunction(this[name])) {
                                this[name](props[name]);
                            } else {
                                this.attr(name, props[name]);
                            }
                        }
                    }
                }
                return self;
            }
        }, Array);
        var query = function() {
            isQ = function(object) {
                return object instanceof NodeList;
            };
            init = function(selector, context) {
                return new NodeList(selector, context);
            };
            var $ = function(selector, context) {
                if (isFunction(selector)) {
                    eventer.ready(function() {
                        selector($);
                    });
                } else if (isQ(selector)) {
                    return selector;
                } else {
                    if (context && isQ(context) && isString(selector)) {
                        return context.find(selector);
                    }
                    return init(selector, context);
                }
            };
            $.fn = NodeList.prototype;
            langx.mixin($.fn, {
                map: function(fn) {
                    return $(uniq(langx.map(this, function(el, i) {
                        return fn.call(el, i, el);
                    })));
                },
                slice: function() {
                    return $(slice.apply(this, arguments));
                },
                get: function(idx) {
                    return idx === undefined ? slice.call(this) : this[idx >= 0 ? idx : idx + this.length];
                },
                toArray: function() {
                    return slice.call(this);
                },
                size: function() {
                    return this.length;
                },
                remove: wrapper_every_act(noder.remove, noder),
                each: function(callback) {
                    langx.each(this, callback);
                    return this;
                },
                filter: function(selector) {
                    if (isFunction(selector)) return this.not(this.not(selector));
                    return $(filter.call(this, function(element) {
                        return finder.matches(element, selector);
                    }));
                },
                add: function(selector, context) {
                    return $(uniq(this.toArray().concat($(selector, context).toArray())));
                },
                is: function(selector) {
                    return this.length > 0 && finder.matches(this[0], selector);
                },
                not: function(selector) {
                    var nodes = [];
                    if (isFunction(selector) && selector.call !== undefined) this.each(function(idx) {
                        if (!selector.call(this, idx)) nodes.push(this);
                    }); else {
                        var excludes = typeof selector == "string" ? this.filter(selector) : isArrayLike(selector) && isFunction(selector.item) ? slice.call(selector) : $(selector);
                        this.forEach(function(el) {
                            if (excludes.indexOf(el) < 0) nodes.push(el);
                        });
                    }
                    return $(nodes);
                },
                has: function(selector) {
                    return this.filter(function() {
                        return isObject(selector) ? noder.contains(this, selector) : $(this).find(selector).size();
                    });
                },
                eq: function(idx) {
                    return idx === -1 ? this.slice(idx) : this.slice(idx, +idx + 1);
                },
                first: function() {
                    return this.eq(0);
                },
                last: function() {
                    return this.eq(-1);
                },
                find: wrapper_selector(finder.descendants, finder),
                closest: wrapper_selector(finder.closest, finder),
                parents: wrapper_selector(finder.ancestors, finder),
                parentsUntil: wrapper_selector_until(finder.ancestors, finder),
                parent: wrapper_selector(finder.parent, finder),
                children: wrapper_selector(finder.children, finder),
                contents: wrapper_map(noder.contents, noder),
                empty: wrapper_every_act(noder.empty, noder),
                pluck: function(property) {
                    return langx.map(this, function(el) {
                        return el[property];
                    });
                },
                pushStack: function(elms) {
                    var ret = $(elms);
                    ret.prevObject = this;
                    return ret;
                },
                show: wrapper_every_act(fx.show, fx),
                replaceWith: function(newContent) {
                    return this.before(newContent).remove();
                },
                wrap: function(structure) {
                    var func = isFunction(structure);
                    if (this[0] && !func) var dom = $(structure).get(0), clone = dom.parentNode || this.length > 1;
                    return this.each(function(index) {
                        $(this).wrapAll(func ? structure.call(this, index) : clone ? dom.cloneNode(true) : dom);
                    });
                },
                wrapAll: function(wrappingElement) {
                    if (this[0]) {
                        $(this[0]).before(wrappingElement = $(wrappingElement));
                        var children;
                        while ((children = wrappingElement.children()).length) {
                            wrappingElement = children.first();
                        }
                        $(wrappingElement).append(this);
                    }
                    return this;
                },
                wrapInner: function(wrappingElement) {
                    var func = isFunction(wrappingElement);
                    return this.each(function(index) {
                        var self = $(this), contents = self.contents(), dom = func ? wrappingElement.call(this, index) : wrappingElement;
                        contents.length ? contents.wrapAll(dom) : self.append(dom);
                    });
                },
                unwrap: function(selector) {
                    if (this.parent().children().length === 0) {
                        this.parent(selector).not("body").each(function() {
                            $(this).replaceWith(document.createTextNode(this.childNodes[0].textContent));
                        });
                    } else {
                        this.parent().each(function() {
                            $(this).replaceWith($(this).children());
                        });
                    }
                    return this;
                },
                clone: function() {
                    return this.map(function() {
                        return this.cloneNode(true);
                    });
                },
                hide: wrapper_every_act(fx.hide, fx),
                toggle: function(setting) {
                    return this.each(function() {
                        var el = $(this);
                        (setting === undefined ? el.css("display") == "none" : setting) ? el.show() : el.hide();
                    });
                },
                prev: function(selector) {
                    return $(this.pluck("previousElementSibling")).filter(selector || "*");
                },
                prevAll: wrapper_selector(finder.previousSibling, finder),
                next: function(selector) {
                    return $(this.pluck("nextElementSibling")).filter(selector || "*");
                },
                nextAll: wrapper_selector(finder.nextSiblings, finder),
                siblings: wrapper_selector(finder.siblings, finder),
                html: wrapper_value(noder.html, noder, noder.html),
                text: wrapper_value(datax.text, datax, datax.text),
                attr: wrapper_name_value(datax.attr, datax, datax.attr),
                removeAttr: wrapper_every_act(datax.removeAttr, datax),
                prop: wrapper_name_value(datax.prop, datax, datax.prop),
                removeProp: wrapper_every_act(datax.removeProp, datax),
                data: wrapper_name_value(datax.data, datax, datax.data),
                removeData: wrapper_every_act(datax.removeData, datax),
                val: wrapper_value(datax.val, datax, datax.val),
                offset: wrapper_value(geom.pageRect, geom, geom.pageRect),
                style: wrapper_name_value(styler.css, styler),
                css: wrapper_name_value(styler.css, styler),
                index: function(elem) {
                    if (elem) {
                        return this.indexOf($(elem)[0]);
                    } else {
                        return this.parent().children().indexOf(this[0]);
                    }
                },
                hasClass: wrapper_some_chk(styler.hasClass, styler),
                addClass: wrapper_every_act_firstArgFunc(styler.addClass, styler, styler.className),
                removeClass: wrapper_every_act_firstArgFunc(styler.removeClass, styler, styler.className),
                toggleClass: wrapper_every_act_firstArgFunc(styler.toggleClass, styler, styler.className),
                scrollTop: wrapper_value(geom.scrollTop, geom),
                scrollLeft: wrapper_value(geom.scrollLeft, geom),
                position: function() {
                    if (!this.length) return;
                    var elem = this[0];
                    return geom.relativePosition(elem);
                },
                offsetParent: wrapper_map(geom.offsetParent, geom)
            });
            $.fn.detach = $.fn.remove;
            $.fn.hover = function(fnOver, fnOut) {
                return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
            };
            $.fn.size = wrapper_value(geom.size, geom);
            $.fn.width = wrapper_value(geom.width, geom, geom.width);
            $.fn.height = wrapper_value(geom.height, geom, geom.height);
            [ "width", "height" ].forEach(function(dimension) {
                var offset, Dimension = dimension.replace(/./, function(m) {
                    return m[0].toUpperCase();
                });
                $.fn["outer" + Dimension] = function(margin, value) {
                    if (arguments.length) {
                        if (typeof margin !== "boolean") {
                            value = margin;
                            margin = false;
                        }
                    } else {
                        margin = false;
                        value = undefined;
                    }
                    if (value === undefined) {
                        var el = this[0];
                        if (!el) {
                            return undefined;
                        }
                        var cb = geom.size(el);
                        if (margin) {
                            var me = geom.marginExtents(el);
                            cb.width = cb.width + me.left + me.right;
                            cb.height = cb.height + me.top + me.bottom;
                        }
                        return dimension === "width" ? cb.width : cb.height;
                    } else {
                        return this.each(function(idx, el) {
                            var mb = {};
                            var me = geom.marginExtents(el);
                            if (dimension === "width") {
                                mb.width = value;
                                if (margin) {
                                    mb.width = mb.width - me.left - me.right;
                                }
                            } else {
                                mb.height = value;
                                if (margin) {
                                    mb.height = mb.height - me.top - me.bottom;
                                }
                            }
                            geom.size(el, mb);
                        });
                    }
                };
            });
            $.fn.innerWidth = wrapper_value(geom.width, geom, geom.width);
            $.fn.innerHeight = wrapper_value(geom.height, geom, geom.height);
            var traverseNode = noder.traverse;
            function wrapper_node_operation(func, context, oldValueFunc) {
                return function(html) {
                    var argType, nodes = langx.map(arguments, function(arg) {
                        argType = type(arg);
                        return argType == "object" || argType == "array" || arg == null ? arg : noder.createFragment(arg);
                    });
                    if (nodes.length < 1) {
                        return this;
                    }
                    this.each(function(idx) {
                        func.apply(context, [ this, nodes, idx > 0 ]);
                    });
                    return this;
                };
            }
            $.fn.after = wrapper_node_operation(noder.after, noder);
            $.fn.prepend = wrapper_node_operation(noder.prepend, noder);
            $.fn.before = wrapper_node_operation(noder.before, noder);
            $.fn.append = wrapper_node_operation(noder.append, noder);
            langx.each({
                appendTo: "append",
                prependTo: "prepend",
                insertBefore: "before",
                insertAfter: "after",
                replaceAll: "replaceWith"
            }, function(name, original) {
                $.fn[name] = function(selector) {
                    var elems, ret = [], insert = $(selector), last = insert.length - 1, i = 0;
                    for (;i <= last; i++) {
                        elems = i === last ? this : this.clone(true);
                        $(insert[i])[original](elems);
                        push.apply(ret, elems.get());
                    }
                    return this.pushStack(ret);
                };
            });
            return $;
        }();
        (function($) {
            $.fn.on = wrapper_every_act(eventer.on, eventer);
            $.fn.off = wrapper_every_act(eventer.off, eventer);
            $.fn.trigger = wrapper_every_act(eventer.trigger, eventer);
            ("focusin focusout focus blur load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select keydown keypress keyup error").split(" ").forEach(function(event) {
                $.fn[event] = function(data, callback) {
                    return 0 in arguments ? this.on(event, data, callback) : this.trigger(event);
                };
            });
            $.fn.one = function(event, selector, data, callback) {
                if (!langx.isString(selector) && !langx.isFunction(callback)) {
                    callback = data;
                    data = selector;
                    selector = null;
                }
                if (langx.isFunction(data)) {
                    callback = data;
                    data = null;
                }
                return this.on(event, selector, data, callback, 1);
            };
            $.fn.animate = wrapper_every_act(fx.animate, fx);
            $.fn.show = wrapper_every_act(fx.show, fx);
            $.fn.hide = wrapper_every_act(fx.hide, fx);
            $.fn.toogle = wrapper_every_act(fx.toogle, fx);
            $.fn.fadeTo = wrapper_every_act(fx.fadeTo, fx);
            $.fn.fadeIn = wrapper_every_act(fx.fadeIn, fx);
            $.fn.fadeOut = wrapper_every_act(fx.fadeOut, fx);
            $.fn.fadeToggle = wrapper_every_act(fx.fadeToggle, fx);
            $.fn.slideDown = wrapper_every_act(fx.slideDown, fx);
            $.fn.slideToggle = wrapper_every_act(fx.slideToggle, fx);
            $.fn.slideUp = wrapper_every_act(fx.slideUp, fx);
        })(query);
        (function($) {
            $.fn.end = function() {
                return this.prevObject || $();
            };
            $.fn.andSelf = function() {
                return this.add(this.prevObject || $());
            };
            $.fn.addBack = function(selector) {
                if (this.prevObject) {
                    if (selector) {
                        return this.add(this.prevObject.filter(selector));
                    } else {
                        return this.add(this.prevObject);
                    }
                } else {
                    return this;
                }
            };
            "filter,add,not,eq,first,last,find,closest,parents,parent,children,siblings".split(",").forEach(function(property) {
                var fn = $.fn[property];
                $.fn[property] = function() {
                    var ret = fn.apply(this, arguments);
                    ret.prevObject = this;
                    return ret;
                };
            });
        })(query);
        (function($) {
            $.fn.query = $.fn.find;
            $.fn.place = function(refNode, position) {
                if (langx.isString(refNode)) {
                    refNode = finder.descendant(refNode);
                } else if (isQ(refNode)) {
                    refNode = refNode[0];
                }
                return this.each(function(i, node) {
                    switch (position) {
                      case "before":
                        noder.before(refNode, node);
                        break;

                      case "after":
                        noder.after(refNode, node);
                        break;

                      case "replace":
                        noder.replace(refNode, node);
                        break;

                      case "only":
                        noder.empty(refNode);
                        noder.append(refNode, node);
                        break;

                      case "first":
                        noder.prepend(refNode, node);
                        break;

                      default:
                        noder.append(refNode, node);
                    }
                });
            };
            $.fn.addContent = function(content, position) {
                if (content.template) {
                    content = langx.substitute(content.template, content);
                }
                return this.append(content);
            };
            $.fn.replaceClass = function(newClass, oldClass) {
                this.removeClass(oldClass);
                this.addClass(newClass);
                return this;
            };
        })(query);
        return skylark.query = query;
    });
    define("skylark-jquery/core", [ "skylark-utils/skylark", "skylark-utils/browser", "skylark-utils/langx", "skylark-utils/noder", "skylark-utils/datax", "skylark-utils/eventer", "skylark-utils/finder", "skylark-utils/fx", "skylark-utils/styler", "skylark-utils/query" ], function(skylark, browser, langx, noder, datax, eventer, finder, fx, styler, query) {
        var filter = Array.prototype.filter, slice = Array.prototype.slice;
        (function($) {
            $.fn.jquery = "2.2.0";
            $.camelCase = langx.camelCase;
            $.cleanData = function(elems) {
                var elem, i = 0;
                for (;(elem = elems[i]) !== undefined; i++) {
                    datax.cleanData(elem);
                }
            };
            $.each = langx.each;
            $.extend = function(target) {
                var deep, args = slice.call(arguments, 1);
                if (typeof target == "boolean") {
                    deep = target;
                    target = args.shift();
                }
                if (args.length == 0) {
                    args = [ target ];
                    target = this;
                }
                args.forEach(function(arg) {
                    langx.mixin(target, arg, deep);
                });
                return target;
            };
            $.grep = function(elements, callback) {
                return filter.call(elements, callback);
            };
            $.isArray = langx.isArray;
            $.isEmptyObject = langx.isEmptyObject;
            $.isFunction = langx.isFunction;
            $.isWindow = langx.isWindow;
            $.isPlainObject = langx.isPlainObject;
            $.inArray = langx.inArray;
            $.makeArray = langx.makeArray;
            $.map = langx.map;
            $.noop = function() {};
            $.parseJSON = window.JSON.parse;
            $.proxy = langx.proxy;
            $.trim = langx.trim;
            $.type = langx.type;
            $.fn.extend = function(props) {
                langx.mixin($.fn, props);
            };
            $.fn.serializeArray = function() {
                var name, type, result = [], add = function(value) {
                    if (value.forEach) return value.forEach(add);
                    result.push({
                        name: name,
                        value: value
                    });
                };
                if (this[0]) langx.each(this[0].elements, function(_, field) {
                    type = field.type, name = field.name;
                    if (name && field.nodeName.toLowerCase() != "fieldset" && !field.disabled && type != "submit" && type != "reset" && type != "button" && type != "file" && (type != "radio" && type != "checkbox" || field.checked)) add($(field).val());
                });
                return result;
            };
            $.fn.serialize = function() {
                var result = [];
                this.serializeArray().forEach(function(elm) {
                    result.push(encodeURIComponent(elm.name) + "=" + encodeURIComponent(elm.value));
                });
                return result.join("&");
            };
        })(query);
        (function($) {
            $.Event = function Event(src, props) {
                if (langx.isString(src)) {
                    var type = src;
                    return eventer.create(type, props);
                }
                return eventer.proxy(src, props);
            };
            $.event = {};
            $.event.special = eventer.special;
            $.fn.submit = function(callback) {
                if (0 in arguments) this.bind("submit", callback); else if (this.length) {
                    var event = $.Event("submit");
                    this.eq(0).trigger(event);
                    if (!event.isDefaultPrevented()) this.get(0).submit();
                }
                return this;
            };
            $.fn.triggerHandler = $.fn.trigger;
            $.fn.delegate = function(selector, event, callback) {
                return this.on(event, selector, callback);
            };
            $.fn.undelegate = function(selector, event, callback) {
                return this.off(event, selector, callback);
            };
            $.fn.live = function(event, callback) {
                $(document.body).delegate(this.selector, event, callback);
                return this;
            };
            $.fn.die = function(event, callback) {
                $(document.body).undelegate(this.selector, event, callback);
                return this;
            };
            $.fn.bind = function(event, selector, data, callback) {
                return this.on(event, selector, data, callback);
            };
            $.fn.unbind = function(event, callback) {
                return this.off(event, callback);
            };
            $.fn.ready = function(callback) {
                eventer.ready(callback);
                return this;
            };
            $.fn.stop = function() {
                return this;
            };
            $.fn.moveto = function(x, y) {
                return this.animate({
                    left: x + "px",
                    top: y + "px"
                }, .4);
            };
            $.ready = eventer.ready;
            $.on = eventer.on;
            $.off = eventer.off;
        })(query);
        (function($) {
            $.uuid = 0;
            $.support = browser.support;
            $.expr = {};
            $.expr[":"] = $.expr.pseudos = $.expr.filters = finder.pseudos;
            $.expr.createPseudo = function(fn) {
                return fn;
            };
            $.cssHooks = styler.cssHooks;
            $.contains = noder.contains;
            $.css = styler.css;
            $.data = datax.data;
            $.fx = fx;
            $.fx.step = {};
            $.easing = {};
            $.offset = {};
            $.offset.setOffset = function(elem, options, i) {
                var position = $.css(elem, "position");
                if (position === "static") {
                    elem.style.position = "relative";
                }
                var curElem = $(elem), curOffset = curElem.offset(), curCSSTop = $.css(elem, "top"), curCSSLeft = $.css(elem, "left"), calculatePosition = (position === "absolute" || position === "fixed") && $.inArray("auto", [ curCSSTop, curCSSLeft ]) > -1, props = {}, curPosition = {}, curTop, curLeft;
                if (calculatePosition) {
                    curPosition = curElem.position();
                    curTop = curPosition.top;
                    curLeft = curPosition.left;
                } else {
                    curTop = parseFloat(curCSSTop) || 0;
                    curLeft = parseFloat(curCSSLeft) || 0;
                }
                if ($.isFunction(options)) {
                    options = options.call(elem, i, curOffset);
                }
                if (options.top != null) {
                    props.top = options.top - curOffset.top + curTop;
                }
                if (options.left != null) {
                    props.left = options.left - curOffset.left + curLeft;
                }
                if ("using" in options) {
                    options.using.call(elem, props);
                } else {
                    curElem.css(props);
                }
            };
            $._data = function(elm, propName) {
                if (elm.hasAttribute) {
                    return datax.data(elm, propName);
                } else {
                    return {};
                }
            };
        })(query);
        query.parseHTML = function(html) {
            return noder.createFragment(html);
        };
        query.unique = langx.uniq;
        query.skylark = skylark;
        return window.jQuery = window.$ = query;
    });
    define("skylark-jquery/ajax", [ "./core", "skylark-langx/langx" ], function($, langx) {
        $.ajaxJSONP = function(options, langx) {
            if (!("type" in options)) return $.ajax(options);
            var _callbackName = options.jsonpCallback, callbackName = ($.isFunction(_callbackName) ? _callbackName() : _callbackName) || "jsonp" + ++jsonpID, script = document.createElement("script"), originalCallback = window[callbackName], responseData, abort = function(errorType) {
                $(script).triggerHandler("error", errorType || "abort");
            }, xhr = {
                abort: abort
            }, abortTimeout;
            if (deferred) deferred.promise(xhr);
            $(script).on("load error", function(e, errorType) {
                clearTimeout(abortTimeout);
                $(script).off().remove();
                if (e.type == "error" || !responseData) {
                    ajaxError(null, errorType || "error", xhr, options, deferred);
                } else {
                    ajaxSuccess(responseData[0], xhr, options, deferred);
                }
                window[callbackName] = originalCallback;
                if (responseData && $.isFunction(originalCallback)) originalCallback(responseData[0]);
                originalCallback = responseData = undefined;
            });
            if (ajaxBeforeSend(xhr, options) === false) {
                abort("abort");
                return xhr;
            }
            window[callbackName] = function() {
                responseData = arguments;
            };
            script.src = options.url.replace(/\?(.+)=\?/, "?$1=" + callbackName);
            document.head.appendChild(script);
            if (options.timeout > 0) abortTimeout = setTimeout(function() {
                abort("timeout");
            }, options.timeout);
            return xhr;
        };
        $.ajaxSettings = langx.Xhr.defaultOptions;
        $.ajaxSettings.xhr = function() {
            return new window.XMLHttpRequest();
        };
        $.ajax = function(options) {
            var url;
            if (!options) {
                url = "./";
                options = {};
            } else if (langx.isString(options)) {
                url = options;
                options = {};
            }
            return langx.Xhr.request(url, options);
        };
        function parseArguments(url, data, success, dataType) {
            if ($.isFunction(data)) dataType = success, success = data, data = undefined;
            if (!$.isFunction(success)) dataType = success, success = undefined;
            return {
                url: url,
                data: data,
                success: success,
                dataType: dataType
            };
        }
        $.get = function() {
            return $.ajax(parseArguments.apply(null, arguments));
        };
        $.post = function() {
            var options = parseArguments.apply(null, arguments);
            options.type = "POST";
            return $.ajax(options);
        };
        $.getJSON = function() {
            var options = parseArguments.apply(null, arguments);
            options.dataType = "json";
            return $.ajax(options);
        };
        var originalLoad = $.fn.load;
        $.fn.load = function(url, data, success) {
            if ("string" != typeof url && originalLoad) {
                return originalLoad.apply(this, arguments);
            }
            if (!this.length) return this;
            var self = this, parts = url.split(/\s/), selector, options = parseArguments(url, data, success), callback = options.success;
            if (parts.length > 1) options.url = parts[0], selector = parts[1];
            options.success = function(response) {
                self.html(selector ? $("<div>").html(response.replace(rscript, "")).find(selector) : response);
                callback && callback.apply(self, arguments);
            };
            $.ajax(options);
            return this;
        };
        $.param = langx.Xhr.param;
        function addToPrefiltersOrTransports(structure) {
            return function(dataTypeExpression, func) {
                if (typeof dataTypeExpression !== "string") {
                    func = dataTypeExpression;
                    dataTypeExpression = "*";
                }
                var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
                if (jQuery.isFunction(func)) {
                    while (dataType = dataTypes[i++]) {
                        if (dataType[0] === "+") {
                            dataType = dataType.slice(1) || "*";
                            (structure[dataType] = structure[dataType] || []).unshift(func);
                        } else {
                            (structure[dataType] = structure[dataType] || []).push(func);
                        }
                    }
                }
            };
        }
        var prefilters = {}, transports = {}, rnotwhite = /\S+/g;
        $.ajaxPrefilter = addToPrefiltersOrTransports(prefilters);
        $.ajaxTransport = addToPrefiltersOrTransports(transports);
        $.ajaxSetup = function(target, settings) {
            langx.mixin(langx.Xhr.defaultOptions, target, settings);
        };
        return $;
    });
    define("skylark-jquery/callbacks", [ "./core" ], function($) {
        $.Callbacks = function(options) {
            options = $.extend({}, options);
            var memory, fired, firing, firingStart, firingLength, firingIndex, list = [], stack = !options.once && [], fire = function(data) {
                memory = options.memory && data;
                fired = true;
                firingIndex = firingStart || 0;
                firingStart = 0;
                firingLength = list.length;
                firing = true;
                for (;list && firingIndex < firingLength; ++firingIndex) {
                    if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                        memory = false;
                        break;
                    }
                }
                firing = false;
                if (list) {
                    if (stack) stack.length && fire(stack.shift()); else if (memory) list.length = 0; else Callbacks.disable();
                }
            }, Callbacks = {
                add: function() {
                    if (list) {
                        var start = list.length, add = function(args) {
                            $.each(args, function(_, arg) {
                                if (typeof arg === "function") {
                                    if (!options.unique || !Callbacks.has(arg)) list.push(arg);
                                } else if (arg && arg.length && typeof arg !== "string") add(arg);
                            });
                        };
                        add(arguments);
                        if (firing) firingLength = list.length; else if (memory) {
                            firingStart = start;
                            fire(memory);
                        }
                    }
                    return this;
                },
                remove: function() {
                    if (list) {
                        $.each(arguments, function(_, arg) {
                            var index;
                            while ((index = $.inArray(arg, list, index)) > -1) {
                                list.splice(index, 1);
                                if (firing) {
                                    if (index <= firingLength) --firingLength;
                                    if (index <= firingIndex) --firingIndex;
                                }
                            }
                        });
                    }
                    return this;
                },
                has: function(fn) {
                    return !!(list && (fn ? $.inArray(fn, list) > -1 : list.length));
                },
                empty: function() {
                    firingLength = list.length = 0;
                    return this;
                },
                disable: function() {
                    list = stack = memory = undefined;
                    return this;
                },
                disabled: function() {
                    return !list;
                },
                lock: function() {
                    stack = undefined;
                    if (!memory) Callbacks.disable();
                    return this;
                },
                locked: function() {
                    return !stack;
                },
                fireWith: function(context, args) {
                    if (list && (!fired || stack)) {
                        args = args || [];
                        args = [ context, args.slice ? args.slice() : args ];
                        if (firing) stack.push(args); else fire(args);
                    }
                    return this;
                },
                fire: function() {
                    return Callbacks.fireWith(this, arguments);
                },
                fired: function() {
                    return !!fired;
                }
            };
            return Callbacks;
        };
        return $;
    });
    define("skylark-jquery/deferred", [ "./core", "skylark-langx/langx" ], function($, langx) {
        $.Deferred = function() {
            var d = new langx.Deferred(), _p = d.promise;
            d.promise = function() {
                return _p;
            };
            return d;
        };
        $.when = function() {
            var p = langx.Deferred.all(langx.makeArray(arguments)), originThen = p.then;
            p.then = function(onResolved, onRejected) {
                var handler = function(results) {
                    results = results.map(function(result) {
                        return [ result ];
                    });
                    return onResolved && onResolved.apply(null, results);
                };
                return originThen.call(p, handler, onRejected);
            };
            return p;
        };
        return $;
    });
    define("skylark-jquery/main", [ "./core", "./ajax", "./callbacks", "./deferred" ], function($) {
        return $;
    });
    define("skylark-jquery", [ "skylark-jquery/main" ], function(main) {
        return main;
    });
}, this);

(function(factory, globals) {
    var define = globals.define, require = globals.require, isAmd = typeof define === "function" && define.amd, isCmd = !isAmd && typeof exports !== "undefined";
    if (!isAmd && !define) {
        var map = {};
        function absolute(relative, base) {
            if (relative[0] !== ".") {
                return relative;
            }
            var stack = base.split("/"), parts = relative.split("/");
            stack.pop();
            for (var i = 0; i < parts.length; i++) {
                if (parts[i] == ".") continue;
                if (parts[i] == "..") stack.pop(); else stack.push(parts[i]);
            }
            return stack.join("/");
        }
        define = globals.define = function(id, deps, factory) {
            if (typeof factory == "function") {
                map[id] = {
                    factory: factory,
                    deps: deps.map(function(dep) {
                        return absolute(dep, id);
                    }),
                    exports: null
                };
                require(id);
            } else {
                map[id] = factory;
            }
        };
        require = globals.require = function(id) {
            if (!map.hasOwnProperty(id)) {
                throw new Error("Module " + id + " has not been defined");
            }
            var module = map[id];
            if (!module.exports) {
                var args = [];
                module.deps.forEach(function(dep) {
                    args.push(require(dep));
                });
                module.exports = module.factory.apply(window, args);
            }
            return module.exports;
        };
    }
    if (!define) {
        throw new Error("The module utility (ex: requirejs or skylark-utils) is not loaded!");
    }
    factory(define, require);
    if (!isAmd) {
        var skylarkjs = require("skylark-langx/skylark");
        if (isCmd) {
            exports = skylarkjs;
        } else {
            globals.skylarkjs = skylarkjs;
        }
    }
})(function(define, require) {
    define("skylark-jqueryui/version", [ "skylark-jquery" ], function($) {
        $.ui = $.ui || {};
        return $.ui.version = "@VERSION";
    });
    define("skylark-jqueryui/data", [ "skylark-jquery", "./version" ], function($) {
        return $.extend($.expr.pseudos, {
            data: function(elem, i, match, dataName) {
                return !!$.data(elem, dataName || match[3]);
            }
        });
    });
    define("skylark-jqueryui/disable-selection", [ "skylark-jquery", "./version" ], function($) {
        return $.fn.extend({
            disableSelection: function() {
                var eventType = "onselectstart" in document.createElement("div") ? "selectstart" : "mousedown";
                return function() {
                    return this.on(eventType + ".ui-disableSelection", function(event) {
                        event.preventDefault();
                    });
                };
            }(),
            enableSelection: function() {
                return this.off(".ui-disableSelection");
            }
        });
    });
    define("skylark-jqueryui/focusable", [ "skylark-jquery", "./version" ], function($) {
        $.ui.focusable = function(element, hasTabindex) {
            var map, mapName, img, focusableIfVisible, fieldset, nodeName = element.nodeName.toLowerCase();
            if ("area" === nodeName) {
                map = element.parentNode;
                mapName = map.name;
                if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") {
                    return false;
                }
                img = $("img[usemap='#" + mapName + "']");
                return img.length > 0 && img.is(":visible");
            }
            if (/^(input|select|textarea|button|object)$/.test(nodeName)) {
                focusableIfVisible = !element.disabled;
                if (focusableIfVisible) {
                    fieldset = $(element).closest("fieldset")[0];
                    if (fieldset) {
                        focusableIfVisible = !fieldset.disabled;
                    }
                }
            } else if ("a" === nodeName) {
                focusableIfVisible = element.href || hasTabindex;
            } else {
                focusableIfVisible = hasTabindex;
            }
            return focusableIfVisible && $(element).is(":visible") && visible($(element));
        };
        function visible(element) {
            var visibility = element.css("visibility");
            while (visibility === "inherit") {
                element = element.parent();
                visibility = element.css("visibility");
            }
            return visibility !== "hidden";
        }
        $.extend($.expr.pseudos, {
            focusable: function(element) {
                return $.ui.focusable(element, $.attr(element, "tabindex") != null);
            }
        });
        return $.ui.focusable;
    });
    define("skylark-jqueryui/form", [ "skylark-jquery", "./version" ], function($) {
        return $.fn._form = function() {
            return typeof this[0].form === "string" ? this.closest("form") : $(this[0].form);
        };
    });
    define("skylark-jqueryui/ie", [ "skylark-jquery", "./version" ], function($) {
        return $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());
    });
    define("skylark-jqueryui/keycode", [ "skylark-jquery", "./version" ], function($) {
        var keyCode = $.ui.keyCode = {}, langx = $.skylark.langx, keys = $.skylark.eventer.keys;
        langx.each(keys, function(name, value) {
            keyCode[name.toUpperCase()] = value;
        });
        return keyCode;
    });
    define("skylark-jqueryui/escape-selector", [ "skylark-jquery", "./version" ], function($) {
        return $.ui.escapeSelector = function() {
            var selectorEscape = /([!"#$%&'()*+,.\/:;<=>?@[\]^`{|}~])/g;
            return function(selector) {
                return selector.replace(selectorEscape, "\\$1");
            };
        }();
    });
    define("skylark-jqueryui/labels", [ "skylark-jquery", "./version", "./escape-selector" ], function($) {
        return $.fn.labels = function() {
            var ancestor, selector, id, labels, ancestors;
            if (!this.length) {
                return this.pushStack([]);
            }
            if (this[0].labels && this[0].labels.length) {
                return this.pushStack(this[0].labels);
            }
            labels = this.eq(0).parents("label");
            id = this.attr("id");
            if (id) {
                ancestor = this.eq(0).parents().last();
                ancestors = ancestor.add(ancestor.length ? ancestor.siblings() : this.siblings());
                selector = "label[for='" + $.ui.escapeSelector(id) + "']";
                labels = labels.add(ancestors.find(selector).addBack(selector));
            }
            return this.pushStack(labels);
        };
    });
    define("skylark-jqueryui/jquery-1-7", [ "skylark-jquery", "./version" ], function($) {
        if ($.fn.jquery.substring(0, 3) === "1.7") {
            $.each([ "Width", "Height" ], function(i, name) {
                var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ], type = name.toLowerCase(), orig = {
                    innerWidth: $.fn.innerWidth,
                    innerHeight: $.fn.innerHeight,
                    outerWidth: $.fn.outerWidth,
                    outerHeight: $.fn.outerHeight
                };
                function reduce(elem, size, border, margin) {
                    $.each(side, function() {
                        size -= parseFloat($.css(elem, "padding" + this)) || 0;
                        if (border) {
                            size -= parseFloat($.css(elem, "border" + this + "Width")) || 0;
                        }
                        if (margin) {
                            size -= parseFloat($.css(elem, "margin" + this)) || 0;
                        }
                    });
                    return size;
                }
                $.fn["inner" + name] = function(size) {
                    if (size === undefined) {
                        return orig["inner" + name].call(this);
                    }
                    return this.each(function() {
                        $(this).css(type, reduce(this, size) + "px");
                    });
                };
                $.fn["outer" + name] = function(size, margin) {
                    if (typeof size !== "number") {
                        return orig["outer" + name].call(this, size);
                    }
                    return this.each(function() {
                        $(this).css(type, reduce(this, size, true, margin) + "px");
                    });
                };
            });
            $.fn.addBack = function(selector) {
                return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
            };
        }
        if (!$.expr.pseudos) {
            $.expr.pseudos = $.expr[":"];
        }
        if (!$.uniqueSort) {
            $.uniqueSort = $.unique;
        }
    });
    define("skylark-jqueryui/plugin", [ "skylark-jquery", "./version" ], function($) {
        return $.ui.plugin = {
            add: function(module, option, set) {
                var i, proto = $.ui[module].prototype;
                for (i in set) {
                    proto.plugins[i] = proto.plugins[i] || [];
                    proto.plugins[i].push([ option, set[i] ]);
                }
            },
            call: function(instance, name, args, allowDisconnected) {
                var i, set = instance.plugins[name];
                if (!set) {
                    return;
                }
                if (!allowDisconnected && (!instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11)) {
                    return;
                }
                for (i = 0; i < set.length; i++) {
                    if (instance.options[set[i][0]]) {
                        set[i][1].apply(instance.element, args);
                    }
                }
            }
        };
    });
    define("skylark-jqueryui/safe-active-element", [ "skylark-jquery", "./version" ], function($) {
        return $.ui.safeActiveElement = function(document) {
            var activeElement;
            try {
                activeElement = document.activeElement;
            } catch (error) {
                activeElement = document.body;
            }
            if (!activeElement) {
                activeElement = document.body;
            }
            if (!activeElement.nodeName) {
                activeElement = document.body;
            }
            return activeElement;
        };
    });
    define("skylark-jqueryui/safe-blur", [ "skylark-jquery", "./version" ], function($) {
        return $.ui.safeBlur = function(element) {
            if (element && element.nodeName.toLowerCase() !== "body") {
                $(element).trigger("blur");
            }
        };
    });
    define("skylark-jqueryui/scroll-parent", [ "skylark-jquery", "./version" ], function($) {
        return $.fn.scrollParent = function(includeHidden) {
            var position = this.css("position"), excludeStaticParent = position === "absolute", overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/, scrollParent = this.parents().filter(function() {
                var parent = $(this);
                if (excludeStaticParent && parent.css("position") === "static") {
                    return false;
                }
                return overflowRegex.test(parent.css("overflow") + parent.css("overflow-y") + parent.css("overflow-x"));
            }).eq(0);
            return position === "fixed" || !scrollParent.length ? $(this[0].ownerDocument || document) : scrollParent;
        };
    });
    define("skylark-jqueryui/tabbable", [ "skylark-jquery", "./version", "./focusable" ], function($) {
        return $.extend($.expr.pseudos, {
            tabbable: function(element) {
                var tabIndex = $.attr(element, "tabindex"), hasTabindex = tabIndex != null;
                return (!hasTabindex || tabIndex >= 0) && $.ui.focusable(element, hasTabindex);
            }
        });
    });
    define("skylark-jqueryui/unique-id", [ "skylark-jquery", "./version" ], function($) {
        return $.fn.extend({
            uniqueId: function() {
                var uuid = 0;
                return function() {
                    return this.each(function() {
                        if (!this.id) {
                            this.id = "ui-id-" + ++uuid;
                        }
                    });
                };
            }(),
            removeUniqueId: function() {
                return this.each(function() {
                    if (/^ui-id-\d+$/.test(this.id)) {
                        $(this).removeAttr("id");
                    }
                });
            }
        });
    });
    define("skylark-jqueryui/widget", [ "skylark-langx/langx", "skylark-jquery", "./version" ], function(langx, $) {
        var widgetUuid = 0;
        var widgetHasOwnProperty = Array.prototype.hasOwnProperty;
        var widgetSlice = Array.prototype.slice;
        $.widget = function(name, base, prototype) {
            var existingConstructor, constructor, basePrototype;
            var proxiedPrototype = {};
            var namespace = name.split(".")[0];
            name = name.split(".")[1];
            var fullName = namespace + "-" + name;
            if (!prototype) {
                prototype = base;
                base = $.Widget;
            }
            if ($.isArray(prototype)) {
                prototype = $.extend.apply(null, [ {} ].concat(prototype));
            }
            $.expr.pseudos[fullName.toLowerCase()] = function(elem) {
                return !!$.data(elem, fullName);
            };
            $[namespace] = $[namespace] || {};
            existingConstructor = $[namespace][name];
            var _proto = $.widget.extend({
                widgetEventPrefix: existingConstructor ? base.prototype.widgetEventPrefix || name : name
            }, {
                options: base.prototype.options
            }, prototype, {
                name: fullName,
                namespace: namespace,
                widgetName: name,
                widgetFullName: fullName
            });
            constructor = $[namespace][name] = base.inherit(_proto);
            $.extend(constructor, existingConstructor, {
                version: prototype.version,
                _proto: _proto,
                _childConstructors: []
            });
            if (existingConstructor) {
                $.each(existingConstructor._childConstructors, function(i, child) {
                    var childPrototype = child.prototype;
                    $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
                });
                delete existingConstructor._childConstructors;
            } else {
                base._childConstructors.push(constructor);
            }
            $.widget.bridge(name, constructor);
            return constructor;
        };
        $.widget.extend = function(target) {
            var input = widgetSlice.call(arguments, 1);
            var inputIndex = 0;
            var inputLength = input.length;
            var key;
            var value;
            for (;inputIndex < inputLength; inputIndex++) {
                for (key in input[inputIndex]) {
                    value = input[inputIndex][key];
                    if (widgetHasOwnProperty.call(input[inputIndex], key) && value !== undefined) {
                        if ($.isPlainObject(value)) {
                            target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) : $.widget.extend({}, value);
                        } else {
                            target[key] = value;
                        }
                    }
                }
            }
            return target;
        };
        $.widget.bridge = function(name, object) {
            var fullName = object.prototype.widgetFullName || name;
            $.fn[name] = function(options) {
                var isMethodCall = typeof options === "string";
                var args = widgetSlice.call(arguments, 1);
                var returnValue = this;
                if (isMethodCall) {
                    if (!this.length && options === "instance") {
                        returnValue = undefined;
                    } else {
                        this.each(function() {
                            var methodValue;
                            var instance = $.data(this, fullName);
                            if (options === "instance") {
                                returnValue = instance;
                                return false;
                            }
                            if (!instance) {
                                return $.error("cannot call methods on " + name + " prior to initialization; " + "attempted to call method '" + options + "'");
                            }
                            if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
                                return $.error("no such method '" + options + "' for " + name + " widget instance");
                            }
                            methodValue = instance[options].apply(instance, args);
                            if (methodValue !== instance && methodValue !== undefined) {
                                returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;
                                return false;
                            }
                        });
                    }
                } else {
                    if (args.length) {
                        options = $.widget.extend.apply(null, [ options ].concat(args));
                    }
                    this.each(function() {
                        var instance = $.data(this, fullName);
                        if (instance) {
                            instance.option(options || {});
                            if (instance._init) {
                                instance._init();
                            }
                        } else {
                            $.data(this, fullName, new object(options, this));
                        }
                    });
                }
                return returnValue;
            };
        };
        $.Widget = langx.Evented.inherit({
            widgetName: "widget",
            widgetEventPrefix: "",
            defaultElement: "<div>",
            options: {
                classes: {},
                disabled: false,
                create: null
            },
            init: function(options, element) {
                this.options = $.widget.extend({}, this.options);
                this._createWidget(options, element);
            },
            _super: function() {
                if (this.overrided) {
                    return this.overrided.apply(this, arguments);
                }
            },
            _superApply: function(args) {
                if (this.overrided) {
                    return this.overrided.apply(this, args);
                }
            },
            _createWidget: function(options, element) {
                element = $(element || this.defaultElement || this)[0];
                this.element = $(element);
                this.uuid = widgetUuid++;
                this.eventNamespace = "." + this.widgetName + this.uuid;
                this.bindings = $();
                this.hoverable = $();
                this.focusable = $();
                this.classesElementLookup = {};
                if (element !== this) {
                    $.data(element, this.widgetFullName, this);
                    this._on(true, this.element, {
                        remove: function(event) {
                            if (event.target === element) {
                                this.destroy();
                            }
                        }
                    });
                    this.document = $(element.style ? element.ownerDocument : element.document || element);
                    this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
                }
                this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);
                this._create();
                if (this.options.disabled) {
                    this._setOptionDisabled(this.options.disabled);
                }
                this._trigger("create", null, this._getCreateEventData());
                this._init();
            },
            _getCreateOptions: function() {
                return {};
            },
            _getCreateEventData: $.noop,
            _create: $.noop,
            _init: $.noop,
            destroy: function() {
                var that = this;
                this._destroy();
                $.each(this.classesElementLookup, function(key, value) {
                    that._removeClass(value, key);
                });
                this.element.off(this.eventNamespace).removeData(this.widgetFullName);
                this.widget().off(this.eventNamespace).removeAttr("aria-disabled");
                this.bindings.off(this.eventNamespace);
            },
            _destroy: $.noop,
            widget: function() {
                return this.element;
            },
            option: function(key, value) {
                var options = key;
                var parts;
                var curOption;
                var i;
                if (arguments.length === 0) {
                    return $.widget.extend({}, this.options);
                }
                if (typeof key === "string") {
                    options = {};
                    parts = key.split(".");
                    key = parts.shift();
                    if (parts.length) {
                        curOption = options[key] = $.widget.extend({}, this.options[key]);
                        for (i = 0; i < parts.length - 1; i++) {
                            curOption[parts[i]] = curOption[parts[i]] || {};
                            curOption = curOption[parts[i]];
                        }
                        key = parts.pop();
                        if (arguments.length === 1) {
                            return curOption[key] === undefined ? null : curOption[key];
                        }
                        curOption[key] = value;
                    } else {
                        if (arguments.length === 1) {
                            return this.options[key] === undefined ? null : this.options[key];
                        }
                        options[key] = value;
                    }
                }
                this._setOptions(options);
                return this;
            },
            _setOptions: function(options) {
                var key;
                for (key in options) {
                    this._setOption(key, options[key]);
                }
                return this;
            },
            _setOption: function(key, value) {
                if (key === "classes") {
                    this._setOptionClasses(value);
                }
                this.options[key] = value;
                if (key === "disabled") {
                    this._setOptionDisabled(value);
                }
                return this;
            },
            _setOptionClasses: function(value) {
                var classKey, elements, currentElements;
                for (classKey in value) {
                    currentElements = this.classesElementLookup[classKey];
                    if (value[classKey] === this.options.classes[classKey] || !currentElements || !currentElements.length) {
                        continue;
                    }
                    elements = $(currentElements.get());
                    this._removeClass(currentElements, classKey);
                    elements.addClass(this._classes({
                        element: elements,
                        keys: classKey,
                        classes: value,
                        add: true
                    }));
                }
            },
            _setOptionDisabled: function(value) {
                this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, !!value);
                if (value) {
                    this._removeClass(this.hoverable, null, "ui-state-hover");
                    this._removeClass(this.focusable, null, "ui-state-focus");
                }
            },
            enable: function() {
                return this._setOptions({
                    disabled: false
                });
            },
            disable: function() {
                return this._setOptions({
                    disabled: true
                });
            },
            _classes: function(options) {
                var full = [];
                var that = this;
                options = $.extend({
                    element: this.element,
                    classes: this.options.classes || {}
                }, options);
                function bindRemoveEvent() {
                    options.element.each(function(_, element) {
                        var isTracked = $.map(that.classesElementLookup, function(elements) {
                            return elements;
                        }).some(function(elements) {
                            return $(elements).is(element);
                        });
                        if (!isTracked) {
                            that._on($(element), {
                                remove: "_untrackClassesElement"
                            });
                        }
                    });
                }
                function processClassString(classes, checkOption) {
                    var current, i;
                    for (i = 0; i < classes.length; i++) {
                        current = that.classesElementLookup[classes[i]] || $();
                        if (options.add) {
                            bindRemoveEvent();
                            current = $($.uniqueSort(current.get().concat(options.element.get())));
                        } else {
                            current = $(current.not(options.element).get());
                        }
                        that.classesElementLookup[classes[i]] = current;
                        full.push(classes[i]);
                        if (checkOption && options.classes[classes[i]]) {
                            full.push(options.classes[classes[i]]);
                        }
                    }
                }
                if (options.keys) {
                    processClassString(options.keys.match(/\S+/g) || [], true);
                }
                if (options.extra) {
                    processClassString(options.extra.match(/\S+/g) || []);
                }
                return full.join(" ");
            },
            _untrackClassesElement: function(event) {
                var that = this;
                $.each(that.classesElementLookup, function(key, value) {
                    if ($.inArray(event.target, value) !== -1) {
                        that.classesElementLookup[key] = $(value.not(event.target).get());
                    }
                });
                this._off($(event.target));
            },
            _removeClass: function(element, keys, extra) {
                return this._toggleClass(element, keys, extra, false);
            },
            _addClass: function(element, keys, extra) {
                return this._toggleClass(element, keys, extra, true);
            },
            _toggleClass: function(element, keys, extra, add) {
                add = typeof add === "boolean" ? add : extra;
                var shift = typeof element === "string" || element === null, options = {
                    extra: shift ? keys : extra,
                    keys: shift ? element : keys,
                    element: shift ? this.element : element,
                    add: add
                };
                options.element.toggleClass(this._classes(options), add);
                return this;
            },
            _on: function(suppressDisabledCheck, element, handlers) {
                var delegateElement;
                var instance = this;
                if (typeof suppressDisabledCheck !== "boolean") {
                    handlers = element;
                    element = suppressDisabledCheck;
                    suppressDisabledCheck = false;
                }
                if (!handlers) {
                    handlers = element;
                    element = this.element;
                    delegateElement = this.widget();
                } else {
                    element = delegateElement = $(element);
                    this.bindings = this.bindings.add(element);
                }
                $.each(handlers, function(event, handler) {
                    function handlerProxy() {
                        if (!suppressDisabledCheck && (instance.options.disabled === true || $(this).hasClass("ui-state-disabled"))) {
                            return;
                        }
                        return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
                    }
                    if (typeof handler !== "string") {
                        handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;
                    }
                    var match = event.match(/^([\w:-]*)\s*(.*)$/);
                    var eventName = match[1] + instance.eventNamespace;
                    var selector = match[2];
                    if (selector) {
                        delegateElement.on(eventName, selector, handlerProxy);
                    } else {
                        element.on(eventName, handlerProxy);
                    }
                });
            },
            _off: function(element, eventName) {
                eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace;
                element.off(eventName);
                this.bindings = $(this.bindings.not(element).get());
                this.focusable = $(this.focusable.not(element).get());
                this.hoverable = $(this.hoverable.not(element).get());
            },
            _delay: function(handler, delay) {
                function handlerProxy() {
                    return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
                }
                var instance = this;
                return setTimeout(handlerProxy, delay || 0);
            },
            _hoverable: function(element) {
                this.hoverable = this.hoverable.add(element);
                this._on(element, {
                    mouseenter: function(event) {
                        this._addClass($(event.currentTarget), null, "ui-state-hover");
                    },
                    mouseleave: function(event) {
                        this._removeClass($(event.currentTarget), null, "ui-state-hover");
                    }
                });
            },
            _focusable: function(element) {
                this.focusable = this.focusable.add(element);
                this._on(element, {
                    focusin: function(event) {
                        this._addClass($(event.currentTarget), null, "ui-state-focus");
                    },
                    focusout: function(event) {
                        this._removeClass($(event.currentTarget), null, "ui-state-focus");
                    }
                });
            },
            _trigger: function(type, event, data) {
                var prop, orig;
                var callback = this.options[type];
                data = data || {};
                event = $.Event(event);
                event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase();
                event.target = this.element[0];
                orig = event.originalEvent;
                if (orig) {
                    for (prop in orig) {
                        if (!(prop in event)) {
                            event[prop] = orig[prop];
                        }
                    }
                }
                this.element.trigger(event, data);
                return !($.isFunction(callback) && callback.apply(this.element[0], [ event ].concat(data)) === false || event.isDefaultPrevented());
            }
        });
        $.Widget._childConstructors = [];
        $.each({
            show: "fadeIn",
            hide: "fadeOut"
        }, function(method, defaultEffect) {
            $.Widget.prototype["_" + method] = function(element, options, callback) {
                if (typeof options === "string") {
                    options = {
                        effect: options
                    };
                }
                var hasOptions;
                var effectName = !options ? method : options === true || typeof options === "number" ? defaultEffect : options.effect || defaultEffect;
                options = options || {};
                if (typeof options === "number") {
                    options = {
                        duration: options
                    };
                }
                hasOptions = !$.isEmptyObject(options);
                options.complete = callback;
                if (options.delay) {
                    element.delay(options.delay);
                }
                if (hasOptions && $.effects && $.effects.effect[effectName]) {
                    element[method](options);
                } else if (effectName !== method && element[effectName]) {
                    element[effectName](options.duration, options.easing, callback);
                } else {
                    element.queue(function(next) {
                        $(this)[method]();
                        if (callback) {
                            callback.call(element[0]);
                        }
                        next();
                    });
                }
            };
        });
        return $.widget;
    });
    define("skylark-jqueryui/widgets/accordion", [ "skylark-jquery", "../version", "../keycode", "../unique-id", "../widget" ], function($) {
        return $.widget("ui.accordion", {
            version: "@VERSION",
            options: {
                active: 0,
                animate: {},
                classes: {
                    "ui-accordion-header": "ui-corner-top",
                    "ui-accordion-header-collapsed": "ui-corner-all",
                    "ui-accordion-content": "ui-corner-bottom"
                },
                collapsible: false,
                event: "click",
                header: "> li > :first-child, > :not(li):even",
                heightStyle: "auto",
                icons: {
                    activeHeader: "ui-icon-triangle-1-s",
                    header: "ui-icon-triangle-1-e"
                },
                activate: null,
                beforeActivate: null
            },
            hideProps: {
                borderTopWidth: "hide",
                borderBottomWidth: "hide",
                paddingTop: "hide",
                paddingBottom: "hide",
                height: "hide"
            },
            showProps: {
                borderTopWidth: "show",
                borderBottomWidth: "show",
                paddingTop: "show",
                paddingBottom: "show",
                height: "show"
            },
            _create: function() {
                var options = this.options;
                this.prevShow = this.prevHide = $();
                this._addClass("ui-accordion", "ui-widget ui-helper-reset");
                this.element.attr("role", "tablist");
                if (!options.collapsible && (options.active === false || options.active == null)) {
                    options.active = 0;
                }
                this._processPanels();
                if (options.active < 0) {
                    options.active += this.headers.length;
                }
                this._refresh();
            },
            _getCreateEventData: function() {
                return {
                    header: this.active,
                    panel: !this.active.length ? $() : this.active.next()
                };
            },
            _createIcons: function() {
                var icon, children, icons = this.options.icons;
                if (icons) {
                    icon = $("<span>");
                    this._addClass(icon, "ui-accordion-header-icon", "ui-icon " + icons.header);
                    icon.prependTo(this.headers);
                    children = this.active.children(".ui-accordion-header-icon");
                    this._removeClass(children, icons.header)._addClass(children, null, icons.activeHeader)._addClass(this.headers, "ui-accordion-icons");
                }
            },
            _destroyIcons: function() {
                this._removeClass(this.headers, "ui-accordion-icons");
                this.headers.children(".ui-accordion-header-icon").remove();
            },
            _destroy: function() {
                var contents;
                this.element.removeAttr("role");
                this.headers.removeAttr("role aria-expanded aria-selected aria-controls tabIndex").removeUniqueId();
                this._destroyIcons();
                contents = this.headers.next().css("display", "").removeAttr("role aria-hidden aria-labelledby").removeUniqueId();
                if (this.options.heightStyle !== "content") {
                    contents.css("height", "");
                }
            },
            _setOption: function(key, value) {
                if (key === "active") {
                    this._activate(value);
                    return;
                }
                if (key === "event") {
                    if (this.options.event) {
                        this._off(this.headers, this.options.event);
                    }
                    this._setupEvents(value);
                }
                this._super(key, value);
                if (key === "collapsible" && !value && this.options.active === false) {
                    this._activate(0);
                }
                if (key === "icons") {
                    this._destroyIcons();
                    if (value) {
                        this._createIcons();
                    }
                }
            },
            _setOptionDisabled: function(value) {
                this._super(value);
                this.element.attr("aria-disabled", value);
                this._toggleClass(null, "ui-state-disabled", !!value);
                this._toggleClass(this.headers.add(this.headers.next()), null, "ui-state-disabled", !!value);
            },
            _keydown: function(event) {
                if (event.altKey || event.ctrlKey) {
                    return;
                }
                var keyCode = $.ui.keyCode, length = this.headers.length, currentIndex = this.headers.index(event.target), toFocus = false;
                switch (event.keyCode) {
                  case keyCode.RIGHT:
                  case keyCode.DOWN:
                    toFocus = this.headers[(currentIndex + 1) % length];
                    break;

                  case keyCode.LEFT:
                  case keyCode.UP:
                    toFocus = this.headers[(currentIndex - 1 + length) % length];
                    break;

                  case keyCode.SPACE:
                  case keyCode.ENTER:
                    this._eventHandler(event);
                    break;

                  case keyCode.HOME:
                    toFocus = this.headers[0];
                    break;

                  case keyCode.END:
                    toFocus = this.headers[length - 1];
                    break;
                }
                if (toFocus) {
                    $(event.target).attr("tabIndex", -1);
                    $(toFocus).attr("tabIndex", 0);
                    $(toFocus).trigger("focus");
                    event.preventDefault();
                }
            },
            _panelKeyDown: function(event) {
                if (event.keyCode === $.ui.keyCode.UP && event.ctrlKey) {
                    $(event.currentTarget).prev().trigger("focus");
                }
            },
            refresh: function() {
                var options = this.options;
                this._processPanels();
                if (options.active === false && options.collapsible === true || !this.headers.length) {
                    options.active = false;
                    this.active = $();
                } else if (options.active === false) {
                    this._activate(0);
                } else if (this.active.length && !$.contains(this.element[0], this.active[0])) {
                    if (this.headers.length === this.headers.find(".ui-state-disabled").length) {
                        options.active = false;
                        this.active = $();
                    } else {
                        this._activate(Math.max(0, options.active - 1));
                    }
                } else {
                    options.active = this.headers.index(this.active);
                }
                this._destroyIcons();
                this._refresh();
            },
            _processPanels: function() {
                var prevHeaders = this.headers, prevPanels = this.panels;
                this.headers = this.element.find(this.options.header);
                this._addClass(this.headers, "ui-accordion-header ui-accordion-header-collapsed", "ui-state-default");
                this.panels = this.headers.next().filter(":not(.ui-accordion-content-active)").hide();
                this._addClass(this.panels, "ui-accordion-content", "ui-helper-reset ui-widget-content");
                if (prevPanels) {
                    this._off(prevHeaders.not(this.headers));
                    this._off(prevPanels.not(this.panels));
                }
            },
            _refresh: function() {
                var maxHeight, options = this.options, heightStyle = options.heightStyle, parent = this.element.parent();
                this.active = this._findActive(options.active);
                this._addClass(this.active, "ui-accordion-header-active", "ui-state-active")._removeClass(this.active, "ui-accordion-header-collapsed");
                this._addClass(this.active.next(), "ui-accordion-content-active");
                this.active.next().show();
                this.headers.attr("role", "tab").each(function() {
                    var header = $(this), headerId = header.uniqueId().attr("id"), panel = header.next(), panelId = panel.uniqueId().attr("id");
                    header.attr("aria-controls", panelId);
                    panel.attr("aria-labelledby", headerId);
                }).next().attr("role", "tabpanel");
                this.headers.not(this.active).attr({
                    "aria-selected": "false",
                    "aria-expanded": "false",
                    tabIndex: -1
                }).next().attr({
                    "aria-hidden": "true"
                }).hide();
                if (!this.active.length) {
                    this.headers.eq(0).attr("tabIndex", 0);
                } else {
                    this.active.attr({
                        "aria-selected": "true",
                        "aria-expanded": "true",
                        tabIndex: 0
                    }).next().attr({
                        "aria-hidden": "false"
                    });
                }
                this._createIcons();
                this._setupEvents(options.event);
                if (heightStyle === "fill") {
                    maxHeight = parent.height();
                    this.element.siblings(":visible").each(function() {
                        var elem = $(this), position = elem.css("position");
                        if (position === "absolute" || position === "fixed") {
                            return;
                        }
                        maxHeight -= elem.outerHeight(true);
                    });
                    this.headers.each(function() {
                        maxHeight -= $(this).outerHeight(true);
                    });
                    this.headers.next().each(function() {
                        $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));
                    }).css("overflow", "auto");
                } else if (heightStyle === "auto") {
                    maxHeight = 0;
                    this.headers.next().each(function() {
                        var isVisible = $(this).is(":visible");
                        if (!isVisible) {
                            $(this).show();
                        }
                        maxHeight = Math.max(maxHeight, $(this).css("height", "").height());
                        if (!isVisible) {
                            $(this).hide();
                        }
                    }).height(maxHeight);
                }
            },
            _activate: function(index) {
                var active = this._findActive(index)[0];
                if (active === this.active[0]) {
                    return;
                }
                active = active || this.active[0];
                this._eventHandler({
                    target: active,
                    currentTarget: active,
                    preventDefault: $.noop
                });
            },
            _findActive: function(selector) {
                return typeof selector === "number" ? this.headers.eq(selector) : $();
            },
            _setupEvents: function(event) {
                var events = {
                    keydown: "_keydown"
                };
                if (event) {
                    $.each(event.split(" "), function(index, eventName) {
                        events[eventName] = "_eventHandler";
                    });
                }
                this._off(this.headers.add(this.headers.next()));
                this._on(this.headers, events);
                this._on(this.headers.next(), {
                    keydown: "_panelKeyDown"
                });
                this._hoverable(this.headers);
                this._focusable(this.headers);
            },
            _eventHandler: function(event) {
                var activeChildren, clickedChildren, options = this.options, active = this.active, clicked = $(event.currentTarget), clickedIsActive = clicked[0] === active[0], collapsing = clickedIsActive && options.collapsible, toShow = collapsing ? $() : clicked.next(), toHide = active.next(), eventData = {
                    oldHeader: active,
                    oldPanel: toHide,
                    newHeader: collapsing ? $() : clicked,
                    newPanel: toShow
                };
                event.preventDefault();
                if (clickedIsActive && !options.collapsible || this._trigger("beforeActivate", event, eventData) === false) {
                    return;
                }
                options.active = collapsing ? false : this.headers.index(clicked);
                this.active = clickedIsActive ? $() : clicked;
                this._toggle(eventData);
                this._removeClass(active, "ui-accordion-header-active", "ui-state-active");
                if (options.icons) {
                    activeChildren = active.children(".ui-accordion-header-icon");
                    this._removeClass(activeChildren, null, options.icons.activeHeader)._addClass(activeChildren, null, options.icons.header);
                }
                if (!clickedIsActive) {
                    this._removeClass(clicked, "ui-accordion-header-collapsed")._addClass(clicked, "ui-accordion-header-active", "ui-state-active");
                    if (options.icons) {
                        clickedChildren = clicked.children(".ui-accordion-header-icon");
                        this._removeClass(clickedChildren, null, options.icons.header)._addClass(clickedChildren, null, options.icons.activeHeader);
                    }
                    this._addClass(clicked.next(), "ui-accordion-content-active");
                }
            },
            _toggle: function(data) {
                var toShow = data.newPanel, toHide = this.prevShow.length ? this.prevShow : data.oldPanel;
                this.prevShow.add(this.prevHide).stop(true, true);
                this.prevShow = toShow;
                this.prevHide = toHide;
                if (this.options.animate) {
                    this._animate(toShow, toHide, data);
                } else {
                    toHide.hide();
                    toShow.show();
                    this._toggleComplete(data);
                }
                toHide.attr({
                    "aria-hidden": "true"
                });
                toHide.prev().attr({
                    "aria-selected": "false",
                    "aria-expanded": "false"
                });
                if (toShow.length && toHide.length) {
                    toHide.prev().attr({
                        tabIndex: -1,
                        "aria-expanded": "false"
                    });
                } else if (toShow.length) {
                    this.headers.filter(function() {
                        return parseInt($(this).attr("tabIndex"), 10) === 0;
                    }).attr("tabIndex", -1);
                }
                toShow.attr("aria-hidden", "false").prev().attr({
                    "aria-selected": "true",
                    "aria-expanded": "true",
                    tabIndex: 0
                });
            },
            _animate: function(toShow, toHide, data) {
                var total, easing, duration, that = this, adjust = 0, boxSizing = toShow.css("box-sizing"), down = toShow.length && (!toHide.length || toShow.index() < toHide.index()), animate = this.options.animate || {}, options = down && animate.down || animate, complete = function() {
                    that._toggleComplete(data);
                };
                if (typeof options === "number") {
                    duration = options;
                }
                if (typeof options === "string") {
                    easing = options;
                }
                easing = easing || options.easing || animate.easing;
                duration = duration || options.duration || animate.duration;
                if (!toHide.length) {
                    return toShow.animate(this.showProps, duration, easing, complete);
                }
                if (!toShow.length) {
                    return toHide.animate(this.hideProps, duration, easing, complete);
                }
                toHide.slideUp();
                toShow.slideDown(complete);
            },
            _toggleComplete: function(data) {
                var toHide = data.oldPanel, prev = toHide.prev();
                this._removeClass(toHide, "ui-accordion-content-active");
                this._removeClass(prev, "ui-accordion-header-active")._addClass(prev, "ui-accordion-header-collapsed");
                if (toHide.length) {
                    toHide.parent()[0].className = toHide.parent()[0].className;
                }
                this._trigger("activate", null, data);
            }
        });
    });
    define("skylark-jqueryui/position", [ "skylark-jquery", "./version" ], function($) {
        (function() {
            var cachedScrollbarWidth, max = Math.max, abs = Math.abs, rhorizontal = /left|center|right/, rvertical = /top|center|bottom/, roffset = /[\+\-]\d+(\.[\d]+)?%?/, rposition = /^\w+/, rpercent = /%$/, _position = $.fn.position;
            function getOffsets(offsets, width, height) {
                return [ parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1), parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1) ];
            }
            function parseCss(element, property) {
                return parseInt($.css(element, property), 10) || 0;
            }
            function getDimensions(elem) {
                var raw = elem[0];
                if (raw.nodeType === 9) {
                    return {
                        width: elem.width(),
                        height: elem.height(),
                        offset: {
                            top: 0,
                            left: 0
                        }
                    };
                }
                if ($.isWindow(raw)) {
                    return {
                        width: elem.width(),
                        height: elem.height(),
                        offset: {
                            top: elem.scrollTop(),
                            left: elem.scrollLeft()
                        }
                    };
                }
                if (raw.preventDefault) {
                    return {
                        width: 0,
                        height: 0,
                        offset: {
                            top: raw.pageY,
                            left: raw.pageX
                        }
                    };
                }
                return {
                    width: elem.outerWidth(),
                    height: elem.outerHeight(),
                    offset: elem.offset()
                };
            }
            $.position = {
                scrollbarWidth: function() {
                    if (cachedScrollbarWidth !== undefined) {
                        return cachedScrollbarWidth;
                    }
                    var w1, w2, div = $("<div style=" + "'display:block;position:absolute;width:200px;height:200px;overflow:hidden;'>" + "<div style='height:300px;width:auto;'></div></div>"), innerDiv = div.children()[0];
                    $("body").append(div);
                    w1 = innerDiv.offsetWidth;
                    div.css("overflow", "scroll");
                    w2 = innerDiv.offsetWidth;
                    if (w1 === w2) {
                        w2 = div[0].clientWidth;
                    }
                    div.remove();
                    return cachedScrollbarWidth = w1 - w2;
                },
                getScrollInfo: function(within) {
                    var overflowX = within.isWindow || within.isDocument ? "" : within.element.css("overflow-x"), overflowY = within.isWindow || within.isDocument ? "" : within.element.css("overflow-y"), hasOverflowX = overflowX === "scroll" || overflowX === "auto" && within.width < within.element[0].scrollWidth, hasOverflowY = overflowY === "scroll" || overflowY === "auto" && within.height < within.element[0].scrollHeight;
                    return {
                        width: hasOverflowY ? $.position.scrollbarWidth() : 0,
                        height: hasOverflowX ? $.position.scrollbarWidth() : 0
                    };
                },
                getWithinInfo: function(element) {
                    var withinElement = $(element || window), isWindow = $.isWindow(withinElement[0]), isDocument = !!withinElement[0] && withinElement[0].nodeType === 9, hasOffset = !isWindow && !isDocument;
                    return {
                        element: withinElement,
                        isWindow: isWindow,
                        isDocument: isDocument,
                        offset: hasOffset ? $(element).offset() : {
                            left: 0,
                            top: 0
                        },
                        scrollLeft: withinElement.scrollLeft(),
                        scrollTop: withinElement.scrollTop(),
                        width: withinElement.outerWidth(),
                        height: withinElement.outerHeight()
                    };
                }
            };
            $.fn.position = function(options) {
                if (!options || !options.of) {
                    return _position.apply(this, arguments);
                }
                options = $.extend({}, options);
                var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions, target = $(options.of), within = $.position.getWithinInfo(options.within), scrollInfo = $.position.getScrollInfo(within), collision = (options.collision || "flip").split(" "), offsets = {};
                dimensions = getDimensions(target);
                if (target[0].preventDefault) {
                    options.at = "left top";
                }
                targetWidth = dimensions.width;
                targetHeight = dimensions.height;
                targetOffset = dimensions.offset;
                basePosition = $.extend({}, targetOffset);
                $.each([ "my", "at" ], function() {
                    var pos = (options[this] || "").split(" "), horizontalOffset, verticalOffset;
                    if (pos.length === 1) {
                        pos = rhorizontal.test(pos[0]) ? pos.concat([ "center" ]) : rvertical.test(pos[0]) ? [ "center" ].concat(pos) : [ "center", "center" ];
                    }
                    pos[0] = rhorizontal.test(pos[0]) ? pos[0] : "center";
                    pos[1] = rvertical.test(pos[1]) ? pos[1] : "center";
                    horizontalOffset = roffset.exec(pos[0]);
                    verticalOffset = roffset.exec(pos[1]);
                    offsets[this] = [ horizontalOffset ? horizontalOffset[0] : 0, verticalOffset ? verticalOffset[0] : 0 ];
                    options[this] = [ rposition.exec(pos[0])[0], rposition.exec(pos[1])[0] ];
                });
                if (collision.length === 1) {
                    collision[1] = collision[0];
                }
                if (options.at[0] === "right") {
                    basePosition.left += targetWidth;
                } else if (options.at[0] === "center") {
                    basePosition.left += targetWidth / 2;
                }
                if (options.at[1] === "bottom") {
                    basePosition.top += targetHeight;
                } else if (options.at[1] === "center") {
                    basePosition.top += targetHeight / 2;
                }
                atOffset = getOffsets(offsets.at, targetWidth, targetHeight);
                basePosition.left += atOffset[0];
                basePosition.top += atOffset[1];
                return this.each(function() {
                    var collisionPosition, using, elem = $(this), elemWidth = elem.outerWidth(), elemHeight = elem.outerHeight(), marginLeft = parseCss(this, "marginLeft"), marginTop = parseCss(this, "marginTop"), collisionWidth = elemWidth + marginLeft + parseCss(this, "marginRight") + scrollInfo.width, collisionHeight = elemHeight + marginTop + parseCss(this, "marginBottom") + scrollInfo.height, position = $.extend({}, basePosition), myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());
                    if (options.my[0] === "right") {
                        position.left -= elemWidth;
                    } else if (options.my[0] === "center") {
                        position.left -= elemWidth / 2;
                    }
                    if (options.my[1] === "bottom") {
                        position.top -= elemHeight;
                    } else if (options.my[1] === "center") {
                        position.top -= elemHeight / 2;
                    }
                    position.left += myOffset[0];
                    position.top += myOffset[1];
                    collisionPosition = {
                        marginLeft: marginLeft,
                        marginTop: marginTop
                    };
                    $.each([ "left", "top" ], function(i, dir) {
                        if ($.ui.position[collision[i]]) {
                            $.ui.position[collision[i]][dir](position, {
                                targetWidth: targetWidth,
                                targetHeight: targetHeight,
                                elemWidth: elemWidth,
                                elemHeight: elemHeight,
                                collisionPosition: collisionPosition,
                                collisionWidth: collisionWidth,
                                collisionHeight: collisionHeight,
                                offset: [ atOffset[0] + myOffset[0], atOffset[1] + myOffset[1] ],
                                my: options.my,
                                at: options.at,
                                within: within,
                                elem: elem
                            });
                        }
                    });
                    if (options.using) {
                        using = function(props) {
                            var left = targetOffset.left - position.left, right = left + targetWidth - elemWidth, top = targetOffset.top - position.top, bottom = top + targetHeight - elemHeight, feedback = {
                                target: {
                                    element: target,
                                    left: targetOffset.left,
                                    top: targetOffset.top,
                                    width: targetWidth,
                                    height: targetHeight
                                },
                                element: {
                                    element: elem,
                                    left: position.left,
                                    top: position.top,
                                    width: elemWidth,
                                    height: elemHeight
                                },
                                horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                                vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
                            };
                            if (targetWidth < elemWidth && abs(left + right) < targetWidth) {
                                feedback.horizontal = "center";
                            }
                            if (targetHeight < elemHeight && abs(top + bottom) < targetHeight) {
                                feedback.vertical = "middle";
                            }
                            if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {
                                feedback.important = "horizontal";
                            } else {
                                feedback.important = "vertical";
                            }
                            options.using.call(this, props, feedback);
                        };
                    }
                    elem.offset($.extend(position, {
                        using: using
                    }));
                });
            };
            $.ui.position = {
                fit: {
                    left: function(position, data) {
                        var within = data.within, withinOffset = within.isWindow ? within.scrollLeft : within.offset.left, outerWidth = within.width, collisionPosLeft = position.left - data.collisionPosition.marginLeft, overLeft = withinOffset - collisionPosLeft, overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset, newOverRight;
                        if (data.collisionWidth > outerWidth) {
                            if (overLeft > 0 && overRight <= 0) {
                                newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
                                position.left += overLeft - newOverRight;
                            } else if (overRight > 0 && overLeft <= 0) {
                                position.left = withinOffset;
                            } else {
                                if (overLeft > overRight) {
                                    position.left = withinOffset + outerWidth - data.collisionWidth;
                                } else {
                                    position.left = withinOffset;
                                }
                            }
                        } else if (overLeft > 0) {
                            position.left += overLeft;
                        } else if (overRight > 0) {
                            position.left -= overRight;
                        } else {
                            position.left = max(position.left - collisionPosLeft, position.left);
                        }
                    },
                    top: function(position, data) {
                        var within = data.within, withinOffset = within.isWindow ? within.scrollTop : within.offset.top, outerHeight = data.within.height, collisionPosTop = position.top - data.collisionPosition.marginTop, overTop = withinOffset - collisionPosTop, overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset, newOverBottom;
                        if (data.collisionHeight > outerHeight) {
                            if (overTop > 0 && overBottom <= 0) {
                                newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
                                position.top += overTop - newOverBottom;
                            } else if (overBottom > 0 && overTop <= 0) {
                                position.top = withinOffset;
                            } else {
                                if (overTop > overBottom) {
                                    position.top = withinOffset + outerHeight - data.collisionHeight;
                                } else {
                                    position.top = withinOffset;
                                }
                            }
                        } else if (overTop > 0) {
                            position.top += overTop;
                        } else if (overBottom > 0) {
                            position.top -= overBottom;
                        } else {
                            position.top = max(position.top - collisionPosTop, position.top);
                        }
                    }
                },
                flip: {
                    left: function(position, data) {
                        var within = data.within, withinOffset = within.offset.left + within.scrollLeft, outerWidth = within.width, offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left, collisionPosLeft = position.left - data.collisionPosition.marginLeft, overLeft = collisionPosLeft - offsetLeft, overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft, myOffset = data.my[0] === "left" ? -data.elemWidth : data.my[0] === "right" ? data.elemWidth : 0, atOffset = data.at[0] === "left" ? data.targetWidth : data.at[0] === "right" ? -data.targetWidth : 0, offset = -2 * data.offset[0], newOverRight, newOverLeft;
                        if (overLeft < 0) {
                            newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
                            if (newOverRight < 0 || newOverRight < abs(overLeft)) {
                                position.left += myOffset + atOffset + offset;
                            }
                        } else if (overRight > 0) {
                            newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
                            if (newOverLeft > 0 || abs(newOverLeft) < overRight) {
                                position.left += myOffset + atOffset + offset;
                            }
                        }
                    },
                    top: function(position, data) {
                        var within = data.within, withinOffset = within.offset.top + within.scrollTop, outerHeight = within.height, offsetTop = within.isWindow ? within.scrollTop : within.offset.top, collisionPosTop = position.top - data.collisionPosition.marginTop, overTop = collisionPosTop - offsetTop, overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop, top = data.my[1] === "top", myOffset = top ? -data.elemHeight : data.my[1] === "bottom" ? data.elemHeight : 0, atOffset = data.at[1] === "top" ? data.targetHeight : data.at[1] === "bottom" ? -data.targetHeight : 0, offset = -2 * data.offset[1], newOverTop, newOverBottom;
                        if (overTop < 0) {
                            newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
                            if (newOverBottom < 0 || newOverBottom < abs(overTop)) {
                                position.top += myOffset + atOffset + offset;
                            }
                        } else if (overBottom > 0) {
                            newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
                            if (newOverTop > 0 || abs(newOverTop) < overBottom) {
                                position.top += myOffset + atOffset + offset;
                            }
                        }
                    }
                },
                flipfit: {
                    left: function() {
                        $.ui.position.flip.left.apply(this, arguments);
                        $.ui.position.fit.left.apply(this, arguments);
                    },
                    top: function() {
                        $.ui.position.flip.top.apply(this, arguments);
                        $.ui.position.fit.top.apply(this, arguments);
                    }
                }
            };
        })();
        return $.ui.position;
    });
    define("skylark-jqueryui/widgets/menu", [ "skylark-jquery", "../keycode", "../position", "../safe-active-element", "../unique-id", "../version", "../widget" ], function($) {
        return $.widget("ui.menu", {
            version: "@VERSION",
            defaultElement: "<ul>",
            delay: 300,
            options: {
                icons: {
                    submenu: "ui-icon-caret-1-e"
                },
                items: "> *",
                menus: "ul",
                position: {
                    my: "left top",
                    at: "right top"
                },
                role: "menu",
                blur: null,
                focus: null,
                select: null
            },
            _create: function() {
                this.activeMenu = this.element;
                this.mouseHandled = false;
                this.lastMousePosition = {
                    x: null,
                    y: null
                };
                this.element.uniqueId().attr({
                    role: this.options.role,
                    tabIndex: 0
                });
                this._addClass("ui-menu", "ui-widget ui-widget-content");
                this._on({
                    "mousedown .ui-menu-item": function(event) {
                        event.preventDefault();
                        this._activateItem(event);
                    },
                    "click .ui-menu-item": function(event) {
                        var target = $(event.target);
                        var active = $($.ui.safeActiveElement(this.document[0]));
                        if (!this.mouseHandled && target.not(".ui-state-disabled").length) {
                            this.select(event);
                            if (!event.isPropagationStopped()) {
                                this.mouseHandled = true;
                            }
                            if (target.has(".ui-menu").length) {
                                this.expand(event);
                            } else if (!this.element.is(":focus") && active.closest(".ui-menu").length) {
                                this.element.trigger("focus", [ true ]);
                                if (this.active && this.active.parents(".ui-menu").length === 1) {
                                    clearTimeout(this.timer);
                                }
                            }
                        }
                    },
                    "mouseenter .ui-menu-item": "_activateItem",
                    "mousemove .ui-menu-item": "_activateItem",
                    mouseleave: "collapseAll",
                    "mouseleave .ui-menu": "collapseAll",
                    focus: function(event, keepActiveItem) {
                        var item = this.active || this._menuItems().first();
                        if (!keepActiveItem) {
                            this.focus(event, item);
                        }
                    },
                    blur: function(event) {
                        this._delay(function() {
                            var notContained = !$.contains(this.element[0], $.ui.safeActiveElement(this.document[0]));
                            if (notContained) {
                                this.collapseAll(event);
                            }
                        });
                    },
                    keydown: "_keydown"
                });
                this.refresh();
                this._on(this.document, {
                    click: function(event) {
                        if (this._closeOnDocumentClick(event)) {
                            this.collapseAll(event, true);
                        }
                        this.mouseHandled = false;
                    }
                });
            },
            _activateItem: function(event) {
                if (this.previousFilter) {
                    return;
                }
                if (event.clientX === this.lastMousePosition.x && event.clientY === this.lastMousePosition.y) {
                    return;
                }
                this.lastMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
                var actualTarget = $(event.target).closest(".ui-menu-item"), target = $(event.currentTarget);
                if (actualTarget[0] !== target[0]) {
                    return;
                }
                if (target.is(".ui-state-active")) {
                    return;
                }
                this._removeClass(target.siblings().children(".ui-state-active"), null, "ui-state-active");
                this.focus(event, target);
            },
            _destroy: function() {
                var items = this.element.find(".ui-menu-item").removeAttr("role aria-disabled"), submenus = items.children(".ui-menu-item-wrapper").removeUniqueId().removeAttr("tabIndex role aria-haspopup");
                this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeAttr("role aria-labelledby aria-expanded aria-hidden aria-disabled " + "tabIndex").removeUniqueId().show();
                submenus.children().each(function() {
                    var elem = $(this);
                    if (elem.data("ui-menu-submenu-caret")) {
                        elem.remove();
                    }
                });
            },
            _keydown: function(event) {
                var match, prev, character, skip, preventDefault = true;
                switch (event.keyCode) {
                  case $.ui.keyCode.PAGE_UP:
                    this.previousPage(event);
                    break;

                  case $.ui.keyCode.PAGE_DOWN:
                    this.nextPage(event);
                    break;

                  case $.ui.keyCode.HOME:
                    this._move("first", "first", event);
                    break;

                  case $.ui.keyCode.END:
                    this._move("last", "last", event);
                    break;

                  case $.ui.keyCode.UP:
                    this.previous(event);
                    break;

                  case $.ui.keyCode.DOWN:
                    this.next(event);
                    break;

                  case $.ui.keyCode.LEFT:
                    this.collapse(event);
                    break;

                  case $.ui.keyCode.RIGHT:
                    if (this.active && !this.active.is(".ui-state-disabled")) {
                        this.expand(event);
                    }
                    break;

                  case $.ui.keyCode.ENTER:
                  case $.ui.keyCode.SPACE:
                    this._activate(event);
                    break;

                  case $.ui.keyCode.ESCAPE:
                    this.collapse(event);
                    break;

                  default:
                    preventDefault = false;
                    prev = this.previousFilter || "";
                    skip = false;
                    character = event.keyCode >= 96 && event.keyCode <= 105 ? (event.keyCode - 96).toString() : String.fromCharCode(event.keyCode);
                    clearTimeout(this.filterTimer);
                    if (character === prev) {
                        skip = true;
                    } else {
                        character = prev + character;
                    }
                    match = this._filterMenuItems(character);
                    match = skip && match.index(this.active.next()) !== -1 ? this.active.nextAll(".ui-menu-item") : match;
                    if (!match.length) {
                        character = String.fromCharCode(event.keyCode);
                        match = this._filterMenuItems(character);
                    }
                    if (match.length) {
                        this.focus(event, match);
                        this.previousFilter = character;
                        this.filterTimer = this._delay(function() {
                            delete this.previousFilter;
                        }, 1e3);
                    } else {
                        delete this.previousFilter;
                    }
                }
                if (preventDefault) {
                    event.preventDefault();
                }
            },
            _activate: function(event) {
                if (this.active && !this.active.is(".ui-state-disabled")) {
                    if (this.active.children("[aria-haspopup='true']").length) {
                        this.expand(event);
                    } else {
                        this.select(event);
                    }
                }
            },
            refresh: function() {
                var menus, items, newSubmenus, newItems, newWrappers, that = this, icon = this.options.icons.submenu, submenus = this.element.find(this.options.menus);
                this._toggleClass("ui-menu-icons", null, !!this.element.find(".ui-icon").length);
                newSubmenus = submenus.filter(":not(.ui-menu)").hide().attr({
                    role: this.options.role,
                    "aria-hidden": "true",
                    "aria-expanded": "false"
                }).each(function() {
                    var menu = $(this), item = menu.prev(), submenuCaret = $("<span>").data("ui-menu-submenu-caret", true);
                    that._addClass(submenuCaret, "ui-menu-icon", "ui-icon " + icon);
                    item.attr("aria-haspopup", "true").prepend(submenuCaret);
                    menu.attr("aria-labelledby", item.attr("id"));
                });
                this._addClass(newSubmenus, "ui-menu", "ui-widget ui-widget-content ui-front");
                menus = submenus.add(this.element);
                items = menus.find(this.options.items);
                items.not(".ui-menu-item").each(function() {
                    var item = $(this);
                    if (that._isDivider(item)) {
                        that._addClass(item, "ui-menu-divider", "ui-widget-content");
                    }
                });
                newItems = items.not(".ui-menu-item, .ui-menu-divider");
                newWrappers = newItems.children().not(".ui-menu").uniqueId().attr({
                    tabIndex: -1,
                    role: this._itemRole()
                });
                this._addClass(newItems, "ui-menu-item")._addClass(newWrappers, "ui-menu-item-wrapper");
                items.filter(".ui-state-disabled").attr("aria-disabled", "true");
                if (this.active && !$.contains(this.element[0], this.active[0])) {
                    this.blur();
                }
            },
            _itemRole: function() {
                return {
                    menu: "menuitem",
                    listbox: "option"
                }[this.options.role];
            },
            _setOption: function(key, value) {
                if (key === "icons") {
                    var icons = this.element.find(".ui-menu-icon");
                    this._removeClass(icons, null, this.options.icons.submenu)._addClass(icons, null, value.submenu);
                }
                this._super(key, value);
            },
            _setOptionDisabled: function(value) {
                this._super(value);
                this.element.attr("aria-disabled", String(value));
                this._toggleClass(null, "ui-state-disabled", !!value);
            },
            focus: function(event, item) {
                var nested, focused, activeParent;
                this.blur(event, event && event.type === "focus");
                this._scrollIntoView(item);
                this.active = item.first();
                focused = this.active.children(".ui-menu-item-wrapper");
                this._addClass(focused, null, "ui-state-active");
                if (this.options.role) {
                    this.element.attr("aria-activedescendant", focused.attr("id"));
                }
                activeParent = this.active.parent().closest(".ui-menu-item").children(".ui-menu-item-wrapper");
                this._addClass(activeParent, null, "ui-state-active");
                if (event && event.type === "keydown") {
                    this._close();
                } else {
                    this.timer = this._delay(function() {
                        this._close();
                    }, this.delay);
                }
                nested = item.children(".ui-menu");
                if (nested.length && event && /^mouse/.test(event.type)) {
                    this._startOpening(nested);
                }
                this.activeMenu = item.parent();
                this._trigger("focus", event, {
                    item: item
                });
            },
            _scrollIntoView: function(item) {
                var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
                if (this._hasScroll()) {
                    borderTop = parseFloat($.css(this.activeMenu[0], "borderTopWidth")) || 0;
                    paddingTop = parseFloat($.css(this.activeMenu[0], "paddingTop")) || 0;
                    offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
                    scroll = this.activeMenu.scrollTop();
                    elementHeight = this.activeMenu.height();
                    itemHeight = item.outerHeight();
                    if (offset < 0) {
                        this.activeMenu.scrollTop(scroll + offset);
                    } else if (offset + itemHeight > elementHeight) {
                        this.activeMenu.scrollTop(scroll + offset - elementHeight + itemHeight);
                    }
                }
            },
            blur: function(event, fromFocus) {
                if (!fromFocus) {
                    clearTimeout(this.timer);
                }
                if (!this.active) {
                    return;
                }
                this._removeClass(this.active.children(".ui-menu-item-wrapper"), null, "ui-state-active");
                this._trigger("blur", event, {
                    item: this.active
                });
                this.active = null;
            },
            _startOpening: function(submenu) {
                clearTimeout(this.timer);
                if (submenu.attr("aria-hidden") !== "true") {
                    return;
                }
                this.timer = this._delay(function() {
                    this._close();
                    this._open(submenu);
                }, this.delay);
            },
            _open: function(submenu) {
                var position = $.extend({
                    of: this.active
                }, this.options.position);
                clearTimeout(this.timer);
                this.element.find(".ui-menu").not(submenu.parents(".ui-menu")).hide().attr("aria-hidden", "true");
                submenu.show().removeAttr("aria-hidden").attr("aria-expanded", "true").position(position);
            },
            collapseAll: function(event, all) {
                clearTimeout(this.timer);
                this.timer = this._delay(function() {
                    var currentMenu = all ? this.element : $(event && event.target).closest(this.element.find(".ui-menu"));
                    if (!currentMenu.length) {
                        currentMenu = this.element;
                    }
                    this._close(currentMenu);
                    this.blur(event);
                    this._removeClass(currentMenu.find(".ui-state-active"), null, "ui-state-active");
                    this.activeMenu = currentMenu;
                }, all ? 0 : this.delay);
            },
            _close: function(startMenu) {
                if (!startMenu) {
                    startMenu = this.active ? this.active.parent() : this.element;
                }
                startMenu.find(".ui-menu").hide().attr("aria-hidden", "true").attr("aria-expanded", "false");
            },
            _closeOnDocumentClick: function(event) {
                return !$(event.target).closest(".ui-menu").length;
            },
            _isDivider: function(item) {
                return !/[^\-\u2014\u2013\s]/.test(item.text());
            },
            collapse: function(event) {
                var newItem = this.active && this.active.parent().closest(".ui-menu-item", this.element);
                if (newItem && newItem.length) {
                    this._close();
                    this.focus(event, newItem);
                }
            },
            expand: function(event) {
                var newItem = this.active && this._menuItems(this.active.children(".ui-menu")).first();
                if (newItem && newItem.length) {
                    this._open(newItem.parent());
                    this._delay(function() {
                        this.focus(event, newItem);
                    });
                }
            },
            next: function(event) {
                this._move("next", "first", event);
            },
            previous: function(event) {
                this._move("prev", "last", event);
            },
            isFirstItem: function() {
                return this.active && !this.active.prevAll(".ui-menu-item").length;
            },
            isLastItem: function() {
                return this.active && !this.active.nextAll(".ui-menu-item").length;
            },
            _menuItems: function(menu) {
                return (menu || this.element).find(this.options.items).filter(".ui-menu-item");
            },
            _move: function(direction, filter, event) {
                var next;
                if (this.active) {
                    if (direction === "first" || direction === "last") {
                        next = this.active[direction === "first" ? "prevAll" : "nextAll"](".ui-menu-item").last();
                    } else {
                        next = this.active[direction + "All"](".ui-menu-item").first();
                    }
                }
                if (!next || !next.length || !this.active) {
                    next = this._menuItems(this.activeMenu)[filter]();
                }
                this.focus(event, next);
            },
            nextPage: function(event) {
                var item, base, height;
                if (!this.active) {
                    this.next(event);
                    return;
                }
                if (this.isLastItem()) {
                    return;
                }
                if (this._hasScroll()) {
                    base = this.active.offset().top;
                    height = this.element.height();
                    this.active.nextAll(".ui-menu-item").each(function() {
                        item = $(this);
                        return item.offset().top - base - height < 0;
                    });
                    this.focus(event, item);
                } else {
                    this.focus(event, this._menuItems(this.activeMenu)[!this.active ? "first" : "last"]());
                }
            },
            previousPage: function(event) {
                var item, base, height;
                if (!this.active) {
                    this.next(event);
                    return;
                }
                if (this.isFirstItem()) {
                    return;
                }
                if (this._hasScroll()) {
                    base = this.active.offset().top;
                    height = this.element.height();
                    this.active.prevAll(".ui-menu-item").each(function() {
                        item = $(this);
                        return item.offset().top - base + height > 0;
                    });
                    this.focus(event, item);
                } else {
                    this.focus(event, this._menuItems(this.activeMenu).first());
                }
            },
            _hasScroll: function() {
                return this.element.outerHeight() < this.element.prop("scrollHeight");
            },
            select: function(event) {
                this.active = this.active || $(event.target).closest(".ui-menu-item");
                var ui = {
                    item: this.active
                };
                if (!this.active.has(".ui-menu").length) {
                    this.collapseAll(event, true);
                }
                this._trigger("select", event, ui);
            },
            _filterMenuItems: function(character) {
                var escapedCharacter = character.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&"), regex = new RegExp("^" + escapedCharacter, "i");
                return this.activeMenu.find(this.options.items).filter(".ui-menu-item").filter(function() {
                    return regex.test($.trim($(this).children(".ui-menu-item-wrapper").text()));
                });
            }
        });
    });
    define("skylark-jqueryui/widgets/autocomplete", [ "skylark-jquery", "./menu", "../keycode", "../position", "../safe-active-element", "../version", "../widget" ], function($) {
        $.widget("ui.autocomplete", {
            version: "@VERSION",
            defaultElement: "<input>",
            options: {
                appendTo: null,
                autoFocus: false,
                delay: 300,
                minLength: 1,
                position: {
                    my: "left top",
                    at: "left bottom",
                    collision: "none"
                },
                source: null,
                change: null,
                close: null,
                focus: null,
                open: null,
                response: null,
                search: null,
                select: null
            },
            requestIndex: 0,
            pending: 0,
            _create: function() {
                var suppressKeyPress, suppressKeyPressRepeat, suppressInput, nodeName = this.element[0].nodeName.toLowerCase(), isTextarea = nodeName === "textarea", isInput = nodeName === "input";
                this.isMultiLine = isTextarea || !isInput && this._isContentEditable(this.element);
                this.valueMethod = this.element[isTextarea || isInput ? "val" : "text"];
                this.isNewMenu = true;
                this._addClass("ui-autocomplete-input");
                this.element.attr("autocomplete", "off");
                this._on(this.element, {
                    keydown: function(event) {
                        if (this.element.prop("readOnly")) {
                            suppressKeyPress = true;
                            suppressInput = true;
                            suppressKeyPressRepeat = true;
                            return;
                        }
                        suppressKeyPress = false;
                        suppressInput = false;
                        suppressKeyPressRepeat = false;
                        var keyCode = $.ui.keyCode;
                        switch (event.keyCode) {
                          case keyCode.PAGE_UP:
                            suppressKeyPress = true;
                            this._move("previousPage", event);
                            break;

                          case keyCode.PAGE_DOWN:
                            suppressKeyPress = true;
                            this._move("nextPage", event);
                            break;

                          case keyCode.UP:
                            suppressKeyPress = true;
                            this._keyEvent("previous", event);
                            break;

                          case keyCode.DOWN:
                            suppressKeyPress = true;
                            this._keyEvent("next", event);
                            break;

                          case keyCode.ENTER:
                            if (this.menu.active) {
                                suppressKeyPress = true;
                                event.preventDefault();
                                this.menu.select(event);
                            }
                            break;

                          case keyCode.TAB:
                            if (this.menu.active) {
                                this.menu.select(event);
                            }
                            break;

                          case keyCode.ESCAPE:
                            if (this.menu.element.is(":visible")) {
                                if (!this.isMultiLine) {
                                    this._value(this.term);
                                }
                                this.close(event);
                                event.preventDefault();
                            }
                            break;

                          default:
                            suppressKeyPressRepeat = true;
                            this._searchTimeout(event);
                            break;
                        }
                    },
                    keypress: function(event) {
                        if (suppressKeyPress) {
                            suppressKeyPress = false;
                            if (!this.isMultiLine || this.menu.element.is(":visible")) {
                                event.preventDefault();
                            }
                            return;
                        }
                        if (suppressKeyPressRepeat) {
                            return;
                        }
                        var keyCode = $.ui.keyCode;
                        switch (event.keyCode) {
                          case keyCode.PAGE_UP:
                            this._move("previousPage", event);
                            break;

                          case keyCode.PAGE_DOWN:
                            this._move("nextPage", event);
                            break;

                          case keyCode.UP:
                            this._keyEvent("previous", event);
                            break;

                          case keyCode.DOWN:
                            this._keyEvent("next", event);
                            break;
                        }
                    },
                    input: function(event) {
                        if (suppressInput) {
                            suppressInput = false;
                            event.preventDefault();
                            return;
                        }
                        this._searchTimeout(event);
                    },
                    focus: function() {
                        this.selectedItem = null;
                        this.previous = this._value();
                    },
                    blur: function(event) {
                        clearTimeout(this.searching);
                        this.close(event);
                        this._change(event);
                    }
                });
                this._initSource();
                this.menu = $("<ul>").appendTo(this._appendTo()).menu({
                    role: null
                }).hide().attr({
                    unselectable: "on"
                }).menu("instance");
                this._addClass(this.menu.element, "ui-autocomplete", "ui-front");
                this._on(this.menu.element, {
                    mousedown: function(event) {
                        event.preventDefault();
                    },
                    menufocus: function(event, ui) {
                        var label, item;
                        if (this.isNewMenu) {
                            this.isNewMenu = false;
                            if (event.originalEvent && /^mouse/.test(event.originalEvent.type)) {
                                this.menu.blur();
                                this.document.one("mousemove", function() {
                                    $(event.target).trigger(event.originalEvent);
                                });
                                return;
                            }
                        }
                        item = ui.item.data("ui-autocomplete-item");
                        if (false !== this._trigger("focus", event, {
                            item: item
                        })) {
                            if (event.originalEvent && /^key/.test(event.originalEvent.type)) {
                                this._value(item.value);
                            }
                        }
                        label = ui.item.attr("aria-label") || item.value;
                        if (label && $.trim(label).length) {
                            this.liveRegion.children().hide();
                            $("<div>").text(label).appendTo(this.liveRegion);
                        }
                    },
                    menuselect: function(event, ui) {
                        var item = ui.item.data("ui-autocomplete-item"), previous = this.previous;
                        if (this.element[0] !== $.ui.safeActiveElement(this.document[0])) {
                            this.element.trigger("focus");
                            this.previous = previous;
                            this._delay(function() {
                                this.previous = previous;
                                this.selectedItem = item;
                            });
                        }
                        if (false !== this._trigger("select", event, {
                            item: item
                        })) {
                            this._value(item.value);
                        }
                        this.term = this._value();
                        this.close(event);
                        this.selectedItem = item;
                    }
                });
                this.liveRegion = $("<div>", {
                    role: "status",
                    "aria-live": "assertive",
                    "aria-relevant": "additions"
                }).appendTo(this.document[0].body);
                this._addClass(this.liveRegion, null, "ui-helper-hidden-accessible");
                this._on(this.window, {
                    beforeunload: function() {
                        this.element.removeAttr("autocomplete");
                    }
                });
            },
            _destroy: function() {
                clearTimeout(this.searching);
                this.element.removeAttr("autocomplete");
                this.menu.element.remove();
                this.liveRegion.remove();
            },
            _setOption: function(key, value) {
                this._super(key, value);
                if (key === "source") {
                    this._initSource();
                }
                if (key === "appendTo") {
                    this.menu.element.appendTo(this._appendTo());
                }
                if (key === "disabled" && value && this.xhr) {
                    this.xhr.abort();
                }
            },
            _isEventTargetInWidget: function(event) {
                var menuElement = this.menu.element[0];
                return event.target === this.element[0] || event.target === menuElement || $.contains(menuElement, event.target);
            },
            _closeOnClickOutside: function(event) {
                if (!this._isEventTargetInWidget(event)) {
                    this.close();
                }
            },
            _appendTo: function() {
                var element = this.options.appendTo;
                if (element) {
                    element = element.jquery || element.nodeType ? $(element) : this.document.find(element).eq(0);
                }
                if (!element || !element[0]) {
                    element = this.element.closest(".ui-front, dialog");
                }
                if (!element.length) {
                    element = this.document[0].body;
                }
                return element;
            },
            _initSource: function() {
                var array, url, that = this;
                if ($.isArray(this.options.source)) {
                    array = this.options.source;
                    this.source = function(request, response) {
                        response($.ui.autocomplete.filter(array, request.term));
                    };
                } else if (typeof this.options.source === "string") {
                    url = this.options.source;
                    this.source = function(request, response) {
                        if (that.xhr) {
                            that.xhr.abort();
                        }
                        that.xhr = $.ajax({
                            url: url,
                            data: request,
                            dataType: "json",
                            success: function(data) {
                                response(data);
                            },
                            error: function() {
                                response([]);
                            }
                        });
                    };
                } else {
                    this.source = this.options.source;
                }
            },
            _searchTimeout: function(event) {
                clearTimeout(this.searching);
                this.searching = this._delay(function() {
                    var equalValues = this.term === this._value(), menuVisible = this.menu.element.is(":visible"), modifierKey = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;
                    if (!equalValues || equalValues && !menuVisible && !modifierKey) {
                        this.selectedItem = null;
                        this.search(null, event);
                    }
                }, this.options.delay);
            },
            search: function(value, event) {
                value = value != null ? value : this._value();
                this.term = this._value();
                if (value.length < this.options.minLength) {
                    return this.close(event);
                }
                if (this._trigger("search", event) === false) {
                    return;
                }
                return this._search(value);
            },
            _search: function(value) {
                this.pending++;
                this._addClass("ui-autocomplete-loading");
                this.cancelSearch = false;
                this.source({
                    term: value
                }, this._response());
            },
            _response: function() {
                var index = ++this.requestIndex;
                return function(content) {
                    if (index === this.requestIndex) {
                        this.__response(content);
                    }
                    this.pending--;
                    if (!this.pending) {
                        this._removeClass("ui-autocomplete-loading");
                    }
                }.bind(this);
            },
            __response: function(content) {
                if (content) {
                    content = this._normalize(content);
                }
                this._trigger("response", null, {
                    content: content
                });
                if (!this.options.disabled && content && content.length && !this.cancelSearch) {
                    this._suggest(content);
                    this._trigger("open");
                } else {
                    this._close();
                }
            },
            close: function(event) {
                this.cancelSearch = true;
                this._close(event);
            },
            _close: function(event) {
                this._off(this.document, "mousedown");
                if (this.menu.element.is(":visible")) {
                    this.menu.element.hide();
                    this.menu.blur();
                    this.isNewMenu = true;
                    this._trigger("close", event);
                }
            },
            _change: function(event) {
                if (this.previous !== this._value()) {
                    this._trigger("change", event, {
                        item: this.selectedItem
                    });
                }
            },
            _normalize: function(items) {
                if (items.length && items[0].label && items[0].value) {
                    return items;
                }
                return $.map(items, function(item) {
                    if (typeof item === "string") {
                        return {
                            label: item,
                            value: item
                        };
                    }
                    return $.extend({}, item, {
                        label: item.label || item.value,
                        value: item.value || item.label
                    });
                });
            },
            _suggest: function(items) {
                var ul = this.menu.element.empty();
                this._renderMenu(ul, items);
                this.isNewMenu = true;
                this.menu.refresh();
                ul.show();
                this._resizeMenu();
                ul.position($.extend({
                    of: this.element
                }, this.options.position));
                if (this.options.autoFocus) {
                    this.menu.next();
                }
                this._on(this.document, {
                    mousedown: "_closeOnClickOutside"
                });
            },
            _resizeMenu: function() {
                var ul = this.menu.element;
                ul.outerWidth(Math.max(ul.width("").outerWidth() + 1, this.element.outerWidth()));
            },
            _renderMenu: function(ul, items) {
                var that = this;
                $.each(items, function(index, item) {
                    that._renderItemData(ul, item);
                });
            },
            _renderItemData: function(ul, item) {
                return this._renderItem(ul, item).data("ui-autocomplete-item", item);
            },
            _renderItem: function(ul, item) {
                return $("<li>").append($("<div>").text(item.label)).appendTo(ul);
            },
            _move: function(direction, event) {
                if (!this.menu.element.is(":visible")) {
                    this.search(null, event);
                    return;
                }
                if (this.menu.isFirstItem() && /^previous/.test(direction) || this.menu.isLastItem() && /^next/.test(direction)) {
                    if (!this.isMultiLine) {
                        this._value(this.term);
                    }
                    this.menu.blur();
                    return;
                }
                this.menu[direction](event);
            },
            widget: function() {
                return this.menu.element;
            },
            _value: function() {
                return this.valueMethod.apply(this.element, arguments);
            },
            _keyEvent: function(keyEvent, event) {
                if (!this.isMultiLine || this.menu.element.is(":visible")) {
                    this._move(keyEvent, event);
                    event.preventDefault();
                }
            },
            _isContentEditable: function(element) {
                if (!element.length) {
                    return false;
                }
                var editable = element.prop("contentEditable");
                if (editable === "inherit") {
                    return this._isContentEditable(element.parent());
                }
                return editable === "true";
            }
        });
        $.extend($.ui.autocomplete, {
            escapeRegex: function(value) {
                return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
            },
            filter: function(array, term) {
                var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), "i");
                return $.grep(array, function(value) {
                    return matcher.test(value.label || value.value || value);
                });
            }
        });
        $.widget("ui.autocomplete", $.ui.autocomplete, {
            options: {
                messages: {
                    noResults: "No search results.",
                    results: function(amount) {
                        return amount + (amount > 1 ? " results are" : " result is") + " available, use up and down arrow keys to navigate.";
                    }
                }
            },
            __response: function(content) {
                var message;
                this._superApply(arguments);
                if (this.options.disabled || this.cancelSearch) {
                    return;
                }
                if (content && content.length) {
                    message = this.options.messages.results(content.length);
                } else {
                    message = this.options.messages.noResults;
                }
                this.liveRegion.children().hide();
                $("<div>").text(message).appendTo(this.liveRegion);
            }
        });
        return $.ui.autocomplete;
    });
    define("skylark-jqueryui/widgets/controlgroup", [ "skylark-jquery", "../widget" ], function($) {
        var controlgroupCornerRegex = /ui-corner-([a-z]){2,6}/g;
        return $.widget("ui.controlgroup", {
            version: "@VERSION",
            defaultElement: "<div>",
            options: {
                direction: "horizontal",
                disabled: null,
                onlyVisible: true,
                items: {
                    button: "input[type=button], input[type=submit], input[type=reset], button, a",
                    controlgroupLabel: ".ui-controlgroup-label",
                    checkboxradio: "input[type='checkbox'], input[type='radio']",
                    selectmenu: "select",
                    spinner: ".ui-spinner-input"
                }
            },
            _create: function() {
                this._enhance();
            },
            _enhance: function() {
                this.element.attr("role", "toolbar");
                this.refresh();
            },
            _destroy: function() {
                this._callChildMethod("destroy");
                this.childWidgets.removeData("ui-controlgroup-data");
                this.element.removeAttr("role");
                if (this.options.items.controlgroupLabel) {
                    this.element.find(this.options.items.controlgroupLabel).find(".ui-controlgroup-label-contents").contents().unwrap();
                }
            },
            _initWidgets: function() {
                var that = this, childWidgets = [];
                $.each(this.options.items, function(widget, selector) {
                    var labels;
                    var options = {};
                    if (!selector) {
                        return;
                    }
                    if (widget === "controlgroupLabel") {
                        labels = that.element.find(selector);
                        labels.each(function() {
                            var element = $(this);
                            if (element.children(".ui-controlgroup-label-contents").length) {
                                return;
                            }
                            element.contents().wrapAll("<span class='ui-controlgroup-label-contents'></span>");
                        });
                        that._addClass(labels, null, "ui-widget ui-widget-content ui-state-default");
                        childWidgets = childWidgets.concat(labels.get());
                        return;
                    }
                    if (!$.fn[widget]) {
                        return;
                    }
                    if (that["_" + widget + "Options"]) {
                        options = that["_" + widget + "Options"]("middle");
                    } else {
                        options = {
                            classes: {}
                        };
                    }
                    that.element.find(selector).each(function() {
                        var element = $(this);
                        var instance = element[widget]("instance");
                        var instanceOptions = $.widget.extend({}, options);
                        if (widget === "button" && element.parent(".ui-spinner").length) {
                            return;
                        }
                        if (!instance) {
                            instance = element[widget]()[widget]("instance");
                        }
                        if (instance) {
                            instanceOptions.classes = that._resolveClassesValues(instanceOptions.classes, instance);
                        }
                        element[widget](instanceOptions);
                        var widgetElement = element[widget]("widget");
                        $.data(widgetElement[0], "ui-controlgroup-data", instance ? instance : element[widget]("instance"));
                        childWidgets.push(widgetElement[0]);
                    });
                });
                this.childWidgets = $($.uniqueSort(childWidgets));
                this._addClass(this.childWidgets, "ui-controlgroup-item");
            },
            _callChildMethod: function(method) {
                this.childWidgets.each(function() {
                    var element = $(this), data = element.data("ui-controlgroup-data");
                    if (data && data[method]) {
                        data[method]();
                    }
                });
            },
            _updateCornerClass: function(element, position) {
                var remove = "ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all";
                var add = this._buildSimpleOptions(position, "label").classes.label;
                this._removeClass(element, null, remove);
                this._addClass(element, null, add);
            },
            _buildSimpleOptions: function(position, key) {
                var direction = this.options.direction === "vertical";
                var result = {
                    classes: {}
                };
                result.classes[key] = {
                    middle: "",
                    first: "ui-corner-" + (direction ? "top" : "left"),
                    last: "ui-corner-" + (direction ? "bottom" : "right"),
                    only: "ui-corner-all"
                }[position];
                return result;
            },
            _spinnerOptions: function(position) {
                var options = this._buildSimpleOptions(position, "ui-spinner");
                options.classes["ui-spinner-up"] = "";
                options.classes["ui-spinner-down"] = "";
                return options;
            },
            _buttonOptions: function(position) {
                return this._buildSimpleOptions(position, "ui-button");
            },
            _checkboxradioOptions: function(position) {
                return this._buildSimpleOptions(position, "ui-checkboxradio-label");
            },
            _selectmenuOptions: function(position) {
                var direction = this.options.direction === "vertical";
                return {
                    width: direction ? "auto" : false,
                    classes: {
                        middle: {
                            "ui-selectmenu-button-open": "",
                            "ui-selectmenu-button-closed": ""
                        },
                        first: {
                            "ui-selectmenu-button-open": "ui-corner-" + (direction ? "top" : "tl"),
                            "ui-selectmenu-button-closed": "ui-corner-" + (direction ? "top" : "left")
                        },
                        last: {
                            "ui-selectmenu-button-open": direction ? "" : "ui-corner-tr",
                            "ui-selectmenu-button-closed": "ui-corner-" + (direction ? "bottom" : "right")
                        },
                        only: {
                            "ui-selectmenu-button-open": "ui-corner-top",
                            "ui-selectmenu-button-closed": "ui-corner-all"
                        }
                    }[position]
                };
            },
            _resolveClassesValues: function(classes, instance) {
                var result = {};
                $.each(classes, function(key) {
                    var current = instance.options.classes[key] || "";
                    current = $.trim(current.replace(controlgroupCornerRegex, ""));
                    result[key] = (current + " " + classes[key]).replace(/\s+/g, " ");
                });
                return result;
            },
            _setOption: function(key, value) {
                if (key === "direction") {
                    this._removeClass("ui-controlgroup-" + this.options.direction);
                }
                this._super(key, value);
                if (key === "disabled") {
                    this._callChildMethod(value ? "disable" : "enable");
                    return;
                }
                this.refresh();
            },
            refresh: function() {
                var children, that = this;
                this._addClass("ui-controlgroup ui-controlgroup-" + this.options.direction);
                if (this.options.direction === "horizontal") {
                    this._addClass(null, "ui-helper-clearfix");
                }
                this._initWidgets();
                children = this.childWidgets;
                if (this.options.onlyVisible) {
                    children = children.filter(":visible");
                }
                if (children.length) {
                    $.each([ "first", "last" ], function(index, value) {
                        var instance = children[value]().data("ui-controlgroup-data");
                        if (instance && that["_" + instance.widgetName + "Options"]) {
                            var options = that["_" + instance.widgetName + "Options"](children.length === 1 ? "only" : value);
                            options.classes = that._resolveClassesValues(options.classes, instance);
                            instance.element[instance.widgetName](options);
                        } else {
                            that._updateCornerClass(children[value](), value);
                        }
                    });
                    this._callChildMethod("refresh");
                }
            }
        });
    });
    define("skylark-jqueryui/form-reset-mixin", [ "skylark-jquery", "./form", "./version" ], function($) {
        return $.ui.formResetMixin = {
            _formResetHandler: function() {
                var form = $(this);
                setTimeout(function() {
                    var instances = form.data("ui-form-reset-instances");
                    $.each(instances, function() {
                        this.refresh();
                    });
                });
            },
            _bindFormResetHandler: function() {
                this.form = this.element._form();
                if (!this.form.length) {
                    return;
                }
                var instances = this.form.data("ui-form-reset-instances") || [];
                if (!instances.length) {
                    this.form.on("reset.ui-form-reset", this._formResetHandler);
                }
                instances.push(this);
                this.form.data("ui-form-reset-instances", instances);
            },
            _unbindFormResetHandler: function() {
                if (!this.form.length) {
                    return;
                }
                var instances = this.form.data("ui-form-reset-instances");
                instances.splice($.inArray(this, instances), 1);
                if (instances.length) {
                    this.form.data("ui-form-reset-instances", instances);
                } else {
                    this.form.removeData("ui-form-reset-instances").off("reset.ui-form-reset");
                }
            }
        };
    });
    define("skylark-jqueryui/widgets/checkboxradio", [ "skylark-jquery", "../escape-selector", "../form-reset-mixin", "../labels", "../widget" ], function($) {
        $.widget("ui.checkboxradio", [ $.ui.formResetMixin, {
            version: "@VERSION",
            options: {
                disabled: null,
                label: null,
                icon: true,
                classes: {
                    "ui-checkboxradio-label": "ui-corner-all",
                    "ui-checkboxradio-icon": "ui-corner-all"
                }
            },
            _getCreateOptions: function() {
                var disabled, labels;
                var that = this;
                var options = this._super() || {};
                this._readType();
                labels = this.element.labels();
                this.label = $(labels[labels.length - 1]);
                if (!this.label.length) {
                    $.error("No label found for checkboxradio widget");
                }
                this.originalLabel = "";
                this.label.contents().not(this.element[0]).each(function() {
                    that.originalLabel += this.nodeType === 3 ? $(this).text() : this.outerHTML;
                });
                if (this.originalLabel) {
                    options.label = this.originalLabel;
                }
                disabled = this.element[0].disabled;
                if (disabled != null) {
                    options.disabled = disabled;
                }
                return options;
            },
            _create: function() {
                var checked = this.element[0].checked;
                this._bindFormResetHandler();
                if (this.options.disabled == null) {
                    this.options.disabled = this.element[0].disabled;
                }
                this._setOption("disabled", this.options.disabled);
                this._addClass("ui-checkboxradio", "ui-helper-hidden-accessible");
                this._addClass(this.label, "ui-checkboxradio-label", "ui-button ui-widget");
                if (this.type === "radio") {
                    this._addClass(this.label, "ui-checkboxradio-radio-label");
                }
                if (this.options.label && this.options.label !== this.originalLabel) {
                    this._updateLabel();
                } else if (this.originalLabel) {
                    this.options.label = this.originalLabel;
                }
                this._enhance();
                if (checked) {
                    this._addClass(this.label, "ui-checkboxradio-checked", "ui-state-active");
                }
                this._on({
                    change: "_toggleClasses",
                    focus: function() {
                        this._addClass(this.label, null, "ui-state-focus ui-visual-focus");
                    },
                    blur: function() {
                        this._removeClass(this.label, null, "ui-state-focus ui-visual-focus");
                    }
                });
            },
            _readType: function() {
                var nodeName = this.element[0].nodeName.toLowerCase();
                this.type = this.element[0].type;
                if (nodeName !== "input" || !/radio|checkbox/.test(this.type)) {
                    $.error("Can't create checkboxradio on element.nodeName=" + nodeName + " and element.type=" + this.type);
                }
            },
            _enhance: function() {
                this._updateIcon(this.element[0].checked);
            },
            widget: function() {
                return this.label;
            },
            _getRadioGroup: function() {
                var group;
                var name = this.element[0].name;
                var nameSelector = "input[name='" + $.ui.escapeSelector(name) + "']";
                if (!name) {
                    return $([]);
                }
                if (this.form.length) {
                    group = $(this.form[0].elements).filter(nameSelector);
                } else {
                    group = $(nameSelector).filter(function() {
                        return $(this)._form().length === 0;
                    });
                }
                return group.not(this.element);
            },
            _toggleClasses: function() {
                var checked = this.element[0].checked;
                this._toggleClass(this.label, "ui-checkboxradio-checked", "ui-state-active", checked);
                if (this.options.icon && this.type === "checkbox") {
                    this._toggleClass(this.icon, null, "ui-icon-check ui-state-checked", checked)._toggleClass(this.icon, null, "ui-icon-blank", !checked);
                }
                if (this.type === "radio") {
                    this._getRadioGroup().each(function() {
                        var instance = $(this).checkboxradio("instance");
                        if (instance) {
                            instance._removeClass(instance.label, "ui-checkboxradio-checked", "ui-state-active");
                        }
                    });
                }
            },
            _destroy: function() {
                this._unbindFormResetHandler();
                if (this.icon) {
                    this.icon.remove();
                    this.iconSpace.remove();
                }
            },
            _setOption: function(key, value) {
                if (key === "label" && !value) {
                    return;
                }
                this._super(key, value);
                if (key === "disabled") {
                    this._toggleClass(this.label, null, "ui-state-disabled", value);
                    this.element[0].disabled = value;
                    return;
                }
                this.refresh();
            },
            _updateIcon: function(checked) {
                var toAdd = "ui-icon ui-icon-background ";
                if (this.options.icon) {
                    if (!this.icon) {
                        this.icon = $("<span>");
                        this.iconSpace = $("<span> </span>");
                        this._addClass(this.iconSpace, "ui-checkboxradio-icon-space");
                    }
                    if (this.type === "checkbox") {
                        toAdd += checked ? "ui-icon-check ui-state-checked" : "ui-icon-blank";
                        this._removeClass(this.icon, null, checked ? "ui-icon-blank" : "ui-icon-check");
                    } else {
                        toAdd += "ui-icon-blank";
                    }
                    this._addClass(this.icon, "ui-checkboxradio-icon", toAdd);
                    if (!checked) {
                        this._removeClass(this.icon, null, "ui-icon-check ui-state-checked");
                    }
                    this.icon.prependTo(this.label).after(this.iconSpace);
                } else if (this.icon !== undefined) {
                    this.icon.remove();
                    this.iconSpace.remove();
                    delete this.icon;
                }
            },
            _updateLabel: function() {
                var contents = this.label.contents().not(this.element[0]);
                if (this.icon) {
                    contents = contents.not(this.icon[0]);
                }
                if (this.iconSpace) {
                    contents = contents.not(this.iconSpace[0]);
                }
                contents.remove();
                this.label.append(this.options.label);
            },
            refresh: function() {
                var checked = this.element[0].checked, isDisabled = this.element[0].disabled;
                this._updateIcon(checked);
                this._toggleClass(this.label, "ui-checkboxradio-checked", "ui-state-active", checked);
                if (this.options.label !== null) {
                    this._updateLabel();
                }
                if (isDisabled !== this.options.disabled) {
                    this._setOptions({
                        disabled: isDisabled
                    });
                }
            }
        } ]);
        return $.ui.checkboxradio;
    });
    define("skylark-jqueryui/widgets/button", [ "skylark-jquery", "./controlgroup", "./checkboxradio", "../keycode", "../widget" ], function($) {
        $.widget("ui.button", {
            version: "@VERSION",
            defaultElement: "<button>",
            options: {
                classes: {
                    "ui-button": "ui-corner-all"
                },
                disabled: null,
                icon: null,
                iconPosition: "beginning",
                label: null,
                showLabel: true
            },
            _getCreateOptions: function() {
                var disabled, options = this._super() || {};
                this.isInput = this.element.is("input");
                disabled = this.element[0].disabled;
                if (disabled != null) {
                    options.disabled = disabled;
                }
                this.originalLabel = this.isInput ? this.element.val() : this.element.html();
                if (this.originalLabel) {
                    options.label = this.originalLabel;
                }
                return options;
            },
            _create: function() {
                if (!this.option.showLabel & !this.options.icon) {
                    this.options.showLabel = true;
                }
                if (this.options.disabled == null) {
                    this.options.disabled = this.element[0].disabled || false;
                }
                this.hasTitle = !!this.element.attr("title");
                if (this.options.label && this.options.label !== this.originalLabel) {
                    if (this.isInput) {
                        this.element.val(this.options.label);
                    } else {
                        this.element.html(this.options.label);
                    }
                }
                this._addClass("ui-button", "ui-widget");
                this._setOption("disabled", this.options.disabled);
                this._enhance();
                if (this.element.is("a")) {
                    this._on({
                        keyup: function(event) {
                            if (event.keyCode === $.ui.keyCode.SPACE) {
                                event.preventDefault();
                                if (this.element[0].click) {
                                    this.element[0].click();
                                } else {
                                    this.element.trigger("click");
                                }
                            }
                        }
                    });
                }
            },
            _enhance: function() {
                if (!this.element.is("button")) {
                    this.element.attr("role", "button");
                }
                if (this.options.icon) {
                    this._updateIcon("icon", this.options.icon);
                    this._updateTooltip();
                }
            },
            _updateTooltip: function() {
                this.title = this.element.attr("title");
                if (!this.options.showLabel && !this.title) {
                    this.element.attr("title", this.options.label);
                }
            },
            _updateIcon: function(option, value) {
                var icon = option !== "iconPosition", position = icon ? this.options.iconPosition : value, displayBlock = position === "top" || position === "bottom";
                if (!this.icon) {
                    this.icon = $("<span>");
                    this._addClass(this.icon, "ui-button-icon", "ui-icon");
                    if (!this.options.showLabel) {
                        this._addClass("ui-button-icon-only");
                    }
                } else if (icon) {
                    this._removeClass(this.icon, null, this.options.icon);
                }
                if (icon) {
                    this._addClass(this.icon, null, value);
                }
                this._attachIcon(position);
                if (displayBlock) {
                    this._addClass(this.icon, null, "ui-widget-icon-block");
                    if (this.iconSpace) {
                        this.iconSpace.remove();
                    }
                } else {
                    if (!this.iconSpace) {
                        this.iconSpace = $("<span> </span>");
                        this._addClass(this.iconSpace, "ui-button-icon-space");
                    }
                    this._removeClass(this.icon, null, "ui-wiget-icon-block");
                    this._attachIconSpace(position);
                }
            },
            _destroy: function() {
                this.element.removeAttr("role");
                if (this.icon) {
                    this.icon.remove();
                }
                if (this.iconSpace) {
                    this.iconSpace.remove();
                }
                if (!this.hasTitle) {
                    this.element.removeAttr("title");
                }
            },
            _attachIconSpace: function(iconPosition) {
                this.icon[/^(?:end|bottom)/.test(iconPosition) ? "before" : "after"](this.iconSpace);
            },
            _attachIcon: function(iconPosition) {
                this.element[/^(?:end|bottom)/.test(iconPosition) ? "append" : "prepend"](this.icon);
            },
            _setOptions: function(options) {
                var newShowLabel = options.showLabel === undefined ? this.options.showLabel : options.showLabel, newIcon = options.icon === undefined ? this.options.icon : options.icon;
                if (!newShowLabel && !newIcon) {
                    options.showLabel = true;
                }
                this._super(options);
            },
            _setOption: function(key, value) {
                if (key === "icon") {
                    if (value) {
                        this._updateIcon(key, value);
                    } else if (this.icon) {
                        this.icon.remove();
                        if (this.iconSpace) {
                            this.iconSpace.remove();
                        }
                    }
                }
                if (key === "iconPosition") {
                    this._updateIcon(key, value);
                }
                if (key === "showLabel") {
                    this._toggleClass("ui-button-icon-only", null, !value);
                    this._updateTooltip();
                }
                if (key === "label") {
                    if (this.isInput) {
                        this.element.val(value);
                    } else {
                        this.element.html(value);
                        if (this.icon) {
                            this._attachIcon(this.options.iconPosition);
                            this._attachIconSpace(this.options.iconPosition);
                        }
                    }
                }
                this._super(key, value);
                if (key === "disabled") {
                    this._toggleClass(null, "ui-state-disabled", value);
                    this.element[0].disabled = value;
                    if (value) {
                        this.element.blur();
                    }
                }
            },
            refresh: function() {
                var isDisabled = this.element.is("input, button") ? this.element[0].disabled : this.element.hasClass("ui-button-disabled");
                if (isDisabled !== this.options.disabled) {
                    this._setOptions({
                        disabled: isDisabled
                    });
                }
                this._updateTooltip();
            }
        });
        if ($.uiBackCompat !== false) {
            $.widget("ui.button", $.ui.button, {
                options: {
                    text: true,
                    icons: {
                        primary: null,
                        secondary: null
                    }
                },
                _create: function() {
                    if (this.options.showLabel && !this.options.text) {
                        this.options.showLabel = this.options.text;
                    }
                    if (!this.options.showLabel && this.options.text) {
                        this.options.text = this.options.showLabel;
                    }
                    if (!this.options.icon && (this.options.icons.primary || this.options.icons.secondary)) {
                        if (this.options.icons.primary) {
                            this.options.icon = this.options.icons.primary;
                        } else {
                            this.options.icon = this.options.icons.secondary;
                            this.options.iconPosition = "end";
                        }
                    } else if (this.options.icon) {
                        this.options.icons.primary = this.options.icon;
                    }
                    this._super();
                },
                _setOption: function(key, value) {
                    if (key === "text") {
                        this._super("showLabel", value);
                        return;
                    }
                    if (key === "showLabel") {
                        this.options.text = value;
                    }
                    if (key === "icon") {
                        this.options.icons.primary = value;
                    }
                    if (key === "icons") {
                        if (value.primary) {
                            this._super("icon", value.primary);
                            this._super("iconPosition", "beginning");
                        } else if (value.secondary) {
                            this._super("icon", value.secondary);
                            this._super("iconPosition", "end");
                        }
                    }
                    this._superApply(arguments);
                }
            });
            $.fn.button = function(orig) {
                return function(options) {
                    var isMethodCall = typeof options === "string";
                    var args = Array.prototype.slice.call(arguments, 1);
                    var returnValue = this;
                    if (isMethodCall) {
                        if (!this.length && options === "instance") {
                            returnValue = undefined;
                        } else {
                            this.each(function() {
                                var methodValue;
                                var type = $(this).attr("type");
                                var name = type !== "checkbox" && type !== "radio" ? "button" : "checkboxradio";
                                var instance = $.data(this, "ui-" + name);
                                if (options === "instance") {
                                    returnValue = instance;
                                    return false;
                                }
                                if (!instance) {
                                    return $.error("cannot call methods on button" + " prior to initialization; " + "attempted to call method '" + options + "'");
                                }
                                if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
                                    return $.error("no such method '" + options + "' for button" + " widget instance");
                                }
                                methodValue = instance[options].apply(instance, args);
                                if (methodValue !== instance && methodValue !== undefined) {
                                    returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;
                                    return false;
                                }
                            });
                        }
                    } else {
                        if (args.length) {
                            options = $.widget.extend.apply(null, [ options ].concat(args));
                        }
                        this.each(function() {
                            var type = $(this).attr("type");
                            var name = type !== "checkbox" && type !== "radio" ? "button" : "checkboxradio";
                            var instance = $.data(this, "ui-" + name);
                            if (instance) {
                                instance.option(options || {});
                                if (instance._init) {
                                    instance._init();
                                }
                            } else {
                                if (name === "button") {
                                    orig.call($(this), options);
                                    return;
                                }
                                $(this).checkboxradio($.extend({
                                    icon: false
                                }, options));
                            }
                        });
                    }
                    return returnValue;
                };
            }($.fn.button);
            $.fn.buttonset = function() {
                if (!$.ui.controlgroup) {
                    $.error("Controlgroup widget missing");
                }
                if (arguments[0] === "option" && arguments[1] === "items" && arguments[2]) {
                    return this.controlgroup.apply(this, [ arguments[0], "items.button", arguments[2] ]);
                }
                if (arguments[0] === "option" && arguments[1] === "items") {
                    return this.controlgroup.apply(this, [ arguments[0], "items.button" ]);
                }
                if (typeof arguments[0] === "object" && arguments[0].items) {
                    arguments[0].items = {
                        button: arguments[0].items
                    };
                }
                return this.controlgroup.apply(this, arguments);
            };
        }
        return $.ui.button;
    });
    define("skylark-jqueryui/widgets/datepicker", [ "skylark-jquery", "../version", "../keycode" ], function($) {
        $.extend($.ui, {
            datepicker: {
                version: "@VERSION"
            }
        });
        var datepicker_instActive;
        function datepicker_getZindex(elem) {
            var position, value;
            while (elem.length && elem[0] !== document) {
                position = elem.css("position");
                if (position === "absolute" || position === "relative" || position === "fixed") {
                    value = parseInt(elem.css("zIndex"), 10);
                    if (!isNaN(value) && value !== 0) {
                        return value;
                    }
                }
                elem = elem.parent();
            }
            return 0;
        }
        function Datepicker() {
            this._curInst = null;
            this._keyEvent = false;
            this._disabledInputs = [];
            this._datepickerShowing = false;
            this._inDialog = false;
            this._mainDivId = "ui-datepicker-div";
            this._inlineClass = "ui-datepicker-inline";
            this._appendClass = "ui-datepicker-append";
            this._triggerClass = "ui-datepicker-trigger";
            this._dialogClass = "ui-datepicker-dialog";
            this._disableClass = "ui-datepicker-disabled";
            this._unselectableClass = "ui-datepicker-unselectable";
            this._currentClass = "ui-datepicker-current-day";
            this._dayOverClass = "ui-datepicker-days-cell-over";
            this.regional = [];
            this.regional[""] = {
                closeText: "Done",
                prevText: "Prev",
                nextText: "Next",
                currentText: "Today",
                monthNames: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                monthNamesShort: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
                dayNames: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
                dayNamesShort: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
                dayNamesMin: [ "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" ],
                weekHeader: "Wk",
                dateFormat: "mm/dd/yy",
                firstDay: 0,
                isRTL: false,
                showMonthAfterYear: false,
                yearSuffix: ""
            };
            this._defaults = {
                showOn: "focus",
                showAnim: "fadeIn",
                showOptions: {},
                defaultDate: null,
                appendText: "",
                buttonText: "...",
                buttonImage: "",
                buttonImageOnly: false,
                hideIfNoPrevNext: false,
                navigationAsDateFormat: false,
                gotoCurrent: false,
                changeMonth: false,
                changeYear: false,
                yearRange: "c-10:c+10",
                showOtherMonths: false,
                selectOtherMonths: false,
                showWeek: false,
                calculateWeek: this.iso8601Week,
                shortYearCutoff: "+10",
                minDate: null,
                maxDate: null,
                duration: "fast",
                beforeShowDay: null,
                beforeShow: null,
                onSelect: null,
                onChangeMonthYear: null,
                onClose: null,
                numberOfMonths: 1,
                showCurrentAtPos: 0,
                stepMonths: 1,
                stepBigMonths: 12,
                altField: "",
                altFormat: "",
                constrainInput: true,
                showButtonPanel: false,
                autoSize: false,
                disabled: false
            };
            $.extend(this._defaults, this.regional[""]);
            this.regional.en = $.extend(true, {}, this.regional[""]);
            this.regional["en-US"] = $.extend(true, {}, this.regional.en);
            this.dpDiv = datepicker_bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
        }
        $.extend(Datepicker.prototype, {
            markerClassName: "hasDatepicker",
            maxRows: 4,
            _widgetDatepicker: function() {
                return this.dpDiv;
            },
            setDefaults: function(settings) {
                datepicker_extendRemove(this._defaults, settings || {});
                return this;
            },
            _attachDatepicker: function(target, settings) {
                var nodeName, inline, inst;
                nodeName = target.nodeName.toLowerCase();
                inline = nodeName === "div" || nodeName === "span";
                if (!target.id) {
                    this.uuid += 1;
                    target.id = "dp" + this.uuid;
                }
                inst = this._newInst($(target), inline);
                inst.settings = $.extend({}, settings || {});
                if (nodeName === "input") {
                    this._connectDatepicker(target, inst);
                } else if (inline) {
                    this._inlineDatepicker(target, inst);
                }
            },
            _newInst: function(target, inline) {
                var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1");
                return {
                    id: id,
                    input: target,
                    selectedDay: 0,
                    selectedMonth: 0,
                    selectedYear: 0,
                    drawMonth: 0,
                    drawYear: 0,
                    inline: inline,
                    dpDiv: !inline ? this.dpDiv : datepicker_bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"))
                };
            },
            _connectDatepicker: function(target, inst) {
                var input = $(target);
                inst.append = $([]);
                inst.trigger = $([]);
                if (input.hasClass(this.markerClassName)) {
                    return;
                }
                this._attachments(input, inst);
                input.addClass(this.markerClassName).on("keydown", this._doKeyDown).on("keypress", this._doKeyPress).on("keyup", this._doKeyUp);
                this._autoSize(inst);
                $.data(target, "datepicker", inst);
                if (inst.settings.disabled) {
                    this._disableDatepicker(target);
                }
            },
            _attachments: function(input, inst) {
                var showOn, buttonText, buttonImage, appendText = this._get(inst, "appendText"), isRTL = this._get(inst, "isRTL");
                if (inst.append) {
                    inst.append.remove();
                }
                if (appendText) {
                    inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
                    input[isRTL ? "before" : "after"](inst.append);
                }
                input.off("focus", this._showDatepicker);
                if (inst.trigger) {
                    inst.trigger.remove();
                }
                showOn = this._get(inst, "showOn");
                if (showOn === "focus" || showOn === "both") {
                    input.on("focus", this._showDatepicker);
                }
                if (showOn === "button" || showOn === "both") {
                    buttonText = this._get(inst, "buttonText");
                    buttonImage = this._get(inst, "buttonImage");
                    inst.trigger = $(this._get(inst, "buttonImageOnly") ? $("<img/>").addClass(this._triggerClass).attr({
                        src: buttonImage,
                        alt: buttonText,
                        title: buttonText
                    }) : $("<button type='button'></button>").addClass(this._triggerClass).html(!buttonImage ? buttonText : $("<img/>").attr({
                        src: buttonImage,
                        alt: buttonText,
                        title: buttonText
                    })));
                    input[isRTL ? "before" : "after"](inst.trigger);
                    inst.trigger.on("click", function() {
                        if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
                            $.datepicker._hideDatepicker();
                        } else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
                            $.datepicker._hideDatepicker();
                            $.datepicker._showDatepicker(input[0]);
                        } else {
                            $.datepicker._showDatepicker(input[0]);
                        }
                        return false;
                    });
                }
            },
            _autoSize: function(inst) {
                if (this._get(inst, "autoSize") && !inst.inline) {
                    var findMax, max, maxI, i, date = new Date(2009, 12 - 1, 20), dateFormat = this._get(inst, "dateFormat");
                    if (dateFormat.match(/[DM]/)) {
                        findMax = function(names) {
                            max = 0;
                            maxI = 0;
                            for (i = 0; i < names.length; i++) {
                                if (names[i].length > max) {
                                    max = names[i].length;
                                    maxI = i;
                                }
                            }
                            return maxI;
                        };
                        date.setMonth(findMax(this._get(inst, dateFormat.match(/MM/) ? "monthNames" : "monthNamesShort")));
                        date.setDate(findMax(this._get(inst, dateFormat.match(/DD/) ? "dayNames" : "dayNamesShort")) + 20 - date.getDay());
                    }
                    inst.input.attr("size", this._formatDate(inst, date).length);
                }
            },
            _inlineDatepicker: function(target, inst) {
                var divSpan = $(target);
                if (divSpan.hasClass(this.markerClassName)) {
                    return;
                }
                divSpan.addClass(this.markerClassName).append(inst.dpDiv);
                $.data(target, "datepicker", inst);
                this._setDate(inst, this._getDefaultDate(inst), true);
                this._updateDatepicker(inst);
                this._updateAlternate(inst);
                if (inst.settings.disabled) {
                    this._disableDatepicker(target);
                }
                inst.dpDiv.css("display", "block");
            },
            _dialogDatepicker: function(input, date, onSelect, settings, pos) {
                var id, browserWidth, browserHeight, scrollX, scrollY, inst = this._dialogInst;
                if (!inst) {
                    this.uuid += 1;
                    id = "dp" + this.uuid;
                    this._dialogInput = $("<input type='text' id='" + id + "' style='position: absolute; top: -100px; width: 0px;'/>");
                    this._dialogInput.on("keydown", this._doKeyDown);
                    $("body").append(this._dialogInput);
                    inst = this._dialogInst = this._newInst(this._dialogInput, false);
                    inst.settings = {};
                    $.data(this._dialogInput[0], "datepicker", inst);
                }
                datepicker_extendRemove(inst.settings, settings || {});
                date = date && date.constructor === Date ? this._formatDate(inst, date) : date;
                this._dialogInput.val(date);
                this._pos = pos ? pos.length ? pos : [ pos.pageX, pos.pageY ] : null;
                if (!this._pos) {
                    browserWidth = document.documentElement.clientWidth;
                    browserHeight = document.documentElement.clientHeight;
                    scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
                    scrollY = document.documentElement.scrollTop || document.body.scrollTop;
                    this._pos = [ browserWidth / 2 - 100 + scrollX, browserHeight / 2 - 150 + scrollY ];
                }
                this._dialogInput.css("left", this._pos[0] + 20 + "px").css("top", this._pos[1] + "px");
                inst.settings.onSelect = onSelect;
                this._inDialog = true;
                this.dpDiv.addClass(this._dialogClass);
                this._showDatepicker(this._dialogInput[0]);
                if ($.blockUI) {
                    $.blockUI(this.dpDiv);
                }
                $.data(this._dialogInput[0], "datepicker", inst);
                return this;
            },
            _destroyDatepicker: function(target) {
                var nodeName, $target = $(target), inst = $.data(target, "datepicker");
                if (!$target.hasClass(this.markerClassName)) {
                    return;
                }
                nodeName = target.nodeName.toLowerCase();
                $.removeData(target, "datepicker");
                if (nodeName === "input") {
                    inst.append.remove();
                    inst.trigger.remove();
                    $target.removeClass(this.markerClassName).off("focus", this._showDatepicker).off("keydown", this._doKeyDown).off("keypress", this._doKeyPress).off("keyup", this._doKeyUp);
                } else if (nodeName === "div" || nodeName === "span") {
                    $target.removeClass(this.markerClassName).empty();
                }
                if (datepicker_instActive === inst) {
                    datepicker_instActive = null;
                }
            },
            _enableDatepicker: function(target) {
                var nodeName, inline, $target = $(target), inst = $.data(target, "datepicker");
                if (!$target.hasClass(this.markerClassName)) {
                    return;
                }
                nodeName = target.nodeName.toLowerCase();
                if (nodeName === "input") {
                    target.disabled = false;
                    inst.trigger.filter("button").each(function() {
                        this.disabled = false;
                    }).end().filter("img").css({
                        opacity: "1.0",
                        cursor: ""
                    });
                } else if (nodeName === "div" || nodeName === "span") {
                    inline = $target.children("." + this._inlineClass);
                    inline.children().removeClass("ui-state-disabled");
                    inline.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", false);
                }
                this._disabledInputs = $.map(this._disabledInputs, function(value) {
                    return value === target ? null : value;
                });
            },
            _disableDatepicker: function(target) {
                var nodeName, inline, $target = $(target), inst = $.data(target, "datepicker");
                if (!$target.hasClass(this.markerClassName)) {
                    return;
                }
                nodeName = target.nodeName.toLowerCase();
                if (nodeName === "input") {
                    target.disabled = true;
                    inst.trigger.filter("button").each(function() {
                        this.disabled = true;
                    }).end().filter("img").css({
                        opacity: "0.5",
                        cursor: "default"
                    });
                } else if (nodeName === "div" || nodeName === "span") {
                    inline = $target.children("." + this._inlineClass);
                    inline.children().addClass("ui-state-disabled");
                    inline.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", true);
                }
                this._disabledInputs = $.map(this._disabledInputs, function(value) {
                    return value === target ? null : value;
                });
                this._disabledInputs[this._disabledInputs.length] = target;
            },
            _isDisabledDatepicker: function(target) {
                if (!target) {
                    return false;
                }
                for (var i = 0; i < this._disabledInputs.length; i++) {
                    if (this._disabledInputs[i] === target) {
                        return true;
                    }
                }
                return false;
            },
            _getInst: function(target) {
                try {
                    return $.data(target, "datepicker");
                } catch (err) {
                    throw "Missing instance data for this datepicker";
                }
            },
            _optionDatepicker: function(target, name, value) {
                var settings, date, minDate, maxDate, inst = this._getInst(target);
                if (arguments.length === 2 && typeof name === "string") {
                    return name === "defaults" ? $.extend({}, $.datepicker._defaults) : inst ? name === "all" ? $.extend({}, inst.settings) : this._get(inst, name) : null;
                }
                settings = name || {};
                if (typeof name === "string") {
                    settings = {};
                    settings[name] = value;
                }
                if (inst) {
                    if (this._curInst === inst) {
                        this._hideDatepicker();
                    }
                    date = this._getDateDatepicker(target, true);
                    minDate = this._getMinMaxDate(inst, "min");
                    maxDate = this._getMinMaxDate(inst, "max");
                    datepicker_extendRemove(inst.settings, settings);
                    if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
                        inst.settings.minDate = this._formatDate(inst, minDate);
                    }
                    if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
                        inst.settings.maxDate = this._formatDate(inst, maxDate);
                    }
                    if ("disabled" in settings) {
                        if (settings.disabled) {
                            this._disableDatepicker(target);
                        } else {
                            this._enableDatepicker(target);
                        }
                    }
                    this._attachments($(target), inst);
                    this._autoSize(inst);
                    this._setDate(inst, date);
                    this._updateAlternate(inst);
                    this._updateDatepicker(inst);
                }
            },
            _changeDatepicker: function(target, name, value) {
                this._optionDatepicker(target, name, value);
            },
            _refreshDatepicker: function(target) {
                var inst = this._getInst(target);
                if (inst) {
                    this._updateDatepicker(inst);
                }
            },
            _setDateDatepicker: function(target, date) {
                var inst = this._getInst(target);
                if (inst) {
                    this._setDate(inst, date);
                    this._updateDatepicker(inst);
                    this._updateAlternate(inst);
                }
            },
            _getDateDatepicker: function(target, noDefault) {
                var inst = this._getInst(target);
                if (inst && !inst.inline) {
                    this._setDateFromField(inst, noDefault);
                }
                return inst ? this._getDate(inst) : null;
            },
            _doKeyDown: function(event) {
                var onSelect, dateStr, sel, inst = $.datepicker._getInst(event.target), handled = true, isRTL = inst.dpDiv.is(".ui-datepicker-rtl");
                inst._keyEvent = true;
                if ($.datepicker._datepickerShowing) {
                    switch (event.keyCode) {
                      case 9:
                        $.datepicker._hideDatepicker();
                        handled = false;
                        break;

                      case 13:
                        sel = $("td." + $.datepicker._dayOverClass + ":not(." + $.datepicker._currentClass + ")", inst.dpDiv);
                        if (sel[0]) {
                            $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
                        }
                        onSelect = $.datepicker._get(inst, "onSelect");
                        if (onSelect) {
                            dateStr = $.datepicker._formatDate(inst);
                            onSelect.apply(inst.input ? inst.input[0] : null, [ dateStr, inst ]);
                        } else {
                            $.datepicker._hideDatepicker();
                        }
                        return false;

                      case 27:
                        $.datepicker._hideDatepicker();
                        break;

                      case 33:
                        $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, "stepBigMonths") : -$.datepicker._get(inst, "stepMonths"), "M");
                        break;

                      case 34:
                        $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, "stepBigMonths") : +$.datepicker._get(inst, "stepMonths"), "M");
                        break;

                      case 35:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._clearDate(event.target);
                        }
                        handled = event.ctrlKey || event.metaKey;
                        break;

                      case 36:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._gotoToday(event.target);
                        }
                        handled = event.ctrlKey || event.metaKey;
                        break;

                      case 37:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(event.target, isRTL ? +1 : -1, "D");
                        }
                        handled = event.ctrlKey || event.metaKey;
                        if (event.originalEvent.altKey) {
                            $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, "stepBigMonths") : -$.datepicker._get(inst, "stepMonths"), "M");
                        }
                        break;

                      case 38:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(event.target, -7, "D");
                        }
                        handled = event.ctrlKey || event.metaKey;
                        break;

                      case 39:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(event.target, isRTL ? -1 : +1, "D");
                        }
                        handled = event.ctrlKey || event.metaKey;
                        if (event.originalEvent.altKey) {
                            $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, "stepBigMonths") : +$.datepicker._get(inst, "stepMonths"), "M");
                        }
                        break;

                      case 40:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(event.target, +7, "D");
                        }
                        handled = event.ctrlKey || event.metaKey;
                        break;

                      default:
                        handled = false;
                    }
                } else if (event.keyCode === 36 && event.ctrlKey) {
                    $.datepicker._showDatepicker(this);
                } else {
                    handled = false;
                }
                if (handled) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            },
            _doKeyPress: function(event) {
                var chars, chr, inst = $.datepicker._getInst(event.target);
                if ($.datepicker._get(inst, "constrainInput")) {
                    chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
                    chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
                    return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
                }
            },
            _doKeyUp: function(event) {
                var date, inst = $.datepicker._getInst(event.target);
                if (inst.input.val() !== inst.lastVal) {
                    try {
                        date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"), inst.input ? inst.input.val() : null, $.datepicker._getFormatConfig(inst));
                        if (date) {
                            $.datepicker._setDateFromField(inst);
                            $.datepicker._updateAlternate(inst);
                            $.datepicker._updateDatepicker(inst);
                        }
                    } catch (err) {}
                }
                return true;
            },
            _showDatepicker: function(input) {
                input = input.target || input;
                if (input.nodeName.toLowerCase() !== "input") {
                    input = $("input", input.parentNode)[0];
                }
                if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) {
                    return;
                }
                var inst, beforeShow, beforeShowSettings, isFixed, offset, showAnim, duration;
                inst = $.datepicker._getInst(input);
                if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
                    $.datepicker._curInst.dpDiv.stop(true, true);
                    if (inst && $.datepicker._datepickerShowing) {
                        $.datepicker._hideDatepicker($.datepicker._curInst.input[0]);
                    }
                }
                beforeShow = $.datepicker._get(inst, "beforeShow");
                beforeShowSettings = beforeShow ? beforeShow.apply(input, [ input, inst ]) : {};
                if (beforeShowSettings === false) {
                    return;
                }
                datepicker_extendRemove(inst.settings, beforeShowSettings);
                inst.lastVal = null;
                $.datepicker._lastInput = input;
                $.datepicker._setDateFromField(inst);
                if ($.datepicker._inDialog) {
                    input.value = "";
                }
                if (!$.datepicker._pos) {
                    $.datepicker._pos = $.datepicker._findPos(input);
                    $.datepicker._pos[1] += input.offsetHeight;
                }
                isFixed = false;
                $(input).parents().each(function() {
                    isFixed |= $(this).css("position") === "fixed";
                    return !isFixed;
                });
                offset = {
                    left: $.datepicker._pos[0],
                    top: $.datepicker._pos[1]
                };
                $.datepicker._pos = null;
                inst.dpDiv.empty();
                inst.dpDiv.css({
                    position: "absolute",
                    display: "block",
                    top: "-1000px"
                });
                $.datepicker._updateDatepicker(inst);
                offset = $.datepicker._checkOffset(inst, offset, isFixed);
                inst.dpDiv.css({
                    position: $.datepicker._inDialog && $.blockUI ? "static" : isFixed ? "fixed" : "absolute",
                    display: "none",
                    left: offset.left + "px",
                    top: offset.top + "px"
                });
                if (!inst.inline) {
                    showAnim = $.datepicker._get(inst, "showAnim");
                    duration = $.datepicker._get(inst, "duration");
                    inst.dpDiv.css("z-index", datepicker_getZindex($(input)) + 1);
                    $.datepicker._datepickerShowing = true;
                    if ($.effects && $.effects.effect[showAnim]) {
                        inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
                    } else {
                        inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
                    }
                    if ($.datepicker._shouldFocusInput(inst)) {
                        inst.input.trigger("focus");
                    }
                    $.datepicker._curInst = inst;
                }
            },
            _updateDatepicker: function(inst) {
                this.maxRows = 4;
                datepicker_instActive = inst;
                inst.dpDiv.empty().append(this._generateHTML(inst));
                this._attachHandlers(inst);
                var origyearshtml, numMonths = this._getNumberOfMonths(inst), cols = numMonths[1], width = 17, activeCell = inst.dpDiv.find("." + this._dayOverClass + " a");
                if (activeCell.length > 0) {
                    datepicker_handleMouseover.apply(activeCell.get(0));
                }
                inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
                if (cols > 1) {
                    inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", width * cols + "em");
                }
                inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") + "Class"]("ui-datepicker-multi");
                inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") + "Class"]("ui-datepicker-rtl");
                if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput(inst)) {
                    inst.input.trigger("focus");
                }
                if (inst.yearshtml) {
                    origyearshtml = inst.yearshtml;
                    setTimeout(function() {
                        if (origyearshtml === inst.yearshtml && inst.yearshtml) {
                            inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
                        }
                        origyearshtml = inst.yearshtml = null;
                    }, 0);
                }
            },
            _shouldFocusInput: function(inst) {
                return inst.input && inst.input.is(":visible") && !inst.input.is(":disabled") && !inst.input.is(":focus");
            },
            _checkOffset: function(inst, offset, isFixed) {
                var dpWidth = inst.dpDiv.outerWidth(), dpHeight = inst.dpDiv.outerHeight(), inputWidth = inst.input ? inst.input.outerWidth() : 0, inputHeight = inst.input ? inst.input.outerHeight() : 0, viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()), viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());
                offset.left -= this._get(inst, "isRTL") ? dpWidth - inputWidth : 0;
                offset.left -= isFixed && offset.left === inst.input.offset().left ? $(document).scrollLeft() : 0;
                offset.top -= isFixed && offset.top === inst.input.offset().top + inputHeight ? $(document).scrollTop() : 0;
                offset.left -= Math.min(offset.left, offset.left + dpWidth > viewWidth && viewWidth > dpWidth ? Math.abs(offset.left + dpWidth - viewWidth) : 0);
                offset.top -= Math.min(offset.top, offset.top + dpHeight > viewHeight && viewHeight > dpHeight ? Math.abs(dpHeight + inputHeight) : 0);
                return offset;
            },
            _findPos: function(obj) {
                var position, inst = this._getInst(obj), isRTL = this._get(inst, "isRTL");
                while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
                    obj = obj[isRTL ? "previousSibling" : "nextSibling"];
                }
                position = $(obj).offset();
                return [ position.left, position.top ];
            },
            _hideDatepicker: function(input) {
                var showAnim, duration, postProcess, onClose, inst = this._curInst;
                if (!inst || input && inst !== $.data(input, "datepicker")) {
                    return;
                }
                if (this._datepickerShowing) {
                    showAnim = this._get(inst, "showAnim");
                    duration = this._get(inst, "duration");
                    postProcess = function() {
                        $.datepicker._tidyDialog(inst);
                    };
                    if ($.effects && ($.effects.effect[showAnim] || $.effects[showAnim])) {
                        inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
                    } else {
                        inst.dpDiv[showAnim === "slideDown" ? "slideUp" : showAnim === "fadeIn" ? "fadeOut" : "hide"](showAnim ? duration : null, postProcess);
                    }
                    if (!showAnim) {
                        postProcess();
                    }
                    this._datepickerShowing = false;
                    onClose = this._get(inst, "onClose");
                    if (onClose) {
                        onClose.apply(inst.input ? inst.input[0] : null, [ inst.input ? inst.input.val() : "", inst ]);
                    }
                    this._lastInput = null;
                    if (this._inDialog) {
                        this._dialogInput.css({
                            position: "absolute",
                            left: "0",
                            top: "-100px"
                        });
                        if ($.blockUI) {
                            $.unblockUI();
                            $("body").append(this.dpDiv);
                        }
                    }
                    this._inDialog = false;
                }
            },
            _tidyDialog: function(inst) {
                inst.dpDiv.removeClass(this._dialogClass).off(".ui-datepicker-calendar");
            },
            _checkExternalClick: function(event) {
                if (!$.datepicker._curInst) {
                    return;
                }
                var $target = $(event.target), inst = $.datepicker._getInst($target[0]);
                if ($target[0].id !== $.datepicker._mainDivId && $target.parents("#" + $.datepicker._mainDivId).length === 0 && !$target.hasClass($.datepicker.markerClassName) && !$target.closest("." + $.datepicker._triggerClass).length && $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) || $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst) {
                    $.datepicker._hideDatepicker();
                }
            },
            _adjustDate: function(id, offset, period) {
                var target = $(id), inst = this._getInst(target[0]);
                if (this._isDisabledDatepicker(target[0])) {
                    return;
                }
                this._adjustInstDate(inst, offset, period);
                this._updateDatepicker(inst);
            },
            _gotoToday: function(id) {
                var date, target = $(id), inst = this._getInst(target[0]);
                if (this._get(inst, "gotoCurrent") && inst.currentDay) {
                    inst.selectedDay = inst.currentDay;
                    inst.drawMonth = inst.selectedMonth = inst.currentMonth;
                    inst.drawYear = inst.selectedYear = inst.currentYear;
                } else {
                    date = new Date();
                    inst.selectedDay = date.getDate();
                    inst.drawMonth = inst.selectedMonth = date.getMonth();
                    inst.drawYear = inst.selectedYear = date.getFullYear();
                }
                this._notifyChange(inst);
                this._adjustDate(target);
            },
            _selectMonthYear: function(id, select, period) {
                var target = $(id), inst = this._getInst(target[0]);
                inst["selected" + (period === "M" ? "Month" : "Year")] = inst["draw" + (period === "M" ? "Month" : "Year")] = parseInt(select.options[select.selectedIndex].value, 10);
                this._notifyChange(inst);
                this._adjustDate(target);
            },
            _selectDay: function(id, month, year, td) {
                var inst, target = $(id);
                if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
                    return;
                }
                inst = this._getInst(target[0]);
                inst.selectedDay = inst.currentDay = $("a", td).html();
                inst.selectedMonth = inst.currentMonth = month;
                inst.selectedYear = inst.currentYear = year;
                this._selectDate(id, this._formatDate(inst, inst.currentDay, inst.currentMonth, inst.currentYear));
            },
            _clearDate: function(id) {
                var target = $(id);
                this._selectDate(target, "");
            },
            _selectDate: function(id, dateStr) {
                var onSelect, target = $(id), inst = this._getInst(target[0]);
                dateStr = dateStr != null ? dateStr : this._formatDate(inst);
                if (inst.input) {
                    inst.input.val(dateStr);
                }
                this._updateAlternate(inst);
                onSelect = this._get(inst, "onSelect");
                if (onSelect) {
                    onSelect.apply(inst.input ? inst.input[0] : null, [ dateStr, inst ]);
                } else if (inst.input) {
                    inst.input.trigger("change");
                }
                if (inst.inline) {
                    this._updateDatepicker(inst);
                } else {
                    this._hideDatepicker();
                    this._lastInput = inst.input[0];
                    if (typeof inst.input[0] !== "object") {
                        inst.input.trigger("focus");
                    }
                    this._lastInput = null;
                }
            },
            _updateAlternate: function(inst) {
                var altFormat, date, dateStr, altField = this._get(inst, "altField");
                if (altField) {
                    altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
                    date = this._getDate(inst);
                    dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
                    $(altField).val(dateStr);
                }
            },
            noWeekends: function(date) {
                var day = date.getDay();
                return [ day > 0 && day < 6, "" ];
            },
            iso8601Week: function(date) {
                var time, checkDate = new Date(date.getTime());
                checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
                time = checkDate.getTime();
                checkDate.setMonth(0);
                checkDate.setDate(1);
                return Math.floor(Math.round((time - checkDate) / 864e5) / 7) + 1;
            },
            parseDate: function(format, value, settings) {
                if (format == null || value == null) {
                    throw "Invalid arguments";
                }
                value = typeof value === "object" ? value.toString() : value + "";
                if (value === "") {
                    return null;
                }
                var iFormat, dim, extra, iValue = 0, shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff, shortYearCutoff = typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp : new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10), dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort, dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames, monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort, monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames, year = -1, month = -1, day = -1, doy = -1, literal = false, date, lookAhead = function(match) {
                    var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                }, getNumber = function(match) {
                    var isDoubled = lookAhead(match), size = match === "@" ? 14 : match === "!" ? 20 : match === "y" && isDoubled ? 4 : match === "o" ? 3 : 2, minSize = match === "y" ? size : 1, digits = new RegExp("^\\d{" + minSize + "," + size + "}"), num = value.substring(iValue).match(digits);
                    if (!num) {
                        throw "Missing number at position " + iValue;
                    }
                    iValue += num[0].length;
                    return parseInt(num[0], 10);
                }, getName = function(match, shortNames, longNames) {
                    var index = -1, names = $.map(lookAhead(match) ? longNames : shortNames, function(v, k) {
                        return [ [ k, v ] ];
                    }).sort(function(a, b) {
                        return -(a[1].length - b[1].length);
                    });
                    $.each(names, function(i, pair) {
                        var name = pair[1];
                        if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
                            index = pair[0];
                            iValue += name.length;
                            return false;
                        }
                    });
                    if (index !== -1) {
                        return index + 1;
                    } else {
                        throw "Unknown name at position " + iValue;
                    }
                }, checkLiteral = function() {
                    if (value.charAt(iValue) !== format.charAt(iFormat)) {
                        throw "Unexpected literal at position " + iValue;
                    }
                    iValue++;
                };
                for (iFormat = 0; iFormat < format.length; iFormat++) {
                    if (literal) {
                        if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                            literal = false;
                        } else {
                            checkLiteral();
                        }
                    } else {
                        switch (format.charAt(iFormat)) {
                          case "d":
                            day = getNumber("d");
                            break;

                          case "D":
                            getName("D", dayNamesShort, dayNames);
                            break;

                          case "o":
                            doy = getNumber("o");
                            break;

                          case "m":
                            month = getNumber("m");
                            break;

                          case "M":
                            month = getName("M", monthNamesShort, monthNames);
                            break;

                          case "y":
                            year = getNumber("y");
                            break;

                          case "@":
                            date = new Date(getNumber("@"));
                            year = date.getFullYear();
                            month = date.getMonth() + 1;
                            day = date.getDate();
                            break;

                          case "!":
                            date = new Date((getNumber("!") - this._ticksTo1970) / 1e4);
                            year = date.getFullYear();
                            month = date.getMonth() + 1;
                            day = date.getDate();
                            break;

                          case "'":
                            if (lookAhead("'")) {
                                checkLiteral();
                            } else {
                                literal = true;
                            }
                            break;

                          default:
                            checkLiteral();
                        }
                    }
                }
                if (iValue < value.length) {
                    extra = value.substr(iValue);
                    if (!/^\s+/.test(extra)) {
                        throw "Extra/unparsed characters found in date: " + extra;
                    }
                }
                if (year === -1) {
                    year = new Date().getFullYear();
                } else if (year < 100) {
                    year += new Date().getFullYear() - new Date().getFullYear() % 100 + (year <= shortYearCutoff ? 0 : -100);
                }
                if (doy > -1) {
                    month = 1;
                    day = doy;
                    do {
                        dim = this._getDaysInMonth(year, month - 1);
                        if (day <= dim) {
                            break;
                        }
                        month++;
                        day -= dim;
                    } while (true);
                }
                date = this._daylightSavingAdjust(new Date(year, month - 1, day));
                if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
                    throw "Invalid date";
                }
                return date;
            },
            ATOM: "yy-mm-dd",
            COOKIE: "D, dd M yy",
            ISO_8601: "yy-mm-dd",
            RFC_822: "D, d M y",
            RFC_850: "DD, dd-M-y",
            RFC_1036: "D, d M y",
            RFC_1123: "D, d M yy",
            RFC_2822: "D, d M yy",
            RSS: "D, d M y",
            TICKS: "!",
            TIMESTAMP: "@",
            W3C: "yy-mm-dd",
            _ticksTo1970: ((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) + Math.floor(1970 / 400)) * 24 * 60 * 60 * 1e7,
            formatDate: function(format, date, settings) {
                if (!date) {
                    return "";
                }
                var iFormat, dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort, dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames, monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort, monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames, lookAhead = function(match) {
                    var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                }, formatNumber = function(match, value, len) {
                    var num = "" + value;
                    if (lookAhead(match)) {
                        while (num.length < len) {
                            num = "0" + num;
                        }
                    }
                    return num;
                }, formatName = function(match, value, shortNames, longNames) {
                    return lookAhead(match) ? longNames[value] : shortNames[value];
                }, output = "", literal = false;
                if (date) {
                    for (iFormat = 0; iFormat < format.length; iFormat++) {
                        if (literal) {
                            if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                                literal = false;
                            } else {
                                output += format.charAt(iFormat);
                            }
                        } else {
                            switch (format.charAt(iFormat)) {
                              case "d":
                                output += formatNumber("d", date.getDate(), 2);
                                break;

                              case "D":
                                output += formatName("D", date.getDay(), dayNamesShort, dayNames);
                                break;

                              case "o":
                                output += formatNumber("o", Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 864e5), 3);
                                break;

                              case "m":
                                output += formatNumber("m", date.getMonth() + 1, 2);
                                break;

                              case "M":
                                output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
                                break;

                              case "y":
                                output += lookAhead("y") ? date.getFullYear() : (date.getFullYear() % 100 < 10 ? "0" : "") + date.getFullYear() % 100;
                                break;

                              case "@":
                                output += date.getTime();
                                break;

                              case "!":
                                output += date.getTime() * 1e4 + this._ticksTo1970;
                                break;

                              case "'":
                                if (lookAhead("'")) {
                                    output += "'";
                                } else {
                                    literal = true;
                                }
                                break;

                              default:
                                output += format.charAt(iFormat);
                            }
                        }
                    }
                }
                return output;
            },
            _possibleChars: function(format) {
                var iFormat, chars = "", literal = false, lookAhead = function(match) {
                    var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                };
                for (iFormat = 0; iFormat < format.length; iFormat++) {
                    if (literal) {
                        if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                            literal = false;
                        } else {
                            chars += format.charAt(iFormat);
                        }
                    } else {
                        switch (format.charAt(iFormat)) {
                          case "d":
                          case "m":
                          case "y":
                          case "@":
                            chars += "0123456789";
                            break;

                          case "D":
                          case "M":
                            return null;

                          case "'":
                            if (lookAhead("'")) {
                                chars += "'";
                            } else {
                                literal = true;
                            }
                            break;

                          default:
                            chars += format.charAt(iFormat);
                        }
                    }
                }
                return chars;
            },
            _get: function(inst, name) {
                return inst.settings[name] !== undefined ? inst.settings[name] : this._defaults[name];
            },
            _setDateFromField: function(inst, noDefault) {
                if (inst.input.val() === inst.lastVal) {
                    return;
                }
                var dateFormat = this._get(inst, "dateFormat"), dates = inst.lastVal = inst.input ? inst.input.val() : null, defaultDate = this._getDefaultDate(inst), date = defaultDate, settings = this._getFormatConfig(inst);
                try {
                    date = this.parseDate(dateFormat, dates, settings) || defaultDate;
                } catch (event) {
                    dates = noDefault ? "" : dates;
                }
                inst.selectedDay = date.getDate();
                inst.drawMonth = inst.selectedMonth = date.getMonth();
                inst.drawYear = inst.selectedYear = date.getFullYear();
                inst.currentDay = dates ? date.getDate() : 0;
                inst.currentMonth = dates ? date.getMonth() : 0;
                inst.currentYear = dates ? date.getFullYear() : 0;
                this._adjustInstDate(inst);
            },
            _getDefaultDate: function(inst) {
                return this._restrictMinMax(inst, this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
            },
            _determineDate: function(inst, date, defaultDate) {
                var offsetNumeric = function(offset) {
                    var date = new Date();
                    date.setDate(date.getDate() + offset);
                    return date;
                }, offsetString = function(offset) {
                    try {
                        return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"), offset, $.datepicker._getFormatConfig(inst));
                    } catch (e) {}
                    var date = (offset.toLowerCase().match(/^c/) ? $.datepicker._getDate(inst) : null) || new Date(), year = date.getFullYear(), month = date.getMonth(), day = date.getDate(), pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g, matches = pattern.exec(offset);
                    while (matches) {
                        switch (matches[2] || "d") {
                          case "d":
                          case "D":
                            day += parseInt(matches[1], 10);
                            break;

                          case "w":
                          case "W":
                            day += parseInt(matches[1], 10) * 7;
                            break;

                          case "m":
                          case "M":
                            month += parseInt(matches[1], 10);
                            day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                            break;

                          case "y":
                          case "Y":
                            year += parseInt(matches[1], 10);
                            day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                            break;
                        }
                        matches = pattern.exec(offset);
                    }
                    return new Date(year, month, day);
                }, newDate = date == null || date === "" ? defaultDate : typeof date === "string" ? offsetString(date) : typeof date === "number" ? isNaN(date) ? defaultDate : offsetNumeric(date) : new Date(date.getTime());
                newDate = newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate;
                if (newDate) {
                    newDate.setHours(0);
                    newDate.setMinutes(0);
                    newDate.setSeconds(0);
                    newDate.setMilliseconds(0);
                }
                return this._daylightSavingAdjust(newDate);
            },
            _daylightSavingAdjust: function(date) {
                if (!date) {
                    return null;
                }
                date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
                return date;
            },
            _setDate: function(inst, date, noChange) {
                var clear = !date, origMonth = inst.selectedMonth, origYear = inst.selectedYear, newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
                inst.selectedDay = inst.currentDay = newDate.getDate();
                inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
                inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
                if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
                    this._notifyChange(inst);
                }
                this._adjustInstDate(inst);
                if (inst.input) {
                    inst.input.val(clear ? "" : this._formatDate(inst));
                }
            },
            _getDate: function(inst) {
                var startDate = !inst.currentYear || inst.input && inst.input.val() === "" ? null : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
                return startDate;
            },
            _attachHandlers: function(inst) {
                var stepMonths = this._get(inst, "stepMonths"), id = "#" + inst.id.replace(/\\\\/g, "\\");
                inst.dpDiv.find("[data-handler]").map(function() {
                    var handler = {
                        prev: function() {
                            $.datepicker._adjustDate(id, -stepMonths, "M");
                        },
                        next: function() {
                            $.datepicker._adjustDate(id, +stepMonths, "M");
                        },
                        hide: function() {
                            $.datepicker._hideDatepicker();
                        },
                        today: function() {
                            $.datepicker._gotoToday(id);
                        },
                        selectDay: function() {
                            $.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
                            return false;
                        },
                        selectMonth: function() {
                            $.datepicker._selectMonthYear(id, this, "M");
                            return false;
                        },
                        selectYear: function() {
                            $.datepicker._selectMonthYear(id, this, "Y");
                            return false;
                        }
                    };
                    $(this).on(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
                });
            },
            _generateHTML: function(inst) {
                var maxDraw, prevText, prev, nextText, next, currentText, gotoDate, controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin, monthNames, monthNamesShort, beforeShowDay, showOtherMonths, selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate, cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows, printDate, dRow, tbody, daySettings, otherMonth, unselectable, tempDate = new Date(), today = this._daylightSavingAdjust(new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), isRTL = this._get(inst, "isRTL"), showButtonPanel = this._get(inst, "showButtonPanel"), hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"), navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"), numMonths = this._getNumberOfMonths(inst), showCurrentAtPos = this._get(inst, "showCurrentAtPos"), stepMonths = this._get(inst, "stepMonths"), isMultiMonth = numMonths[0] !== 1 || numMonths[1] !== 1, currentDate = this._daylightSavingAdjust(!inst.currentDay ? new Date(9999, 9, 9) : new Date(inst.currentYear, inst.currentMonth, inst.currentDay)), minDate = this._getMinMaxDate(inst, "min"), maxDate = this._getMinMaxDate(inst, "max"), drawMonth = inst.drawMonth - showCurrentAtPos, drawYear = inst.drawYear;
                if (drawMonth < 0) {
                    drawMonth += 12;
                    drawYear--;
                }
                if (maxDate) {
                    maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(), maxDate.getMonth() - numMonths[0] * numMonths[1] + 1, maxDate.getDate()));
                    maxDraw = minDate && maxDraw < minDate ? minDate : maxDraw;
                    while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
                        drawMonth--;
                        if (drawMonth < 0) {
                            drawMonth = 11;
                            drawYear--;
                        }
                    }
                }
                inst.drawMonth = drawMonth;
                inst.drawYear = drawYear;
                prevText = this._get(inst, "prevText");
                prevText = !navigationAsDateFormat ? prevText : this.formatDate(prevText, this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)), this._getFormatConfig(inst));
                prev = this._canAdjustMonth(inst, -1, drawYear, drawMonth) ? "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" + " title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" : hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>";
                nextText = this._get(inst, "nextText");
                nextText = !navigationAsDateFormat ? nextText : this.formatDate(nextText, this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)), this._getFormatConfig(inst));
                next = this._canAdjustMonth(inst, +1, drawYear, drawMonth) ? "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" + " title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" : hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>";
                currentText = this._get(inst, "currentText");
                gotoDate = this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today;
                currentText = !navigationAsDateFormat ? currentText : this.formatDate(currentText, gotoDate, this._getFormatConfig(inst));
                controls = !inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" + this._get(inst, "closeText") + "</button>" : "";
                buttonPanel = showButtonPanel ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") + (this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" + ">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";
                firstDay = parseInt(this._get(inst, "firstDay"), 10);
                firstDay = isNaN(firstDay) ? 0 : firstDay;
                showWeek = this._get(inst, "showWeek");
                dayNames = this._get(inst, "dayNames");
                dayNamesMin = this._get(inst, "dayNamesMin");
                monthNames = this._get(inst, "monthNames");
                monthNamesShort = this._get(inst, "monthNamesShort");
                beforeShowDay = this._get(inst, "beforeShowDay");
                showOtherMonths = this._get(inst, "showOtherMonths");
                selectOtherMonths = this._get(inst, "selectOtherMonths");
                defaultDate = this._getDefaultDate(inst);
                html = "";
                for (row = 0; row < numMonths[0]; row++) {
                    group = "";
                    this.maxRows = 4;
                    for (col = 0; col < numMonths[1]; col++) {
                        selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
                        cornerClass = " ui-corner-all";
                        calender = "";
                        if (isMultiMonth) {
                            calender += "<div class='ui-datepicker-group";
                            if (numMonths[1] > 1) {
                                switch (col) {
                                  case 0:
                                    calender += " ui-datepicker-group-first";
                                    cornerClass = " ui-corner-" + (isRTL ? "right" : "left");
                                    break;

                                  case numMonths[1] - 1:
                                    calender += " ui-datepicker-group-last";
                                    cornerClass = " ui-corner-" + (isRTL ? "left" : "right");
                                    break;

                                  default:
                                    calender += " ui-datepicker-group-middle";
                                    cornerClass = "";
                                    break;
                                }
                            }
                            calender += "'>";
                        }
                        calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" + (/all|left/.test(cornerClass) && row === 0 ? isRTL ? next : prev : "") + (/all|right/.test(cornerClass) && row === 0 ? isRTL ? prev : next : "") + this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate, row > 0 || col > 0, monthNames, monthNamesShort) + "</div><table class='ui-datepicker-calendar'><thead>" + "<tr>";
                        thead = showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "";
                        for (dow = 0; dow < 7; dow++) {
                            day = (dow + firstDay) % 7;
                            thead += "<th scope='col'" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" + "<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
                        }
                        calender += thead + "</tr></thead><tbody>";
                        daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
                        if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
                            inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
                        }
                        leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
                        curRows = Math.ceil((leadDays + daysInMonth) / 7);
                        numRows = isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows;
                        this.maxRows = numRows;
                        printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
                        for (dRow = 0; dRow < numRows; dRow++) {
                            calender += "<tr>";
                            tbody = !showWeek ? "" : "<td class='ui-datepicker-week-col'>" + this._get(inst, "calculateWeek")(printDate) + "</td>";
                            for (dow = 0; dow < 7; dow++) {
                                daySettings = beforeShowDay ? beforeShowDay.apply(inst.input ? inst.input[0] : null, [ printDate ]) : [ true, "" ];
                                otherMonth = printDate.getMonth() !== drawMonth;
                                unselectable = otherMonth && !selectOtherMonths || !daySettings[0] || minDate && printDate < minDate || maxDate && printDate > maxDate;
                                tbody += "<td class='" + ((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + (otherMonth ? " ui-datepicker-other-month" : "") + (printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent || defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ? " " + this._dayOverClass : "") + (unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "") + (otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + (printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + (printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + ((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + (unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + (otherMonth && !showOtherMonths ? "&#xa0;" : unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" + (printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") + (printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + (otherMonth ? " ui-priority-secondary" : "") + "' href='#'>" + printDate.getDate() + "</a>") + "</td>";
                                printDate.setDate(printDate.getDate() + 1);
                                printDate = this._daylightSavingAdjust(printDate);
                            }
                            calender += tbody + "</tr>";
                        }
                        drawMonth++;
                        if (drawMonth > 11) {
                            drawMonth = 0;
                            drawYear++;
                        }
                        calender += "</tbody></table>" + (isMultiMonth ? "</div>" + (numMonths[0] > 0 && col === numMonths[1] - 1 ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
                        group += calender;
                    }
                    html += group;
                }
                html += buttonPanel;
                inst._keyEvent = false;
                return html;
            },
            _generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate, secondary, monthNames, monthNamesShort) {
                var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear, changeMonth = this._get(inst, "changeMonth"), changeYear = this._get(inst, "changeYear"), showMonthAfterYear = this._get(inst, "showMonthAfterYear"), html = "<div class='ui-datepicker-title'>", monthHtml = "";
                if (secondary || !changeMonth) {
                    monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
                } else {
                    inMinYear = minDate && minDate.getFullYear() === drawYear;
                    inMaxYear = maxDate && maxDate.getFullYear() === drawYear;
                    monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
                    for (month = 0; month < 12; month++) {
                        if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
                            monthHtml += "<option value='" + month + "'" + (month === drawMonth ? " selected='selected'" : "") + ">" + monthNamesShort[month] + "</option>";
                        }
                    }
                    monthHtml += "</select>";
                }
                if (!showMonthAfterYear) {
                    html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
                }
                if (!inst.yearshtml) {
                    inst.yearshtml = "";
                    if (secondary || !changeYear) {
                        html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
                    } else {
                        years = this._get(inst, "yearRange").split(":");
                        thisYear = new Date().getFullYear();
                        determineYear = function(value) {
                            var year = value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) : value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) : parseInt(value, 10);
                            return isNaN(year) ? thisYear : year;
                        };
                        year = determineYear(years[0]);
                        endYear = Math.max(year, determineYear(years[1] || ""));
                        year = minDate ? Math.max(year, minDate.getFullYear()) : year;
                        endYear = maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear;
                        inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
                        for (;year <= endYear; year++) {
                            inst.yearshtml += "<option value='" + year + "'" + (year === drawYear ? " selected='selected'" : "") + ">" + year + "</option>";
                        }
                        inst.yearshtml += "</select>";
                        html += inst.yearshtml;
                        inst.yearshtml = null;
                    }
                }
                html += this._get(inst, "yearSuffix");
                if (showMonthAfterYear) {
                    html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
                }
                html += "</div>";
                return html;
            },
            _adjustInstDate: function(inst, offset, period) {
                var year = inst.selectedYear + (period === "Y" ? offset : 0), month = inst.selectedMonth + (period === "M" ? offset : 0), day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0), date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));
                inst.selectedDay = date.getDate();
                inst.drawMonth = inst.selectedMonth = date.getMonth();
                inst.drawYear = inst.selectedYear = date.getFullYear();
                if (period === "M" || period === "Y") {
                    this._notifyChange(inst);
                }
            },
            _restrictMinMax: function(inst, date) {
                var minDate = this._getMinMaxDate(inst, "min"), maxDate = this._getMinMaxDate(inst, "max"), newDate = minDate && date < minDate ? minDate : date;
                return maxDate && newDate > maxDate ? maxDate : newDate;
            },
            _notifyChange: function(inst) {
                var onChange = this._get(inst, "onChangeMonthYear");
                if (onChange) {
                    onChange.apply(inst.input ? inst.input[0] : null, [ inst.selectedYear, inst.selectedMonth + 1, inst ]);
                }
            },
            _getNumberOfMonths: function(inst) {
                var numMonths = this._get(inst, "numberOfMonths");
                return numMonths == null ? [ 1, 1 ] : typeof numMonths === "number" ? [ 1, numMonths ] : numMonths;
            },
            _getMinMaxDate: function(inst, minMax) {
                return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
            },
            _getDaysInMonth: function(year, month) {
                return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
            },
            _getFirstDayOfMonth: function(year, month) {
                return new Date(year, month, 1).getDay();
            },
            _canAdjustMonth: function(inst, offset, curYear, curMonth) {
                var numMonths = this._getNumberOfMonths(inst), date = this._daylightSavingAdjust(new Date(curYear, curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
                if (offset < 0) {
                    date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
                }
                return this._isInRange(inst, date);
            },
            _isInRange: function(inst, date) {
                var yearSplit, currentYear, minDate = this._getMinMaxDate(inst, "min"), maxDate = this._getMinMaxDate(inst, "max"), minYear = null, maxYear = null, years = this._get(inst, "yearRange");
                if (years) {
                    yearSplit = years.split(":");
                    currentYear = new Date().getFullYear();
                    minYear = parseInt(yearSplit[0], 10);
                    maxYear = parseInt(yearSplit[1], 10);
                    if (yearSplit[0].match(/[+\-].*/)) {
                        minYear += currentYear;
                    }
                    if (yearSplit[1].match(/[+\-].*/)) {
                        maxYear += currentYear;
                    }
                }
                return (!minDate || date.getTime() >= minDate.getTime()) && (!maxDate || date.getTime() <= maxDate.getTime()) && (!minYear || date.getFullYear() >= minYear) && (!maxYear || date.getFullYear() <= maxYear);
            },
            _getFormatConfig: function(inst) {
                var shortYearCutoff = this._get(inst, "shortYearCutoff");
                shortYearCutoff = typeof shortYearCutoff !== "string" ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10);
                return {
                    shortYearCutoff: shortYearCutoff,
                    dayNamesShort: this._get(inst, "dayNamesShort"),
                    dayNames: this._get(inst, "dayNames"),
                    monthNamesShort: this._get(inst, "monthNamesShort"),
                    monthNames: this._get(inst, "monthNames")
                };
            },
            _formatDate: function(inst, day, month, year) {
                if (!day) {
                    inst.currentDay = inst.selectedDay;
                    inst.currentMonth = inst.selectedMonth;
                    inst.currentYear = inst.selectedYear;
                }
                var date = day ? typeof day === "object" ? day : this._daylightSavingAdjust(new Date(year, month, day)) : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
                return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
            }
        });
        function datepicker_bindHover(dpDiv) {
            var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
            return dpDiv.on("mouseout", selector, function() {
                $(this).removeClass("ui-state-hover");
                if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                    $(this).removeClass("ui-datepicker-prev-hover");
                }
                if (this.className.indexOf("ui-datepicker-next") !== -1) {
                    $(this).removeClass("ui-datepicker-next-hover");
                }
            }).on("mouseover", selector, datepicker_handleMouseover);
        }
        function datepicker_handleMouseover() {
            if (!$.datepicker._isDisabledDatepicker(datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[0] : datepicker_instActive.input[0])) {
                $(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
                $(this).addClass("ui-state-hover");
                if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                    $(this).addClass("ui-datepicker-prev-hover");
                }
                if (this.className.indexOf("ui-datepicker-next") !== -1) {
                    $(this).addClass("ui-datepicker-next-hover");
                }
            }
        }
        function datepicker_extendRemove(target, props) {
            $.extend(target, props);
            for (var name in props) {
                if (props[name] == null) {
                    target[name] = props[name];
                }
            }
            return target;
        }
        $.fn.datepicker = function(options) {
            if (!this.length) {
                return this;
            }
            if (!$.datepicker.initialized) {
                $(document).on("mousedown", $.datepicker._checkExternalClick);
                $.datepicker.initialized = true;
            }
            if ($("#" + $.datepicker._mainDivId).length === 0) {
                $("body").append($.datepicker.dpDiv);
            }
            var otherArgs = Array.prototype.slice.call(arguments, 1);
            if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
                return $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [ this[0] ].concat(otherArgs));
            }
            if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
                return $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [ this[0] ].concat(otherArgs));
            }
            return this.each(function() {
                typeof options === "string" ? $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [ this ].concat(otherArgs)) : $.datepicker._attachDatepicker(this, options);
            });
        };
        $.datepicker = new Datepicker();
        $.datepicker.initialized = false;
        $.datepicker.uuid = new Date().getTime();
        $.datepicker.version = "@VERSION";
        return $.datepicker;
    });
    define("skylark-jqueryui/widgets/mouse", [ "skylark-jquery", "../ie", "../version", "../widget" ], function($) {
        var mouseHandled = false;
        $(document).on("mouseup", function() {
            mouseHandled = false;
        });
        return $.widget("ui.mouse", {
            version: "@VERSION",
            options: {
                cancel: "input, textarea, button, select, option",
                distance: 1,
                delay: 0
            },
            _mouseInit: function() {
                var that = this;
                this.element.on("mousedown." + this.widgetName, function(event) {
                    return that._mouseDown(event);
                }).on("click." + this.widgetName, function(event) {
                    if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
                        $.removeData(event.target, that.widgetName + ".preventClickEvent");
                        event.stopImmediatePropagation();
                        return false;
                    }
                });
                this.started = false;
            },
            _mouseDestroy: function() {
                this.element.off("." + this.widgetName);
                if (this._mouseMoveDelegate) {
                    this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate);
                }
            },
            _mouseDown: function(event) {
                if (mouseHandled) {
                    return;
                }
                this._mouseMoved = false;
                this._mouseStarted && this._mouseUp(event);
                this._mouseDownEvent = event;
                var that = this, btnIsLeft = event.which === 1, elIsCancel = typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false;
                if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
                    return true;
                }
                this.mouseDelayMet = !this.options.delay;
                if (!this.mouseDelayMet) {
                    this._mouseDelayTimer = setTimeout(function() {
                        that.mouseDelayMet = true;
                    }, this.options.delay);
                }
                if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                    this._mouseStarted = this._mouseStart(event) !== false;
                    if (!this._mouseStarted) {
                        event.preventDefault();
                        return true;
                    }
                }
                if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
                    $.removeData(event.target, this.widgetName + ".preventClickEvent");
                }
                this._mouseMoveDelegate = function(event) {
                    return that._mouseMove(event);
                };
                this._mouseUpDelegate = function(event) {
                    return that._mouseUp(event);
                };
                this.document.on("mousemove." + this.widgetName, this._mouseMoveDelegate).on("mouseup." + this.widgetName, this._mouseUpDelegate);
                event.preventDefault();
                mouseHandled = true;
                return true;
            },
            _mouseMove: function(event) {
                if (this._mouseMoved) {
                    if ($.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button) {
                        return this._mouseUp(event);
                    } else if (!event.which) {
                        if (event.originalEvent.altKey || event.originalEvent.ctrlKey || event.originalEvent.metaKey || event.originalEvent.shiftKey) {
                            this.ignoreMissingWhich = true;
                        } else if (!this.ignoreMissingWhich) {
                            return this._mouseUp(event);
                        }
                    }
                }
                if (event.which || event.button) {
                    this._mouseMoved = true;
                }
                if (this._mouseStarted) {
                    this._mouseDrag(event);
                    return event.preventDefault();
                }
                if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                    this._mouseStarted = this._mouseStart(this._mouseDownEvent, event) !== false;
                    this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event);
                }
                return !this._mouseStarted;
            },
            _mouseUp: function(event) {
                this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate);
                if (this._mouseStarted) {
                    this._mouseStarted = false;
                    if (event.target === this._mouseDownEvent.target) {
                        $.data(event.target, this.widgetName + ".preventClickEvent", true);
                    }
                    this._mouseStop(event);
                }
                if (this._mouseDelayTimer) {
                    clearTimeout(this._mouseDelayTimer);
                    delete this._mouseDelayTimer;
                }
                this.ignoreMissingWhich = false;
                mouseHandled = false;
                event.preventDefault();
            },
            _mouseDistanceMet: function(event) {
                return Math.max(Math.abs(this._mouseDownEvent.pageX - event.pageX), Math.abs(this._mouseDownEvent.pageY - event.pageY)) >= this.options.distance;
            },
            _mouseDelayMet: function() {
                return this.mouseDelayMet;
            },
            _mouseStart: function() {},
            _mouseDrag: function() {},
            _mouseStop: function() {},
            _mouseCapture: function() {
                return true;
            }
        });
    });
    define("skylark-jqueryui/widgets/draggable", [ "skylark-jquery", "./mouse", "../data", "../plugin", "../safe-active-element", "../safe-blur", "../scroll-parent", "../version", "../widget" ], function($) {
        $.widget("ui.draggable", $.ui.mouse, {
            version: "@VERSION",
            widgetEventPrefix: "drag",
            options: {
                addClasses: true,
                appendTo: "parent",
                axis: false,
                connectToSortable: false,
                containment: false,
                cursor: "auto",
                cursorAt: false,
                grid: false,
                handle: false,
                helper: "original",
                iframeFix: false,
                opacity: false,
                refreshPositions: false,
                revert: false,
                revertDuration: 500,
                scope: "default",
                scroll: true,
                scrollSensitivity: 20,
                scrollSpeed: 20,
                snap: false,
                snapMode: "both",
                snapTolerance: 20,
                stack: false,
                zIndex: false,
                drag: null,
                start: null,
                stop: null
            },
            _create: function() {
                if (this.options.helper === "original") {
                    this._setPositionRelative();
                }
                if (this.options.addClasses) {
                    this._addClass("ui-draggable");
                }
                this._setHandleClassName();
                this._mouseInit();
            },
            _setOption: function(key, value) {
                this._super(key, value);
                if (key === "handle") {
                    this._removeHandleClassName();
                    this._setHandleClassName();
                }
            },
            _destroy: function() {
                if ((this.helper || this.element).is(".ui-draggable-dragging")) {
                    this.destroyOnClear = true;
                    return;
                }
                this._removeHandleClassName();
                this._mouseDestroy();
            },
            _mouseCapture: function(event) {
                var o = this.options;
                if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
                    return false;
                }
                this.handle = this._getHandle(event);
                if (!this.handle) {
                    return false;
                }
                this._blurActiveElement(event);
                this._blockFrames(o.iframeFix === true ? "iframe" : o.iframeFix);
                return true;
            },
            _blockFrames: function(selector) {
                this.iframeBlocks = this.document.find(selector).map(function() {
                    var iframe = $(this);
                    return $("<div>").css("position", "absolute").appendTo(iframe.parent()).outerWidth(iframe.outerWidth()).outerHeight(iframe.outerHeight()).offset(iframe.offset())[0];
                });
            },
            _unblockFrames: function() {
                if (this.iframeBlocks) {
                    this.iframeBlocks.remove();
                    delete this.iframeBlocks;
                }
            },
            _blurActiveElement: function(event) {
                var activeElement = $.ui.safeActiveElement(this.document[0]), target = $(event.target);
                if (target.closest(activeElement).length) {
                    return;
                }
                $.ui.safeBlur(activeElement);
            },
            _mouseStart: function(event) {
                var o = this.options;
                this.helper = this._createHelper(event);
                this._addClass(this.helper, "ui-draggable-dragging");
                this._cacheHelperProportions();
                if ($.ui.ddmanager) {
                    $.ui.ddmanager.current = this;
                }
                this._cacheMargins();
                this.cssPosition = this.helper.css("position");
                this.scrollParent = this.helper.scrollParent(true);
                this.offsetParent = this.helper.offsetParent();
                this.hasFixedAncestor = this.helper.parents().filter(function() {
                    return $(this).css("position") === "fixed";
                }).length > 0;
                this.positionAbs = this.element.offset();
                this._refreshOffsets(event);
                this.originalPosition = this.position = this._generatePosition(event, false);
                this.originalPageX = event.pageX;
                this.originalPageY = event.pageY;
                o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt);
                this._setContainment();
                if (this._trigger("start", event) === false) {
                    this._clear();
                    return false;
                }
                this._cacheHelperProportions();
                if ($.ui.ddmanager && !o.dropBehaviour) {
                    $.ui.ddmanager.prepareOffsets(this, event);
                }
                this._mouseDrag(event, true);
                if ($.ui.ddmanager) {
                    $.ui.ddmanager.dragStart(this, event);
                }
                return true;
            },
            _refreshOffsets: function(event) {
                this.offset = {
                    top: this.positionAbs.top - this.margins.top,
                    left: this.positionAbs.left - this.margins.left,
                    scroll: false,
                    parent: this._getParentOffset(),
                    relative: this._getRelativeOffset()
                };
                this.offset.click = {
                    left: event.pageX - this.offset.left,
                    top: event.pageY - this.offset.top
                };
            },
            _mouseDrag: function(event, noPropagation) {
                if (this.hasFixedAncestor) {
                    this.offset.parent = this._getParentOffset();
                }
                this.position = this._generatePosition(event, true);
                this.positionAbs = this._convertPositionTo("absolute");
                if (!noPropagation) {
                    var ui = this._uiHash();
                    if (this._trigger("drag", event, ui) === false) {
                        this._mouseUp(new $.Event("mouseup", event));
                        return false;
                    }
                    this.position = ui.position;
                }
                this.helper[0].style.left = this.position.left + "px";
                this.helper[0].style.top = this.position.top + "px";
                if ($.ui.ddmanager) {
                    $.ui.ddmanager.drag(this, event);
                }
                return false;
            },
            _mouseStop: function(event) {
                var that = this, dropped = false;
                if ($.ui.ddmanager && !this.options.dropBehaviour) {
                    dropped = $.ui.ddmanager.drop(this, event);
                }
                if (this.dropped) {
                    dropped = this.dropped;
                    this.dropped = false;
                }
                if (this.options.revert === "invalid" && !dropped || this.options.revert === "valid" && dropped || this.options.revert === true || $.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped)) {
                    $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
                        if (that._trigger("stop", event) !== false) {
                            that._clear();
                        }
                    });
                } else {
                    if (this._trigger("stop", event) !== false) {
                        this._clear();
                    }
                }
                return false;
            },
            _mouseUp: function(event) {
                this._unblockFrames();
                if ($.ui.ddmanager) {
                    $.ui.ddmanager.dragStop(this, event);
                }
                if (this.handleElement.is(event.target)) {
                    this.element.trigger("focus");
                }
                return $.ui.mouse.prototype._mouseUp.call(this, event);
            },
            cancel: function() {
                if (this.helper.is(".ui-draggable-dragging")) {
                    this._mouseUp(new $.Event("mouseup", {
                        target: this.element[0]
                    }));
                } else {
                    this._clear();
                }
                return this;
            },
            _getHandle: function(event) {
                return this.options.handle ? !!$(event.target).closest(this.element.find(this.options.handle)).length : true;
            },
            _setHandleClassName: function() {
                this.handleElement = this.options.handle ? this.element.find(this.options.handle) : this.element;
                this._addClass(this.handleElement, "ui-draggable-handle");
            },
            _removeHandleClassName: function() {
                this._removeClass(this.handleElement, "ui-draggable-handle");
            },
            _createHelper: function(event) {
                var o = this.options, helperIsFunction = $.isFunction(o.helper), helper = helperIsFunction ? $(o.helper.apply(this.element[0], [ event ])) : o.helper === "clone" ? this.element.clone().removeAttr("id") : this.element;
                if (!helper.parents("body").length) {
                    helper.appendTo(o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo);
                }
                if (helperIsFunction && helper[0] === this.element[0]) {
                    this._setPositionRelative();
                }
                if (helper[0] !== this.element[0] && !/(fixed|absolute)/.test(helper.css("position"))) {
                    helper.css("position", "absolute");
                }
                return helper;
            },
            _setPositionRelative: function() {
                if (!/^(?:r|a|f)/.test(this.element.css("position"))) {
                    this.element[0].style.position = "relative";
                }
            },
            _adjustOffsetFromHelper: function(obj) {
                if (typeof obj === "string") {
                    obj = obj.split(" ");
                }
                if ($.isArray(obj)) {
                    obj = {
                        left: +obj[0],
                        top: +obj[1] || 0
                    };
                }
                if ("left" in obj) {
                    this.offset.click.left = obj.left + this.margins.left;
                }
                if ("right" in obj) {
                    this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
                }
                if ("top" in obj) {
                    this.offset.click.top = obj.top + this.margins.top;
                }
                if ("bottom" in obj) {
                    this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
                }
            },
            _isRootNode: function(element) {
                return /(html|body)/i.test(element.tagName) || element === this.document[0];
            },
            _getParentOffset: function() {
                var po = this.offsetParent.offset(), document = this.document[0];
                if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
                    po.left += this.scrollParent.scrollLeft();
                    po.top += this.scrollParent.scrollTop();
                }
                if (this._isRootNode(this.offsetParent[0])) {
                    po = {
                        top: 0,
                        left: 0
                    };
                }
                return {
                    top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                    left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
                };
            },
            _getRelativeOffset: function() {
                if (this.cssPosition !== "relative") {
                    return {
                        top: 0,
                        left: 0
                    };
                }
                var p = this.element.position(), scrollIsRootNode = this._isRootNode(this.scrollParent[0]);
                return {
                    top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + (!scrollIsRootNode ? this.scrollParent.scrollTop() : 0),
                    left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + (!scrollIsRootNode ? this.scrollParent.scrollLeft() : 0)
                };
            },
            _cacheMargins: function() {
                this.margins = {
                    left: parseInt(this.element.css("marginLeft"), 10) || 0,
                    top: parseInt(this.element.css("marginTop"), 10) || 0,
                    right: parseInt(this.element.css("marginRight"), 10) || 0,
                    bottom: parseInt(this.element.css("marginBottom"), 10) || 0
                };
            },
            _cacheHelperProportions: function() {
                this.helperProportions = {
                    width: this.helper.outerWidth(),
                    height: this.helper.outerHeight()
                };
            },
            _setContainment: function() {
                var isUserScrollable, c, ce, o = this.options, document = this.document[0];
                this.relativeContainer = null;
                if (!o.containment) {
                    this.containment = null;
                    return;
                }
                if (o.containment === "window") {
                    this.containment = [ $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, $(window).scrollLeft() + $(window).width() - this.helperProportions.width - this.margins.left, $(window).scrollTop() + ($(window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top ];
                    return;
                }
                if (o.containment === "document") {
                    this.containment = [ 0, 0, $(document).width() - this.helperProportions.width - this.margins.left, ($(document).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top ];
                    return;
                }
                if (o.containment.constructor === Array) {
                    this.containment = o.containment;
                    return;
                }
                if (o.containment === "parent") {
                    o.containment = this.helper[0].parentNode;
                }
                c = $(o.containment);
                ce = c[0];
                if (!ce) {
                    return;
                }
                isUserScrollable = /(scroll|auto)/.test(c.css("overflow"));
                this.containment = [ (parseInt(c.css("borderLeftWidth"), 10) || 0) + (parseInt(c.css("paddingLeft"), 10) || 0), (parseInt(c.css("borderTopWidth"), 10) || 0) + (parseInt(c.css("paddingTop"), 10) || 0), (isUserScrollable ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt(c.css("borderRightWidth"), 10) || 0) - (parseInt(c.css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (isUserScrollable ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt(c.css("borderBottomWidth"), 10) || 0) - (parseInt(c.css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom ];
                this.relativeContainer = c;
            },
            _convertPositionTo: function(d, pos) {
                if (!pos) {
                    pos = this.position;
                }
                var mod = d === "absolute" ? 1 : -1, scrollIsRootNode = this._isRootNode(this.scrollParent[0]);
                return {
                    top: pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - (this.cssPosition === "fixed" ? -this.offset.scroll.top : scrollIsRootNode ? 0 : this.offset.scroll.top) * mod,
                    left: pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - (this.cssPosition === "fixed" ? -this.offset.scroll.left : scrollIsRootNode ? 0 : this.offset.scroll.left) * mod
                };
            },
            _generatePosition: function(event, constrainPosition) {
                var containment, co, top, left, o = this.options, scrollIsRootNode = this._isRootNode(this.scrollParent[0]), pageX = event.pageX, pageY = event.pageY;
                if (!scrollIsRootNode || !this.offset.scroll) {
                    this.offset.scroll = {
                        top: this.scrollParent.scrollTop(),
                        left: this.scrollParent.scrollLeft()
                    };
                }
                if (constrainPosition) {
                    if (this.containment) {
                        if (this.relativeContainer) {
                            co = this.relativeContainer.offset();
                            containment = [ this.containment[0] + co.left, this.containment[1] + co.top, this.containment[2] + co.left, this.containment[3] + co.top ];
                        } else {
                            containment = this.containment;
                        }
                        if (event.pageX - this.offset.click.left < containment[0]) {
                            pageX = containment[0] + this.offset.click.left;
                        }
                        if (event.pageY - this.offset.click.top < containment[1]) {
                            pageY = containment[1] + this.offset.click.top;
                        }
                        if (event.pageX - this.offset.click.left > containment[2]) {
                            pageX = containment[2] + this.offset.click.left;
                        }
                        if (event.pageY - this.offset.click.top > containment[3]) {
                            pageY = containment[3] + this.offset.click.top;
                        }
                    }
                    if (o.grid) {
                        top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
                        pageY = containment ? top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3] ? top : top - this.offset.click.top >= containment[1] ? top - o.grid[1] : top + o.grid[1] : top;
                        left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
                        pageX = containment ? left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2] ? left : left - this.offset.click.left >= containment[0] ? left - o.grid[0] : left + o.grid[0] : left;
                    }
                    if (o.axis === "y") {
                        pageX = this.originalPageX;
                    }
                    if (o.axis === "x") {
                        pageY = this.originalPageY;
                    }
                }
                return {
                    top: pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + (this.cssPosition === "fixed" ? -this.offset.scroll.top : scrollIsRootNode ? 0 : this.offset.scroll.top),
                    left: pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + (this.cssPosition === "fixed" ? -this.offset.scroll.left : scrollIsRootNode ? 0 : this.offset.scroll.left)
                };
            },
            _clear: function() {
                this._removeClass(this.helper, "ui-draggable-dragging");
                if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
                    this.helper.remove();
                }
                this.helper = null;
                this.cancelHelperRemoval = false;
                if (this.destroyOnClear) {
                    this.destroy();
                }
            },
            _trigger: function(type, event, ui) {
                ui = ui || this._uiHash();
                $.ui.plugin.call(this, type, [ event, ui, this ], true);
                if (/^(drag|start|stop)/.test(type)) {
                    this.positionAbs = this._convertPositionTo("absolute");
                    ui.offset = this.positionAbs;
                }
                return $.Widget.prototype._trigger.call(this, type, event, ui);
            },
            plugins: {},
            _uiHash: function() {
                return {
                    helper: this.helper,
                    position: this.position,
                    originalPosition: this.originalPosition,
                    offset: this.positionAbs
                };
            }
        });
        $.ui.plugin.add("draggable", "connectToSortable", {
            start: function(event, ui, draggable) {
                var uiSortable = $.extend({}, ui, {
                    item: draggable.element
                });
                draggable.sortables = [];
                $(draggable.options.connectToSortable).each(function() {
                    var sortable = $(this).sortable("instance");
                    if (sortable && !sortable.options.disabled) {
                        draggable.sortables.push(sortable);
                        sortable.refreshPositions();
                        sortable._trigger("activate", event, uiSortable);
                    }
                });
            },
            stop: function(event, ui, draggable) {
                var uiSortable = $.extend({}, ui, {
                    item: draggable.element
                });
                draggable.cancelHelperRemoval = false;
                $.each(draggable.sortables, function() {
                    var sortable = this;
                    if (sortable.isOver) {
                        sortable.isOver = 0;
                        draggable.cancelHelperRemoval = true;
                        sortable.cancelHelperRemoval = false;
                        sortable._storedCSS = {
                            position: sortable.placeholder.css("position"),
                            top: sortable.placeholder.css("top"),
                            left: sortable.placeholder.css("left")
                        };
                        sortable._mouseStop(event);
                        sortable.options.helper = sortable.options._helper;
                    } else {
                        sortable.cancelHelperRemoval = true;
                        sortable._trigger("deactivate", event, uiSortable);
                    }
                });
            },
            drag: function(event, ui, draggable) {
                $.each(draggable.sortables, function() {
                    var innermostIntersecting = false, sortable = this;
                    sortable.positionAbs = draggable.positionAbs;
                    sortable.helperProportions = draggable.helperProportions;
                    sortable.offset.click = draggable.offset.click;
                    if (sortable._intersectsWith(sortable.containerCache)) {
                        innermostIntersecting = true;
                        $.each(draggable.sortables, function() {
                            this.positionAbs = draggable.positionAbs;
                            this.helperProportions = draggable.helperProportions;
                            this.offset.click = draggable.offset.click;
                            if (this !== sortable && this._intersectsWith(this.containerCache) && $.contains(sortable.element[0], this.element[0])) {
                                innermostIntersecting = false;
                            }
                            return innermostIntersecting;
                        });
                    }
                    if (innermostIntersecting) {
                        if (!sortable.isOver) {
                            sortable.isOver = 1;
                            draggable._parent = ui.helper.parent();
                            sortable.currentItem = ui.helper.appendTo(sortable.element).data("ui-sortable-item", true);
                            sortable.options._helper = sortable.options.helper;
                            sortable.options.helper = function() {
                                return ui.helper[0];
                            };
                            event.target = sortable.currentItem[0];
                            sortable._mouseCapture(event, true);
                            sortable._mouseStart(event, true, true);
                            sortable.offset.click.top = draggable.offset.click.top;
                            sortable.offset.click.left = draggable.offset.click.left;
                            sortable.offset.parent.left -= draggable.offset.parent.left - sortable.offset.parent.left;
                            sortable.offset.parent.top -= draggable.offset.parent.top - sortable.offset.parent.top;
                            draggable._trigger("toSortable", event);
                            draggable.dropped = sortable.element;
                            $.each(draggable.sortables, function() {
                                this.refreshPositions();
                            });
                            draggable.currentItem = draggable.element;
                            sortable.fromOutside = draggable;
                        }
                        if (sortable.currentItem) {
                            sortable._mouseDrag(event);
                            ui.position = sortable.position;
                        }
                    } else {
                        if (sortable.isOver) {
                            sortable.isOver = 0;
                            sortable.cancelHelperRemoval = true;
                            sortable.options._revert = sortable.options.revert;
                            sortable.options.revert = false;
                            sortable._trigger("out", event, sortable._uiHash(sortable));
                            sortable._mouseStop(event, true);
                            sortable.options.revert = sortable.options._revert;
                            sortable.options.helper = sortable.options._helper;
                            if (sortable.placeholder) {
                                sortable.placeholder.remove();
                            }
                            ui.helper.appendTo(draggable._parent);
                            draggable._refreshOffsets(event);
                            ui.position = draggable._generatePosition(event, true);
                            draggable._trigger("fromSortable", event);
                            draggable.dropped = false;
                            $.each(draggable.sortables, function() {
                                this.refreshPositions();
                            });
                        }
                    }
                });
            }
        });
        $.ui.plugin.add("draggable", "cursor", {
            start: function(event, ui, instance) {
                var t = $("body"), o = instance.options;
                if (t.css("cursor")) {
                    o._cursor = t.css("cursor");
                }
                t.css("cursor", o.cursor);
            },
            stop: function(event, ui, instance) {
                var o = instance.options;
                if (o._cursor) {
                    $("body").css("cursor", o._cursor);
                }
            }
        });
        $.ui.plugin.add("draggable", "opacity", {
            start: function(event, ui, instance) {
                var t = $(ui.helper), o = instance.options;
                if (t.css("opacity")) {
                    o._opacity = t.css("opacity");
                }
                t.css("opacity", o.opacity);
            },
            stop: function(event, ui, instance) {
                var o = instance.options;
                if (o._opacity) {
                    $(ui.helper).css("opacity", o._opacity);
                }
            }
        });
        $.ui.plugin.add("draggable", "scroll", {
            start: function(event, ui, i) {
                if (!i.scrollParentNotHidden) {
                    i.scrollParentNotHidden = i.helper.scrollParent(false);
                }
                if (i.scrollParentNotHidden[0] !== i.document[0] && i.scrollParentNotHidden[0].tagName !== "HTML") {
                    i.overflowOffset = i.scrollParentNotHidden.offset();
                }
            },
            drag: function(event, ui, i) {
                var o = i.options, scrolled = false, scrollParent = i.scrollParentNotHidden[0], document = i.document[0];
                if (scrollParent !== document && scrollParent.tagName !== "HTML") {
                    if (!o.axis || o.axis !== "x") {
                        if (i.overflowOffset.top + scrollParent.offsetHeight - event.pageY < o.scrollSensitivity) {
                            scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
                        } else if (event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
                            scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
                        }
                    }
                    if (!o.axis || o.axis !== "y") {
                        if (i.overflowOffset.left + scrollParent.offsetWidth - event.pageX < o.scrollSensitivity) {
                            scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
                        } else if (event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
                            scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
                        }
                    }
                } else {
                    if (!o.axis || o.axis !== "x") {
                        if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
                            scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
                        } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
                            scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
                        }
                    }
                    if (!o.axis || o.axis !== "y") {
                        if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
                            scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
                        } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
                            scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
                        }
                    }
                }
                if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
                    $.ui.ddmanager.prepareOffsets(i, event);
                }
            }
        });
        $.ui.plugin.add("draggable", "snap", {
            start: function(event, ui, i) {
                var o = i.options;
                i.snapElements = [];
                $(o.snap.constructor !== String ? o.snap.items || ":data(ui-draggable)" : o.snap).each(function() {
                    var $t = $(this), $o = $t.offset();
                    if (this !== i.element[0]) {
                        i.snapElements.push({
                            item: this,
                            width: $t.outerWidth(),
                            height: $t.outerHeight(),
                            top: $o.top,
                            left: $o.left
                        });
                    }
                });
            },
            drag: function(event, ui, inst) {
                var ts, bs, ls, rs, l, r, t, b, i, first, o = inst.options, d = o.snapTolerance, x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width, y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;
                for (i = inst.snapElements.length - 1; i >= 0; i--) {
                    l = inst.snapElements[i].left - inst.margins.left;
                    r = l + inst.snapElements[i].width;
                    t = inst.snapElements[i].top - inst.margins.top;
                    b = t + inst.snapElements[i].height;
                    if (x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains(inst.snapElements[i].item.ownerDocument, inst.snapElements[i].item)) {
                        if (inst.snapElements[i].snapping) {
                            inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), {
                                snapItem: inst.snapElements[i].item
                            }));
                        }
                        inst.snapElements[i].snapping = false;
                        continue;
                    }
                    if (o.snapMode !== "inner") {
                        ts = Math.abs(t - y2) <= d;
                        bs = Math.abs(b - y1) <= d;
                        ls = Math.abs(l - x2) <= d;
                        rs = Math.abs(r - x1) <= d;
                        if (ts) {
                            ui.position.top = inst._convertPositionTo("relative", {
                                top: t - inst.helperProportions.height,
                                left: 0
                            }).top;
                        }
                        if (bs) {
                            ui.position.top = inst._convertPositionTo("relative", {
                                top: b,
                                left: 0
                            }).top;
                        }
                        if (ls) {
                            ui.position.left = inst._convertPositionTo("relative", {
                                top: 0,
                                left: l - inst.helperProportions.width
                            }).left;
                        }
                        if (rs) {
                            ui.position.left = inst._convertPositionTo("relative", {
                                top: 0,
                                left: r
                            }).left;
                        }
                    }
                    first = ts || bs || ls || rs;
                    if (o.snapMode !== "outer") {
                        ts = Math.abs(t - y1) <= d;
                        bs = Math.abs(b - y2) <= d;
                        ls = Math.abs(l - x1) <= d;
                        rs = Math.abs(r - x2) <= d;
                        if (ts) {
                            ui.position.top = inst._convertPositionTo("relative", {
                                top: t,
                                left: 0
                            }).top;
                        }
                        if (bs) {
                            ui.position.top = inst._convertPositionTo("relative", {
                                top: b - inst.helperProportions.height,
                                left: 0
                            }).top;
                        }
                        if (ls) {
                            ui.position.left = inst._convertPositionTo("relative", {
                                top: 0,
                                left: l
                            }).left;
                        }
                        if (rs) {
                            ui.position.left = inst._convertPositionTo("relative", {
                                top: 0,
                                left: r - inst.helperProportions.width
                            }).left;
                        }
                    }
                    if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
                        inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), {
                            snapItem: inst.snapElements[i].item
                        }));
                    }
                    inst.snapElements[i].snapping = ts || bs || ls || rs || first;
                }
            }
        });
        $.ui.plugin.add("draggable", "stack", {
            start: function(event, ui, instance) {
                var min, o = instance.options, group = $.makeArray($(o.stack)).sort(function(a, b) {
                    return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0);
                });
                if (!group.length) {
                    return;
                }
                min = parseInt($(group[0]).css("zIndex"), 10) || 0;
                $(group).each(function(i) {
                    $(this).css("zIndex", min + i);
                });
                this.css("zIndex", min + group.length);
            }
        });
        $.ui.plugin.add("draggable", "zIndex", {
            start: function(event, ui, instance) {
                var t = $(ui.helper), o = instance.options;
                if (t.css("zIndex")) {
                    o._zIndex = t.css("zIndex");
                }
                t.css("zIndex", o.zIndex);
            },
            stop: function(event, ui, instance) {
                var o = instance.options;
                if (o._zIndex) {
                    $(ui.helper).css("zIndex", o._zIndex);
                }
            }
        });
        return $.ui.draggable;
    });
    define("skylark-jqueryui/widgets/droppable", [ "skylark-jquery", "./draggable", "./mouse", "../version", "../widget" ], function($) {
        $.widget("ui.droppable", {
            version: "@VERSION",
            widgetEventPrefix: "drop",
            options: {
                accept: "*",
                addClasses: true,
                greedy: false,
                scope: "default",
                tolerance: "intersect",
                activate: null,
                deactivate: null,
                drop: null,
                out: null,
                over: null
            },
            _create: function() {
                var proportions, o = this.options, accept = o.accept;
                this.isover = false;
                this.isout = true;
                this.accept = $.isFunction(accept) ? accept : function(d) {
                    return d.is(accept);
                };
                this.proportions = function() {
                    if (arguments.length) {
                        proportions = arguments[0];
                    } else {
                        return proportions ? proportions : proportions = {
                            width: this.element[0].offsetWidth,
                            height: this.element[0].offsetHeight
                        };
                    }
                };
                this._addToManager(o.scope);
                o.addClasses && this._addClass("ui-droppable");
            },
            _addToManager: function(scope) {
                $.ui.ddmanager.droppables[scope] = $.ui.ddmanager.droppables[scope] || [];
                $.ui.ddmanager.droppables[scope].push(this);
            },
            _splice: function(drop) {
                var i = 0;
                for (;i < drop.length; i++) {
                    if (drop[i] === this) {
                        drop.splice(i, 1);
                    }
                }
            },
            _destroy: function() {
                var drop = $.ui.ddmanager.droppables[this.options.scope];
                this._splice(drop);
            },
            _setOption: function(key, value) {
                if (key === "accept") {
                    this.accept = $.isFunction(value) ? value : function(d) {
                        return d.is(value);
                    };
                } else if (key === "scope") {
                    var drop = $.ui.ddmanager.droppables[this.options.scope];
                    this._splice(drop);
                    this._addToManager(value);
                }
                this._super(key, value);
            },
            _activate: function(event) {
                var draggable = $.ui.ddmanager.current;
                this._addActiveClass();
                if (draggable) {
                    this._trigger("activate", event, this.ui(draggable));
                }
            },
            _deactivate: function(event) {
                var draggable = $.ui.ddmanager.current;
                this._removeActiveClass();
                if (draggable) {
                    this._trigger("deactivate", event, this.ui(draggable));
                }
            },
            _over: function(event) {
                var draggable = $.ui.ddmanager.current;
                if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                    return;
                }
                if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
                    this._addHoverClass();
                    this._trigger("over", event, this.ui(draggable));
                }
            },
            _out: function(event) {
                var draggable = $.ui.ddmanager.current;
                if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                    return;
                }
                if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
                    this._removeHoverClass();
                    this._trigger("out", event, this.ui(draggable));
                }
            },
            _drop: function(event, custom) {
                var draggable = custom || $.ui.ddmanager.current, childrenIntersection = false;
                if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                    return false;
                }
                this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function() {
                    var inst = $(this).droppable("instance");
                    if (inst.options.greedy && !inst.options.disabled && inst.options.scope === draggable.options.scope && inst.accept.call(inst.element[0], draggable.currentItem || draggable.element) && $.ui.intersect(draggable, $.extend(inst, {
                        offset: inst.element.offset()
                    }), inst.options.tolerance, event)) {
                        childrenIntersection = true;
                        return false;
                    }
                });
                if (childrenIntersection) {
                    return false;
                }
                if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
                    this._removeActiveClass();
                    this._removeHoverClass();
                    this._trigger("drop", event, this.ui(draggable));
                    return this.element;
                }
                return false;
            },
            ui: function(c) {
                return {
                    draggable: c.currentItem || c.element,
                    helper: c.helper,
                    position: c.position,
                    offset: c.positionAbs
                };
            },
            _addHoverClass: function() {
                this._addClass("ui-droppable-hover");
            },
            _removeHoverClass: function() {
                this._removeClass("ui-droppable-hover");
            },
            _addActiveClass: function() {
                this._addClass("ui-droppable-active");
            },
            _removeActiveClass: function() {
                this._removeClass("ui-droppable-active");
            }
        });
        $.ui.intersect = function() {
            function isOverAxis(x, reference, size) {
                return x >= reference && x < reference + size;
            }
            return function(draggable, droppable, toleranceMode, event) {
                if (!droppable.offset) {
                    return false;
                }
                var x1 = (draggable.positionAbs || draggable.position.absolute).left + draggable.margins.left, y1 = (draggable.positionAbs || draggable.position.absolute).top + draggable.margins.top, x2 = x1 + draggable.helperProportions.width, y2 = y1 + draggable.helperProportions.height, l = droppable.offset.left, t = droppable.offset.top, r = l + droppable.proportions().width, b = t + droppable.proportions().height;
                switch (toleranceMode) {
                  case "fit":
                    return l <= x1 && x2 <= r && t <= y1 && y2 <= b;

                  case "intersect":
                    return l < x1 + draggable.helperProportions.width / 2 && x2 - draggable.helperProportions.width / 2 < r && t < y1 + draggable.helperProportions.height / 2 && y2 - draggable.helperProportions.height / 2 < b;

                  case "pointer":
                    return isOverAxis(event.pageY, t, droppable.proportions().height) && isOverAxis(event.pageX, l, droppable.proportions().width);

                  case "touch":
                    return (y1 >= t && y1 <= b || y2 >= t && y2 <= b || y1 < t && y2 > b) && (x1 >= l && x1 <= r || x2 >= l && x2 <= r || x1 < l && x2 > r);

                  default:
                    return false;
                }
            };
        }();
        $.ui.ddmanager = {
            current: null,
            droppables: {
                "default": []
            },
            prepareOffsets: function(t, event) {
                var i, j, m = $.ui.ddmanager.droppables[t.options.scope] || [], type = event ? event.type : null, list = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();
                droppablesLoop: for (i = 0; i < m.length; i++) {
                    if (m[i].options.disabled || t && !m[i].accept.call(m[i].element[0], t.currentItem || t.element)) {
                        continue;
                    }
                    for (j = 0; j < list.length; j++) {
                        if (list[j] === m[i].element[0]) {
                            m[i].proportions().height = 0;
                            continue droppablesLoop;
                        }
                    }
                    m[i].visible = m[i].element.css("display") !== "none";
                    if (!m[i].visible) {
                        continue;
                    }
                    if (type === "mousedown") {
                        m[i]._activate.call(m[i], event);
                    }
                    m[i].offset = m[i].element.offset();
                    m[i].proportions({
                        width: m[i].element[0].offsetWidth,
                        height: m[i].element[0].offsetHeight
                    });
                }
            },
            drop: function(draggable, event) {
                var dropped = false;
                $.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function() {
                    if (!this.options) {
                        return;
                    }
                    if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance, event)) {
                        dropped = this._drop.call(this, event) || dropped;
                    }
                    if (!this.options.disabled && this.visible && this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
                        this.isout = true;
                        this.isover = false;
                        this._deactivate.call(this, event);
                    }
                });
                return dropped;
            },
            dragStart: function(draggable, event) {
                draggable.element.parentsUntil("body").on("scroll.droppable", function() {
                    if (!draggable.options.refreshPositions) {
                        $.ui.ddmanager.prepareOffsets(draggable, event);
                    }
                });
            },
            drag: function(draggable, event) {
                if (draggable.options.refreshPositions) {
                    $.ui.ddmanager.prepareOffsets(draggable, event);
                }
                $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {
                    if (this.options.disabled || this.greedyChild || !this.visible) {
                        return;
                    }
                    var parentInstance, scope, parent, intersects = $.ui.intersect(draggable, this, this.options.tolerance, event), c = !intersects && this.isover ? "isout" : intersects && !this.isover ? "isover" : null;
                    if (!c) {
                        return;
                    }
                    if (this.options.greedy) {
                        scope = this.options.scope;
                        parent = this.element.parents(":data(ui-droppable)").filter(function() {
                            return $(this).droppable("instance").options.scope === scope;
                        });
                        if (parent.length) {
                            parentInstance = $(parent[0]).droppable("instance");
                            parentInstance.greedyChild = c === "isover";
                        }
                    }
                    if (parentInstance && c === "isover") {
                        parentInstance.isover = false;
                        parentInstance.isout = true;
                        parentInstance._out.call(parentInstance, event);
                    }
                    this[c] = true;
                    this[c === "isout" ? "isover" : "isout"] = false;
                    this[c === "isover" ? "_over" : "_out"].call(this, event);
                    if (parentInstance && c === "isout") {
                        parentInstance.isout = false;
                        parentInstance.isover = true;
                        parentInstance._over.call(parentInstance, event);
                    }
                });
            },
            dragStop: function(draggable, event) {
                draggable.element.parentsUntil("body").off("scroll.droppable");
                if (!draggable.options.refreshPositions) {
                    $.ui.ddmanager.prepareOffsets(draggable, event);
                }
            }
        };
        if ($.uiBackCompat !== false) {
            $.widget("ui.droppable", $.ui.droppable, {
                options: {
                    hoverClass: false,
                    activeClass: false
                },
                _addActiveClass: function() {
                    this._super();
                    if (this.options.activeClass) {
                        this.element.addClass(this.options.activeClass);
                    }
                },
                _removeActiveClass: function() {
                    this._super();
                    if (this.options.activeClass) {
                        this.element.removeClass(this.options.activeClass);
                    }
                },
                _addHoverClass: function() {
                    this._super();
                    if (this.options.hoverClass) {
                        this.element.addClass(this.options.hoverClass);
                    }
                },
                _removeHoverClass: function() {
                    this._super();
                    if (this.options.hoverClass) {
                        this.element.removeClass(this.options.hoverClass);
                    }
                }
            });
        }
        return $.ui.droppable;
    });
    define("skylark-jqueryui/widgets/resizable", [ "skylark-jquery", "./mouse", "../disable-selection", "../plugin", "../version", "../widget" ], function($) {
        $.widget("ui.resizable", $.ui.mouse, {
            version: "@VERSION",
            widgetEventPrefix: "resize",
            options: {
                alsoResize: false,
                animate: false,
                animateDuration: "slow",
                animateEasing: "swing",
                aspectRatio: false,
                autoHide: false,
                classes: {
                    "ui-resizable-se": "ui-icon ui-icon-gripsmall-diagonal-se"
                },
                containment: false,
                ghost: false,
                grid: false,
                handles: "e,s,se",
                helper: false,
                maxHeight: null,
                maxWidth: null,
                minHeight: 10,
                minWidth: 10,
                zIndex: 90,
                resize: null,
                start: null,
                stop: null
            },
            _num: function(value) {
                return parseFloat(value) || 0;
            },
            _isNumber: function(value) {
                return !isNaN(parseFloat(value));
            },
            _hasScroll: function(el, a) {
                if ($(el).css("overflow") === "hidden") {
                    return false;
                }
                var scroll = a && a === "left" ? "scrollLeft" : "scrollTop", has = false;
                if (el[scroll] > 0) {
                    return true;
                }
                el[scroll] = 1;
                has = el[scroll] > 0;
                el[scroll] = 0;
                return has;
            },
            _create: function() {
                var margins, o = this.options, that = this;
                this._addClass("ui-resizable");
                $.extend(this, {
                    _aspectRatio: !!o.aspectRatio,
                    aspectRatio: o.aspectRatio,
                    originalElement: this.element,
                    _proportionallyResizeElements: [],
                    _helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
                });
                if (this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)) {
                    this.element.wrap($("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
                        position: this.element.css("position"),
                        width: this.element.outerWidth(),
                        height: this.element.outerHeight(),
                        top: this.element.css("top"),
                        left: this.element.css("left")
                    }));
                    this.element = this.element.parent().data("ui-resizable", this.element.resizable("instance"));
                    this.elementIsWrapper = true;
                    margins = {
                        marginTop: this.originalElement.css("marginTop"),
                        marginRight: this.originalElement.css("marginRight"),
                        marginBottom: this.originalElement.css("marginBottom"),
                        marginLeft: this.originalElement.css("marginLeft")
                    };
                    this.element.css(margins);
                    this.originalElement.css("margin", 0);
                    this.originalResizeStyle = this.originalElement.css("resize");
                    this.originalElement.css("resize", "none");
                    this._proportionallyResizeElements.push(this.originalElement.css({
                        position: "static",
                        zoom: 1,
                        display: "block"
                    }));
                    this.originalElement.css(margins);
                    this._proportionallyResize();
                }
                this._setupHandles();
                if (o.autoHide) {
                    $(this.element).on("mouseenter", function() {
                        if (o.disabled) {
                            return;
                        }
                        that._removeClass("ui-resizable-autohide");
                        that._handles.show();
                    }).on("mouseleave", function() {
                        if (o.disabled) {
                            return;
                        }
                        if (!that.resizing) {
                            that._addClass("ui-resizable-autohide");
                            that._handles.hide();
                        }
                    });
                }
                this._mouseInit();
            },
            _destroy: function() {
                this._mouseDestroy();
                this._addedHandles.remove();
                var wrapper, _destroy = function(exp) {
                    $(exp).removeData("resizable").removeData("ui-resizable").off(".resizable");
                };
                if (this.elementIsWrapper) {
                    _destroy(this.element);
                    wrapper = this.element;
                    this.originalElement.css({
                        position: wrapper.css("position"),
                        width: wrapper.outerWidth(),
                        height: wrapper.outerHeight(),
                        top: wrapper.css("top"),
                        left: wrapper.css("left")
                    }).insertAfter(wrapper);
                    wrapper.remove();
                }
                this.originalElement.css("resize", this.originalResizeStyle);
                _destroy(this.originalElement);
                return this;
            },
            _setOption: function(key, value) {
                this._super(key, value);
                switch (key) {
                  case "handles":
                    this._removeHandles();
                    this._setupHandles();
                    break;

                  case "aspectRatio":
                    this._aspectRatio = !!value;
                    break;

                  default:
                    break;
                }
            },
            _setupHandles: function() {
                var o = this.options, handle, i, n, hname, axis, that = this;
                this.handles = o.handles || (!$(".ui-resizable-handle", this.element).length ? "e,s,se" : {
                    n: ".ui-resizable-n",
                    e: ".ui-resizable-e",
                    s: ".ui-resizable-s",
                    w: ".ui-resizable-w",
                    se: ".ui-resizable-se",
                    sw: ".ui-resizable-sw",
                    ne: ".ui-resizable-ne",
                    nw: ".ui-resizable-nw"
                });
                this._handles = $();
                this._addedHandles = $();
                if (this.handles.constructor === String) {
                    if (this.handles === "all") {
                        this.handles = "n,e,s,w,se,sw,ne,nw";
                    }
                    n = this.handles.split(",");
                    this.handles = {};
                    for (i = 0; i < n.length; i++) {
                        handle = $.trim(n[i]);
                        hname = "ui-resizable-" + handle;
                        axis = $("<div>");
                        this._addClass(axis, "ui-resizable-handle " + hname);
                        axis.css({
                            zIndex: o.zIndex
                        });
                        this.handles[handle] = ".ui-resizable-" + handle;
                        if (!this.element.children(this.handles[handle]).length) {
                            this.element.append(axis);
                            this._addedHandles = this._addedHandles.add(axis);
                        }
                    }
                }
                this._renderAxis = function(target) {
                    var i, axis, padPos, padWrapper;
                    target = target || this.element;
                    for (i in this.handles) {
                        if (this.handles[i].constructor === String) {
                            this.handles[i] = this.element.children(this.handles[i]).first().show();
                        } else if (this.handles[i].jquery || this.handles[i].nodeType) {
                            this.handles[i] = $(this.handles[i]);
                            this._on(this.handles[i], {
                                mousedown: that._mouseDown
                            });
                        }
                        if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)) {
                            axis = $(this.handles[i], this.element);
                            padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();
                            padPos = [ "padding", /ne|nw|n/.test(i) ? "Top" : /se|sw|s/.test(i) ? "Bottom" : /^e$/.test(i) ? "Right" : "Left" ].join("");
                            target.css(padPos, padWrapper);
                            this._proportionallyResize();
                        }
                        this._handles = this._handles.add(this.handles[i]);
                    }
                };
                this._renderAxis(this.element);
                this._handles = this._handles.add(this.element.find(".ui-resizable-handle"));
                this._handles.disableSelection();
                this._handles.on("mouseover", function() {
                    if (!that.resizing) {
                        if (this.className) {
                            axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
                        }
                        that.axis = axis && axis[1] ? axis[1] : "se";
                    }
                });
                if (o.autoHide) {
                    this._handles.hide();
                    this._addClass("ui-resizable-autohide");
                }
            },
            _removeHandles: function() {
                this._addedHandles.remove();
            },
            _mouseCapture: function(event) {
                var i, handle, capture = false;
                for (i in this.handles) {
                    handle = $(this.handles[i])[0];
                    if (handle === event.target || $.contains(handle, event.target)) {
                        capture = true;
                    }
                }
                return !this.options.disabled && capture;
            },
            _mouseStart: function(event) {
                var curleft, curtop, cursor, o = this.options, el = this.element;
                this.resizing = true;
                this._renderProxy();
                curleft = this._num(this.helper.css("left"));
                curtop = this._num(this.helper.css("top"));
                if (o.containment) {
                    curleft += $(o.containment).scrollLeft() || 0;
                    curtop += $(o.containment).scrollTop() || 0;
                }
                this.offset = this.helper.offset();
                this.position = {
                    left: curleft,
                    top: curtop
                };
                this.size = this._helper ? {
                    width: this.helper.width(),
                    height: this.helper.height()
                } : {
                    width: el.width(),
                    height: el.height()
                };
                this.originalSize = this._helper ? {
                    width: el.outerWidth(),
                    height: el.outerHeight()
                } : {
                    width: el.width(),
                    height: el.height()
                };
                this.sizeDiff = {
                    width: el.outerWidth() - el.width(),
                    height: el.outerHeight() - el.height()
                };
                this.originalPosition = {
                    left: curleft,
                    top: curtop
                };
                this.originalMousePosition = {
                    left: event.pageX,
                    top: event.pageY
                };
                this.aspectRatio = typeof o.aspectRatio === "number" ? o.aspectRatio : this.originalSize.width / this.originalSize.height || 1;
                cursor = $(".ui-resizable-" + this.axis).css("cursor");
                $("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);
                this._addClass("ui-resizable-resizing");
                this._propagate("start", event);
                return true;
            },
            _mouseDrag: function(event) {
                var data, props, smp = this.originalMousePosition, a = this.axis, dx = event.pageX - smp.left || 0, dy = event.pageY - smp.top || 0, trigger = this._change[a];
                this._updatePrevProperties();
                if (!trigger) {
                    return false;
                }
                data = trigger.apply(this, [ event, dx, dy ]);
                this._updateVirtualBoundaries(event.shiftKey);
                if (this._aspectRatio || event.shiftKey) {
                    data = this._updateRatio(data, event);
                }
                data = this._respectSize(data, event);
                this._updateCache(data);
                this._propagate("resize", event);
                props = this._applyChanges();
                if (!this._helper && this._proportionallyResizeElements.length) {
                    this._proportionallyResize();
                }
                if (!$.isEmptyObject(props)) {
                    this._updatePrevProperties();
                    this._trigger("resize", event, this.ui());
                    this._applyChanges();
                }
                return false;
            },
            _mouseStop: function(event) {
                this.resizing = false;
                var pr, ista, soffseth, soffsetw, s, left, top, o = this.options, that = this;
                if (this._helper) {
                    pr = this._proportionallyResizeElements;
                    ista = pr.length && /textarea/i.test(pr[0].nodeName);
                    soffseth = ista && this._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height;
                    soffsetw = ista ? 0 : that.sizeDiff.width;
                    s = {
                        width: that.helper.width() - soffsetw,
                        height: that.helper.height() - soffseth
                    };
                    left = parseFloat(that.element.css("left")) + (that.position.left - that.originalPosition.left) || null;
                    top = parseFloat(that.element.css("top")) + (that.position.top - that.originalPosition.top) || null;
                    if (!o.animate) {
                        this.element.css($.extend(s, {
                            top: top,
                            left: left
                        }));
                    }
                    that.helper.height(that.size.height);
                    that.helper.width(that.size.width);
                    if (this._helper && !o.animate) {
                        this._proportionallyResize();
                    }
                }
                $("body").css("cursor", "auto");
                this._removeClass("ui-resizable-resizing");
                this._propagate("stop", event);
                if (this._helper) {
                    this.helper.remove();
                }
                return false;
            },
            _updatePrevProperties: function() {
                this.prevPosition = {
                    top: this.position.top,
                    left: this.position.left
                };
                this.prevSize = {
                    width: this.size.width,
                    height: this.size.height
                };
            },
            _applyChanges: function() {
                var props = {};
                if (this.position.top !== this.prevPosition.top) {
                    props.top = this.position.top + "px";
                }
                if (this.position.left !== this.prevPosition.left) {
                    props.left = this.position.left + "px";
                }
                if (this.size.width !== this.prevSize.width) {
                    props.width = this.size.width + "px";
                }
                if (this.size.height !== this.prevSize.height) {
                    props.height = this.size.height + "px";
                }
                this.helper.css(props);
                return props;
            },
            _updateVirtualBoundaries: function(forceAspectRatio) {
                var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b, o = this.options;
                b = {
                    minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
                    maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,
                    minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
                    maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity
                };
                if (this._aspectRatio || forceAspectRatio) {
                    pMinWidth = b.minHeight * this.aspectRatio;
                    pMinHeight = b.minWidth / this.aspectRatio;
                    pMaxWidth = b.maxHeight * this.aspectRatio;
                    pMaxHeight = b.maxWidth / this.aspectRatio;
                    if (pMinWidth > b.minWidth) {
                        b.minWidth = pMinWidth;
                    }
                    if (pMinHeight > b.minHeight) {
                        b.minHeight = pMinHeight;
                    }
                    if (pMaxWidth < b.maxWidth) {
                        b.maxWidth = pMaxWidth;
                    }
                    if (pMaxHeight < b.maxHeight) {
                        b.maxHeight = pMaxHeight;
                    }
                }
                this._vBoundaries = b;
            },
            _updateCache: function(data) {
                this.offset = this.helper.offset();
                if (this._isNumber(data.left)) {
                    this.position.left = data.left;
                }
                if (this._isNumber(data.top)) {
                    this.position.top = data.top;
                }
                if (this._isNumber(data.height)) {
                    this.size.height = data.height;
                }
                if (this._isNumber(data.width)) {
                    this.size.width = data.width;
                }
            },
            _updateRatio: function(data) {
                var cpos = this.position, csize = this.size, a = this.axis;
                if (this._isNumber(data.height)) {
                    data.width = data.height * this.aspectRatio;
                } else if (this._isNumber(data.width)) {
                    data.height = data.width / this.aspectRatio;
                }
                if (a === "sw") {
                    data.left = cpos.left + (csize.width - data.width);
                    data.top = null;
                }
                if (a === "nw") {
                    data.top = cpos.top + (csize.height - data.height);
                    data.left = cpos.left + (csize.width - data.width);
                }
                return data;
            },
            _respectSize: function(data) {
                var o = this._vBoundaries, a = this.axis, ismaxw = this._isNumber(data.width) && o.maxWidth && o.maxWidth < data.width, ismaxh = this._isNumber(data.height) && o.maxHeight && o.maxHeight < data.height, isminw = this._isNumber(data.width) && o.minWidth && o.minWidth > data.width, isminh = this._isNumber(data.height) && o.minHeight && o.minHeight > data.height, dw = this.originalPosition.left + this.originalSize.width, dh = this.originalPosition.top + this.originalSize.height, cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
                if (isminw) {
                    data.width = o.minWidth;
                }
                if (isminh) {
                    data.height = o.minHeight;
                }
                if (ismaxw) {
                    data.width = o.maxWidth;
                }
                if (ismaxh) {
                    data.height = o.maxHeight;
                }
                if (isminw && cw) {
                    data.left = dw - o.minWidth;
                }
                if (ismaxw && cw) {
                    data.left = dw - o.maxWidth;
                }
                if (isminh && ch) {
                    data.top = dh - o.minHeight;
                }
                if (ismaxh && ch) {
                    data.top = dh - o.maxHeight;
                }
                if (!data.width && !data.height && !data.left && data.top) {
                    data.top = null;
                } else if (!data.width && !data.height && !data.top && data.left) {
                    data.left = null;
                }
                return data;
            },
            _getPaddingPlusBorderDimensions: function(element) {
                var i = 0, widths = [], borders = [ element.css("borderTopWidth"), element.css("borderRightWidth"), element.css("borderBottomWidth"), element.css("borderLeftWidth") ], paddings = [ element.css("paddingTop"), element.css("paddingRight"), element.css("paddingBottom"), element.css("paddingLeft") ];
                for (;i < 4; i++) {
                    widths[i] = parseFloat(borders[i]) || 0;
                    widths[i] += parseFloat(paddings[i]) || 0;
                }
                return {
                    height: widths[0] + widths[2],
                    width: widths[1] + widths[3]
                };
            },
            _proportionallyResize: function() {
                if (!this._proportionallyResizeElements.length) {
                    return;
                }
                var prel, i = 0, element = this.helper || this.element;
                for (;i < this._proportionallyResizeElements.length; i++) {
                    prel = this._proportionallyResizeElements[i];
                    if (!this.outerDimensions) {
                        this.outerDimensions = this._getPaddingPlusBorderDimensions(prel);
                    }
                    prel.css({
                        height: element.height() - this.outerDimensions.height || 0,
                        width: element.width() - this.outerDimensions.width || 0
                    });
                }
            },
            _renderProxy: function() {
                var el = this.element, o = this.options;
                this.elementOffset = el.offset();
                if (this._helper) {
                    this.helper = this.helper || $("<div style='overflow:hidden;'></div>");
                    this._addClass(this.helper, this._helper);
                    this.helper.css({
                        width: this.element.outerWidth(),
                        height: this.element.outerHeight(),
                        position: "absolute",
                        left: this.elementOffset.left + "px",
                        top: this.elementOffset.top + "px",
                        zIndex: ++o.zIndex
                    });
                    this.helper.appendTo("body").disableSelection();
                } else {
                    this.helper = this.element;
                }
            },
            _change: {
                e: function(event, dx) {
                    return {
                        width: this.originalSize.width + dx
                    };
                },
                w: function(event, dx) {
                    var cs = this.originalSize, sp = this.originalPosition;
                    return {
                        left: sp.left + dx,
                        width: cs.width - dx
                    };
                },
                n: function(event, dx, dy) {
                    var cs = this.originalSize, sp = this.originalPosition;
                    return {
                        top: sp.top + dy,
                        height: cs.height - dy
                    };
                },
                s: function(event, dx, dy) {
                    return {
                        height: this.originalSize.height + dy
                    };
                },
                se: function(event, dx, dy) {
                    return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [ event, dx, dy ]));
                },
                sw: function(event, dx, dy) {
                    return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [ event, dx, dy ]));
                },
                ne: function(event, dx, dy) {
                    return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [ event, dx, dy ]));
                },
                nw: function(event, dx, dy) {
                    return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [ event, dx, dy ]));
                }
            },
            _propagate: function(n, event) {
                $.ui.plugin.call(this, n, [ event, this.ui() ]);
                n !== "resize" && this._trigger(n, event, this.ui());
            },
            plugins: {},
            ui: function() {
                return {
                    originalElement: this.originalElement,
                    element: this.element,
                    helper: this.helper,
                    position: this.position,
                    size: this.size,
                    originalSize: this.originalSize,
                    originalPosition: this.originalPosition
                };
            }
        });
        $.ui.plugin.add("resizable", "animate", {
            stop: function(event) {
                var that = $(this).resizable("instance"), o = that.options, pr = that._proportionallyResizeElements, ista = pr.length && /textarea/i.test(pr[0].nodeName), soffseth = ista && that._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height, soffsetw = ista ? 0 : that.sizeDiff.width, style = {
                    width: that.size.width - soffsetw,
                    height: that.size.height - soffseth
                }, left = parseFloat(that.element.css("left")) + (that.position.left - that.originalPosition.left) || null, top = parseFloat(that.element.css("top")) + (that.position.top - that.originalPosition.top) || null;
                that.element.animate($.extend(style, top && left ? {
                    top: top,
                    left: left
                } : {}), {
                    duration: o.animateDuration,
                    easing: o.animateEasing,
                    step: function() {
                        var data = {
                            width: parseFloat(that.element.css("width")),
                            height: parseFloat(that.element.css("height")),
                            top: parseFloat(that.element.css("top")),
                            left: parseFloat(that.element.css("left"))
                        };
                        if (pr && pr.length) {
                            $(pr[0]).css({
                                width: data.width,
                                height: data.height
                            });
                        }
                        that._updateCache(data);
                        that._propagate("resize", event);
                    }
                });
            }
        });
        $.ui.plugin.add("resizable", "containment", {
            start: function() {
                var element, p, co, ch, cw, width, height, that = $(this).resizable("instance"), o = that.options, el = that.element, oc = o.containment, ce = oc instanceof $ ? oc.get(0) : /parent/.test(oc) ? el.parent().get(0) : oc;
                if (!ce) {
                    return;
                }
                that.containerElement = $(ce);
                if (/document/.test(oc) || oc === document) {
                    that.containerOffset = {
                        left: 0,
                        top: 0
                    };
                    that.containerPosition = {
                        left: 0,
                        top: 0
                    };
                    that.parentData = {
                        element: $(document),
                        left: 0,
                        top: 0,
                        width: $(document).width(),
                        height: $(document).height() || document.body.parentNode.scrollHeight
                    };
                } else {
                    element = $(ce);
                    p = [];
                    $([ "Top", "Right", "Left", "Bottom" ]).each(function(i, name) {
                        p[i] = that._num(element.css("padding" + name));
                    });
                    that.containerOffset = element.offset();
                    that.containerPosition = element.position();
                    that.containerSize = {
                        height: element.innerHeight() - p[3],
                        width: element.innerWidth() - p[1]
                    };
                    co = that.containerOffset;
                    ch = that.containerSize.height;
                    cw = that.containerSize.width;
                    width = that._hasScroll(ce, "left") ? ce.scrollWidth : cw;
                    height = that._hasScroll(ce) ? ce.scrollHeight : ch;
                    that.parentData = {
                        element: ce,
                        left: co.left,
                        top: co.top,
                        width: width,
                        height: height
                    };
                }
            },
            resize: function(event) {
                var woset, hoset, isParent, isOffsetRelative, that = $(this).resizable("instance"), o = that.options, co = that.containerOffset, cp = that.position, pRatio = that._aspectRatio || event.shiftKey, cop = {
                    top: 0,
                    left: 0
                }, ce = that.containerElement, continueResize = true;
                if (ce[0] !== document && /static/.test(ce.css("position"))) {
                    cop = co;
                }
                if (cp.left < (that._helper ? co.left : 0)) {
                    that.size.width = that.size.width + (that._helper ? that.position.left - co.left : that.position.left - cop.left);
                    if (pRatio) {
                        that.size.height = that.size.width / that.aspectRatio;
                        continueResize = false;
                    }
                    that.position.left = o.helper ? co.left : 0;
                }
                if (cp.top < (that._helper ? co.top : 0)) {
                    that.size.height = that.size.height + (that._helper ? that.position.top - co.top : that.position.top);
                    if (pRatio) {
                        that.size.width = that.size.height * that.aspectRatio;
                        continueResize = false;
                    }
                    that.position.top = that._helper ? co.top : 0;
                }
                isParent = that.containerElement.get(0) === that.element.parent().get(0);
                isOffsetRelative = /relative|absolute/.test(that.containerElement.css("position"));
                if (isParent && isOffsetRelative) {
                    that.offset.left = that.parentData.left + that.position.left;
                    that.offset.top = that.parentData.top + that.position.top;
                } else {
                    that.offset.left = that.element.offset().left;
                    that.offset.top = that.element.offset().top;
                }
                woset = Math.abs(that.sizeDiff.width + (that._helper ? that.offset.left - cop.left : that.offset.left - co.left));
                hoset = Math.abs(that.sizeDiff.height + (that._helper ? that.offset.top - cop.top : that.offset.top - co.top));
                if (woset + that.size.width >= that.parentData.width) {
                    that.size.width = that.parentData.width - woset;
                    if (pRatio) {
                        that.size.height = that.size.width / that.aspectRatio;
                        continueResize = false;
                    }
                }
                if (hoset + that.size.height >= that.parentData.height) {
                    that.size.height = that.parentData.height - hoset;
                    if (pRatio) {
                        that.size.width = that.size.height * that.aspectRatio;
                        continueResize = false;
                    }
                }
                if (!continueResize) {
                    that.position.left = that.prevPosition.left;
                    that.position.top = that.prevPosition.top;
                    that.size.width = that.prevSize.width;
                    that.size.height = that.prevSize.height;
                }
            },
            stop: function() {
                var that = $(this).resizable("instance"), o = that.options, co = that.containerOffset, cop = that.containerPosition, ce = that.containerElement, helper = $(that.helper), ho = helper.offset(), w = helper.outerWidth() - that.sizeDiff.width, h = helper.outerHeight() - that.sizeDiff.height;
                if (that._helper && !o.animate && /relative/.test(ce.css("position"))) {
                    $(this).css({
                        left: ho.left - cop.left - co.left,
                        width: w,
                        height: h
                    });
                }
                if (that._helper && !o.animate && /static/.test(ce.css("position"))) {
                    $(this).css({
                        left: ho.left - cop.left - co.left,
                        width: w,
                        height: h
                    });
                }
            }
        });
        $.ui.plugin.add("resizable", "alsoResize", {
            start: function() {
                var that = $(this).resizable("instance"), o = that.options;
                $(o.alsoResize).each(function() {
                    var el = $(this);
                    el.data("ui-resizable-alsoresize", {
                        width: parseFloat(el.width()),
                        height: parseFloat(el.height()),
                        left: parseFloat(el.css("left")),
                        top: parseFloat(el.css("top"))
                    });
                });
            },
            resize: function(event, ui) {
                var that = $(this).resizable("instance"), o = that.options, os = that.originalSize, op = that.originalPosition, delta = {
                    height: that.size.height - os.height || 0,
                    width: that.size.width - os.width || 0,
                    top: that.position.top - op.top || 0,
                    left: that.position.left - op.left || 0
                };
                $(o.alsoResize).each(function() {
                    var el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {}, css = el.parents(ui.originalElement[0]).length ? [ "width", "height" ] : [ "width", "height", "top", "left" ];
                    $.each(css, function(i, prop) {
                        var sum = (start[prop] || 0) + (delta[prop] || 0);
                        if (sum && sum >= 0) {
                            style[prop] = sum || null;
                        }
                    });
                    el.css(style);
                });
            },
            stop: function() {
                $(this).removeData("ui-resizable-alsoresize");
            }
        });
        $.ui.plugin.add("resizable", "ghost", {
            start: function() {
                var that = $(this).resizable("instance"), cs = that.size;
                that.ghost = that.originalElement.clone();
                that.ghost.css({
                    opacity: .25,
                    display: "block",
                    position: "relative",
                    height: cs.height,
                    width: cs.width,
                    margin: 0,
                    left: 0,
                    top: 0
                });
                that._addClass(that.ghost, "ui-resizable-ghost");
                if ($.uiBackCompat !== false && typeof that.options.ghost === "string") {
                    that.ghost.addClass(this.options.ghost);
                }
                that.ghost.appendTo(that.helper);
            },
            resize: function() {
                var that = $(this).resizable("instance");
                if (that.ghost) {
                    that.ghost.css({
                        position: "relative",
                        height: that.size.height,
                        width: that.size.width
                    });
                }
            },
            stop: function() {
                var that = $(this).resizable("instance");
                if (that.ghost && that.helper) {
                    that.helper.get(0).removeChild(that.ghost.get(0));
                }
            }
        });
        $.ui.plugin.add("resizable", "grid", {
            resize: function() {
                var outerDimensions, that = $(this).resizable("instance"), o = that.options, cs = that.size, os = that.originalSize, op = that.originalPosition, a = that.axis, grid = typeof o.grid === "number" ? [ o.grid, o.grid ] : o.grid, gridX = grid[0] || 1, gridY = grid[1] || 1, ox = Math.round((cs.width - os.width) / gridX) * gridX, oy = Math.round((cs.height - os.height) / gridY) * gridY, newWidth = os.width + ox, newHeight = os.height + oy, isMaxWidth = o.maxWidth && o.maxWidth < newWidth, isMaxHeight = o.maxHeight && o.maxHeight < newHeight, isMinWidth = o.minWidth && o.minWidth > newWidth, isMinHeight = o.minHeight && o.minHeight > newHeight;
                o.grid = grid;
                if (isMinWidth) {
                    newWidth += gridX;
                }
                if (isMinHeight) {
                    newHeight += gridY;
                }
                if (isMaxWidth) {
                    newWidth -= gridX;
                }
                if (isMaxHeight) {
                    newHeight -= gridY;
                }
                if (/^(se|s|e)$/.test(a)) {
                    that.size.width = newWidth;
                    that.size.height = newHeight;
                } else if (/^(ne)$/.test(a)) {
                    that.size.width = newWidth;
                    that.size.height = newHeight;
                    that.position.top = op.top - oy;
                } else if (/^(sw)$/.test(a)) {
                    that.size.width = newWidth;
                    that.size.height = newHeight;
                    that.position.left = op.left - ox;
                } else {
                    if (newHeight - gridY <= 0 || newWidth - gridX <= 0) {
                        outerDimensions = that._getPaddingPlusBorderDimensions(this);
                    }
                    if (newHeight - gridY > 0) {
                        that.size.height = newHeight;
                        that.position.top = op.top - oy;
                    } else {
                        newHeight = gridY - outerDimensions.height;
                        that.size.height = newHeight;
                        that.position.top = op.top + os.height - newHeight;
                    }
                    if (newWidth - gridX > 0) {
                        that.size.width = newWidth;
                        that.position.left = op.left - ox;
                    } else {
                        newWidth = gridX - outerDimensions.width;
                        that.size.width = newWidth;
                        that.position.left = op.left + os.width - newWidth;
                    }
                }
            }
        });
        return $.ui.resizable;
    });
    define("skylark-jqueryui/widgets/dialog", [ "skylark-jquery", "./button", "./draggable", "./mouse", "./resizable", "../focusable", "../keycode", "../position", "../safe-active-element", "../safe-blur", "../tabbable", "../unique-id", "../version", "../widget" ], function($) {
        $.widget("ui.dialog", {
            version: "@VERSION",
            options: {
                appendTo: "body",
                autoOpen: true,
                buttons: [],
                classes: {
                    "ui-dialog": "ui-corner-all",
                    "ui-dialog-titlebar": "ui-corner-all"
                },
                closeOnEscape: true,
                closeText: "Close",
                draggable: true,
                hide: null,
                height: "auto",
                maxHeight: null,
                maxWidth: null,
                minHeight: 150,
                minWidth: 150,
                modal: false,
                position: {
                    my: "center",
                    at: "center",
                    of: window,
                    collision: "fit",
                    using: function(pos) {
                        var topOffset = $(this).css(pos).offset().top;
                        if (topOffset < 0) {
                            $(this).css("top", pos.top - topOffset);
                        }
                    }
                },
                resizable: true,
                show: null,
                title: null,
                width: 300,
                beforeClose: null,
                close: null,
                drag: null,
                dragStart: null,
                dragStop: null,
                focus: null,
                open: null,
                resize: null,
                resizeStart: null,
                resizeStop: null
            },
            sizeRelatedOptions: {
                buttons: true,
                height: true,
                maxHeight: true,
                maxWidth: true,
                minHeight: true,
                minWidth: true,
                width: true
            },
            resizableRelatedOptions: {
                maxHeight: true,
                maxWidth: true,
                minHeight: true,
                minWidth: true
            },
            _create: function() {
                this.originalCss = {
                    display: this.element[0].style.display,
                    width: this.element[0].style.width,
                    minHeight: this.element[0].style.minHeight,
                    maxHeight: this.element[0].style.maxHeight,
                    height: this.element[0].style.height
                };
                this.originalPosition = {
                    parent: this.element.parent(),
                    index: this.element.parent().children().index(this.element)
                };
                this.originalTitle = this.element.attr("title");
                if (this.options.title == null && this.originalTitle != null) {
                    this.options.title = this.originalTitle;
                }
                if (this.options.disabled) {
                    this.options.disabled = false;
                }
                this._createWrapper();
                this.element.show().removeAttr("title").appendTo(this.uiDialog);
                this._addClass("ui-dialog-content", "ui-widget-content");
                this._createTitlebar();
                this._createButtonPane();
                if (this.options.draggable && $.fn.draggable) {
                    this._makeDraggable();
                }
                if (this.options.resizable && $.fn.resizable) {
                    this._makeResizable();
                }
                this._isOpen = false;
                this._trackFocus();
            },
            _init: function() {
                if (this.options.autoOpen) {
                    this.open();
                }
            },
            _appendTo: function() {
                var element = this.options.appendTo;
                if (element && (element.jquery || element.nodeType)) {
                    return $(element);
                }
                return this.document.find(element || "body").eq(0);
            },
            _destroy: function() {
                var next, originalPosition = this.originalPosition;
                this._untrackInstance();
                this._destroyOverlay();
                this.element.removeUniqueId().css(this.originalCss).detach();
                this.uiDialog.remove();
                if (this.originalTitle) {
                    this.element.attr("title", this.originalTitle);
                }
                next = originalPosition.parent.children().eq(originalPosition.index);
                if (next.length && next[0] !== this.element[0]) {
                    next.before(this.element);
                } else {
                    originalPosition.parent.append(this.element);
                }
            },
            widget: function() {
                return this.uiDialog;
            },
            disable: $.noop,
            enable: $.noop,
            close: function(event) {
                var that = this;
                if (!this._isOpen || this._trigger("beforeClose", event) === false) {
                    return;
                }
                this._isOpen = false;
                this._focusedElement = null;
                this._destroyOverlay();
                this._untrackInstance();
                if (!this.opener.filter(":focusable").trigger("focus").length) {
                    $.ui.safeBlur($.ui.safeActiveElement(this.document[0]));
                }
                this._hide(this.uiDialog, this.options.hide, function() {
                    that._trigger("close", event);
                });
            },
            isOpen: function() {
                return this._isOpen;
            },
            moveToTop: function() {
                this._moveToTop();
            },
            _moveToTop: function(event, silent) {
                var moved = false, zIndices = this.uiDialog.siblings(".ui-front:visible").map(function() {
                    return +$(this).css("z-index");
                }).get(), zIndexMax = Math.max.apply(null, zIndices);
                if (zIndexMax >= +this.uiDialog.css("z-index")) {
                    this.uiDialog.css("z-index", zIndexMax + 1);
                    moved = true;
                }
                if (moved && !silent) {
                    this._trigger("focus", event);
                }
                return moved;
            },
            open: function() {
                var that = this;
                if (this._isOpen) {
                    if (this._moveToTop()) {
                        this._focusTabbable();
                    }
                    return;
                }
                this._isOpen = true;
                this.opener = $($.ui.safeActiveElement(this.document[0]));
                this._size();
                this._position();
                this._createOverlay();
                this._moveToTop(null, true);
                if (this.overlay) {
                    this.overlay.css("z-index", this.uiDialog.css("z-index") - 1);
                }
                this._show(this.uiDialog, this.options.show, function() {
                    that._focusTabbable();
                    that._trigger("focus");
                });
                this._makeFocusTarget();
                this._trigger("open");
            },
            _focusTabbable: function() {
                var hasFocus = this._focusedElement;
                if (!hasFocus) {
                    hasFocus = this.element.find("[autofocus]");
                }
                if (!hasFocus.length) {
                    hasFocus = this.element.find(":tabbable");
                }
                if (!hasFocus.length) {
                    hasFocus = this.uiDialogButtonPane.find(":tabbable");
                }
                if (!hasFocus.length) {
                    hasFocus = this.uiDialogTitlebarClose.filter(":tabbable");
                }
                if (!hasFocus.length) {
                    hasFocus = this.uiDialog;
                }
                hasFocus.eq(0).trigger("focus");
            },
            _keepFocus: function(event) {
                function checkFocus() {
                    var activeElement = $.ui.safeActiveElement(this.document[0]), isActive = this.uiDialog[0] === activeElement || $.contains(this.uiDialog[0], activeElement);
                    if (!isActive) {
                        this._focusTabbable();
                    }
                }
                event.preventDefault();
                checkFocus.call(this);
                this._delay(checkFocus);
            },
            _createWrapper: function() {
                this.uiDialog = $("<div>").hide().attr({
                    tabIndex: -1,
                    role: "dialog"
                }).appendTo(this._appendTo());
                this._addClass(this.uiDialog, "ui-dialog", "ui-widget ui-widget-content ui-front");
                this._on(this.uiDialog, {
                    keydown: function(event) {
                        if (this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode && event.keyCode === $.ui.keyCode.ESCAPE) {
                            event.preventDefault();
                            this.close(event);
                            return;
                        }
                        if (event.keyCode !== $.ui.keyCode.TAB || event.isDefaultPrevented()) {
                            return;
                        }
                        var tabbables = this.uiDialog.find(":tabbable"), first = tabbables.filter(":first"), last = tabbables.filter(":last");
                        if ((event.target === last[0] || event.target === this.uiDialog[0]) && !event.shiftKey) {
                            this._delay(function() {
                                first.trigger("focus");
                            });
                            event.preventDefault();
                        } else if ((event.target === first[0] || event.target === this.uiDialog[0]) && event.shiftKey) {
                            this._delay(function() {
                                last.trigger("focus");
                            });
                            event.preventDefault();
                        }
                    },
                    mousedown: function(event) {
                        if (this._moveToTop(event)) {
                            this._focusTabbable();
                        }
                    }
                });
                if (!this.element.find("[aria-describedby]").length) {
                    this.uiDialog.attr({
                        "aria-describedby": this.element.uniqueId().attr("id")
                    });
                }
            },
            _createTitlebar: function() {
                var uiDialogTitle;
                this.uiDialogTitlebar = $("<div>");
                this._addClass(this.uiDialogTitlebar, "ui-dialog-titlebar", "ui-widget-header ui-helper-clearfix");
                this._on(this.uiDialogTitlebar, {
                    mousedown: function(event) {
                        if (!$(event.target).closest(".ui-dialog-titlebar-close")) {
                            this.uiDialog.trigger("focus");
                        }
                    }
                });
                this.uiDialogTitlebarClose = $("<button type='button'></button>").button({
                    label: $("<a>").text(this.options.closeText).html(),
                    icon: "ui-icon-closethick",
                    showLabel: false
                }).appendTo(this.uiDialogTitlebar);
                this._addClass(this.uiDialogTitlebarClose, "ui-dialog-titlebar-close");
                this._on(this.uiDialogTitlebarClose, {
                    click: function(event) {
                        event.preventDefault();
                        this.close(event);
                    }
                });
                uiDialogTitle = $("<span>").uniqueId().prependTo(this.uiDialogTitlebar);
                this._addClass(uiDialogTitle, "ui-dialog-title");
                this._title(uiDialogTitle);
                this.uiDialogTitlebar.prependTo(this.uiDialog);
                this.uiDialog.attr({
                    "aria-labelledby": uiDialogTitle.attr("id")
                });
            },
            _title: function(title) {
                if (this.options.title) {
                    title.text(this.options.title);
                } else {
                    title.html("&#160;");
                }
            },
            _createButtonPane: function() {
                this.uiDialogButtonPane = $("<div>");
                this._addClass(this.uiDialogButtonPane, "ui-dialog-buttonpane", "ui-widget-content ui-helper-clearfix");
                this.uiButtonSet = $("<div>").appendTo(this.uiDialogButtonPane);
                this._addClass(this.uiButtonSet, "ui-dialog-buttonset");
                this._createButtons();
            },
            _createButtons: function() {
                var that = this, buttons = this.options.buttons;
                this.uiDialogButtonPane.remove();
                this.uiButtonSet.empty();
                if ($.isEmptyObject(buttons) || $.isArray(buttons) && !buttons.length) {
                    this._removeClass(this.uiDialog, "ui-dialog-buttons");
                    return;
                }
                $.each(buttons, function(name, props) {
                    var click, buttonOptions;
                    props = $.isFunction(props) ? {
                        click: props,
                        text: name
                    } : props;
                    props = $.extend({
                        type: "button"
                    }, props);
                    click = props.click;
                    buttonOptions = {
                        icon: props.icon,
                        iconPosition: props.iconPosition,
                        showLabel: props.showLabel,
                        icons: props.icons,
                        text: props.text
                    };
                    delete props.click;
                    delete props.icon;
                    delete props.iconPosition;
                    delete props.showLabel;
                    delete props.icons;
                    if (typeof props.text === "boolean") {
                        delete props.text;
                    }
                    $("<button></button>", props).button(buttonOptions).appendTo(that.uiButtonSet).on("click", function() {
                        click.apply(that.element[0], arguments);
                    });
                });
                this._addClass(this.uiDialog, "ui-dialog-buttons");
                this.uiDialogButtonPane.appendTo(this.uiDialog);
            },
            _makeDraggable: function() {
                var that = this, options = this.options;
                function filteredUi(ui) {
                    return {
                        position: ui.position,
                        offset: ui.offset
                    };
                }
                this.uiDialog.draggable({
                    cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
                    handle: ".ui-dialog-titlebar",
                    containment: "document",
                    start: function(event, ui) {
                        that._addClass($(this), "ui-dialog-dragging");
                        that._blockFrames();
                        that._trigger("dragStart", event, filteredUi(ui));
                    },
                    drag: function(event, ui) {
                        that._trigger("drag", event, filteredUi(ui));
                    },
                    stop: function(event, ui) {
                        var left = ui.offset.left - that.document.scrollLeft(), top = ui.offset.top - that.document.scrollTop();
                        options.position = {
                            my: "left top",
                            at: "left" + (left >= 0 ? "+" : "") + left + " " + "top" + (top >= 0 ? "+" : "") + top,
                            of: that.window
                        };
                        that._removeClass($(this), "ui-dialog-dragging");
                        that._unblockFrames();
                        that._trigger("dragStop", event, filteredUi(ui));
                    }
                });
            },
            _makeResizable: function() {
                var that = this, options = this.options, handles = options.resizable, position = this.uiDialog.css("position"), resizeHandles = typeof handles === "string" ? handles : "n,e,s,w,se,sw,ne,nw";
                function filteredUi(ui) {
                    return {
                        originalPosition: ui.originalPosition,
                        originalSize: ui.originalSize,
                        position: ui.position,
                        size: ui.size
                    };
                }
                this.uiDialog.resizable({
                    cancel: ".ui-dialog-content",
                    containment: "document",
                    alsoResize: this.element,
                    maxWidth: options.maxWidth,
                    maxHeight: options.maxHeight,
                    minWidth: options.minWidth,
                    minHeight: this._minHeight(),
                    handles: resizeHandles,
                    start: function(event, ui) {
                        that._addClass($(this), "ui-dialog-resizing");
                        that._blockFrames();
                        that._trigger("resizeStart", event, filteredUi(ui));
                    },
                    resize: function(event, ui) {
                        that._trigger("resize", event, filteredUi(ui));
                    },
                    stop: function(event, ui) {
                        var offset = that.uiDialog.offset(), left = offset.left - that.document.scrollLeft(), top = offset.top - that.document.scrollTop();
                        options.height = that.uiDialog.height();
                        options.width = that.uiDialog.width();
                        options.position = {
                            my: "left top",
                            at: "left" + (left >= 0 ? "+" : "") + left + " " + "top" + (top >= 0 ? "+" : "") + top,
                            of: that.window
                        };
                        that._removeClass($(this), "ui-dialog-resizing");
                        that._unblockFrames();
                        that._trigger("resizeStop", event, filteredUi(ui));
                    }
                }).css("position", position);
            },
            _trackFocus: function() {
                this._on(this.widget(), {
                    focusin: function(event) {
                        this._makeFocusTarget();
                        this._focusedElement = $(event.target);
                    }
                });
            },
            _makeFocusTarget: function() {
                this._untrackInstance();
                this._trackingInstances().unshift(this);
            },
            _untrackInstance: function() {
                var instances = this._trackingInstances(), exists = $.inArray(this, instances);
                if (exists !== -1) {
                    instances.splice(exists, 1);
                }
            },
            _trackingInstances: function() {
                var instances = this.document.data("ui-dialog-instances");
                if (!instances) {
                    instances = [];
                    this.document.data("ui-dialog-instances", instances);
                }
                return instances;
            },
            _minHeight: function() {
                var options = this.options;
                return options.height === "auto" ? options.minHeight : Math.min(options.minHeight, options.height);
            },
            _position: function() {
                var isVisible = this.uiDialog.is(":visible");
                if (!isVisible) {
                    this.uiDialog.show();
                }
                this.uiDialog.position(this.options.position);
                if (!isVisible) {
                    this.uiDialog.hide();
                }
            },
            _setOptions: function(options) {
                var that = this, resize = false, resizableOptions = {};
                $.each(options, function(key, value) {
                    that._setOption(key, value);
                    if (key in that.sizeRelatedOptions) {
                        resize = true;
                    }
                    if (key in that.resizableRelatedOptions) {
                        resizableOptions[key] = value;
                    }
                });
                if (resize) {
                    this._size();
                    this._position();
                }
                if (this.uiDialog.is(":data(ui-resizable)")) {
                    this.uiDialog.resizable("option", resizableOptions);
                }
            },
            _setOption: function(key, value) {
                var isDraggable, isResizable, uiDialog = this.uiDialog;
                if (key === "disabled") {
                    return;
                }
                this._super(key, value);
                if (key === "appendTo") {
                    this.uiDialog.appendTo(this._appendTo());
                }
                if (key === "buttons") {
                    this._createButtons();
                }
                if (key === "closeText") {
                    this.uiDialogTitlebarClose.button({
                        label: $("<a>").text("" + this.options.closeText).html()
                    });
                }
                if (key === "draggable") {
                    isDraggable = uiDialog.is(":data(ui-draggable)");
                    if (isDraggable && !value) {
                        uiDialog.draggable("destroy");
                    }
                    if (!isDraggable && value) {
                        this._makeDraggable();
                    }
                }
                if (key === "position") {
                    this._position();
                }
                if (key === "resizable") {
                    isResizable = uiDialog.is(":data(ui-resizable)");
                    if (isResizable && !value) {
                        uiDialog.resizable("destroy");
                    }
                    if (isResizable && typeof value === "string") {
                        uiDialog.resizable("option", "handles", value);
                    }
                    if (!isResizable && value !== false) {
                        this._makeResizable();
                    }
                }
                if (key === "title") {
                    this._title(this.uiDialogTitlebar.find(".ui-dialog-title"));
                }
            },
            _size: function() {
                var nonContentHeight, minContentHeight, maxContentHeight, options = this.options;
                this.element.show().css({
                    width: "auto",
                    minHeight: 0,
                    maxHeight: "none",
                    height: 0
                });
                if (options.minWidth > options.width) {
                    options.width = options.minWidth;
                }
                nonContentHeight = this.uiDialog.css({
                    height: "auto",
                    width: options.width
                }).outerHeight();
                minContentHeight = Math.max(0, options.minHeight - nonContentHeight);
                maxContentHeight = typeof options.maxHeight === "number" ? Math.max(0, options.maxHeight - nonContentHeight) : "none";
                if (options.height === "auto") {
                    this.element.css({
                        minHeight: minContentHeight,
                        maxHeight: maxContentHeight,
                        height: "auto"
                    });
                } else {
                    this.element.height(Math.max(0, options.height - nonContentHeight));
                }
                if (this.uiDialog.is(":data(ui-resizable)")) {
                    this.uiDialog.resizable("option", "minHeight", this._minHeight());
                }
            },
            _blockFrames: function() {
                this.iframeBlocks = this.document.find("iframe").map(function() {
                    var iframe = $(this);
                    return $("<div>").css({
                        position: "absolute",
                        width: iframe.outerWidth(),
                        height: iframe.outerHeight()
                    }).appendTo(iframe.parent()).offset(iframe.offset())[0];
                });
            },
            _unblockFrames: function() {
                if (this.iframeBlocks) {
                    this.iframeBlocks.remove();
                    delete this.iframeBlocks;
                }
            },
            _allowInteraction: function(event) {
                if ($(event.target).closest(".ui-dialog").length) {
                    return true;
                }
                return !!$(event.target).closest(".ui-datepicker").length;
            },
            _createOverlay: function() {
                if (!this.options.modal) {
                    return;
                }
                var isOpening = true;
                this._delay(function() {
                    isOpening = false;
                });
                if (!this.document.data("ui-dialog-overlays")) {
                    this.document.on("focusin.ui-dialog", function(event) {
                        if (isOpening) {
                            return;
                        }
                        var instance = this._trackingInstances()[0];
                        if (!instance._allowInteraction(event)) {
                            event.preventDefault();
                            instance._focusTabbable();
                        }
                    }.bind(this));
                }
                this.overlay = $("<div>").appendTo(this._appendTo());
                this._addClass(this.overlay, null, "ui-widget-overlay ui-front");
                this._on(this.overlay, {
                    mousedown: "_keepFocus"
                });
                this.document.data("ui-dialog-overlays", (this.document.data("ui-dialog-overlays") || 0) + 1);
            },
            _destroyOverlay: function() {
                if (!this.options.modal) {
                    return;
                }
                if (this.overlay) {
                    var overlays = this.document.data("ui-dialog-overlays") - 1;
                    if (!overlays) {
                        this.document.off("focusin.ui-dialog");
                        this.document.removeData("ui-dialog-overlays");
                    } else {
                        this.document.data("ui-dialog-overlays", overlays);
                    }
                    this.overlay.remove();
                    this.overlay = null;
                }
            }
        });
        if ($.uiBackCompat !== false) {
            $.widget("ui.dialog", $.ui.dialog, {
                options: {
                    dialogClass: ""
                },
                _createWrapper: function() {
                    this._super();
                    this.uiDialog.addClass(this.options.dialogClass);
                },
                _setOption: function(key, value) {
                    if (key === "dialogClass") {
                        this.uiDialog.removeClass(this.options.dialogClass).addClass(value);
                    }
                    this._superApply(arguments);
                }
            });
        }
        return $.ui.dialog;
    });
    define("skylark-jqueryui/widgets/progressbar", [ "skylark-jquery", "../version", "../widget" ], function($) {
        return $.widget("ui.progressbar", {
            version: "@VERSION",
            options: {
                classes: {
                    "ui-progressbar": "ui-corner-all",
                    "ui-progressbar-value": "ui-corner-left",
                    "ui-progressbar-complete": "ui-corner-right"
                },
                max: 100,
                value: 0,
                change: null,
                complete: null
            },
            min: 0,
            _create: function() {
                this.oldValue = this.options.value = this._constrainedValue();
                this.element.attr({
                    role: "progressbar",
                    "aria-valuemin": this.min
                });
                this._addClass("ui-progressbar", "ui-widget ui-widget-content");
                this.valueDiv = $("<div>").appendTo(this.element);
                this._addClass(this.valueDiv, "ui-progressbar-value", "ui-widget-header");
                this._refreshValue();
            },
            _destroy: function() {
                this.element.removeAttr("role aria-valuemin aria-valuemax aria-valuenow");
                this.valueDiv.remove();
            },
            value: function(newValue) {
                if (newValue === undefined) {
                    return this.options.value;
                }
                this.options.value = this._constrainedValue(newValue);
                this._refreshValue();
            },
            _constrainedValue: function(newValue) {
                if (newValue === undefined) {
                    newValue = this.options.value;
                }
                this.indeterminate = newValue === false;
                if (typeof newValue !== "number") {
                    newValue = 0;
                }
                return this.indeterminate ? false : Math.min(this.options.max, Math.max(this.min, newValue));
            },
            _setOptions: function(options) {
                var value = options.value;
                delete options.value;
                this._super(options);
                this.options.value = this._constrainedValue(value);
                this._refreshValue();
            },
            _setOption: function(key, value) {
                if (key === "max") {
                    value = Math.max(this.min, value);
                }
                this._super(key, value);
            },
            _setOptionDisabled: function(value) {
                this._super(value);
                this.element.attr("aria-disabled", value);
                this._toggleClass(null, "ui-state-disabled", !!value);
            },
            _percentage: function() {
                return this.indeterminate ? 100 : 100 * (this.options.value - this.min) / (this.options.max - this.min);
            },
            _refreshValue: function() {
                var value = this.options.value, percentage = this._percentage();
                this.valueDiv.toggle(this.indeterminate || value > this.min).width(percentage.toFixed(0) + "%");
                this._toggleClass(this.valueDiv, "ui-progressbar-complete", null, value === this.options.max)._toggleClass("ui-progressbar-indeterminate", null, this.indeterminate);
                if (this.indeterminate) {
                    this.element.removeAttr("aria-valuenow");
                    if (!this.overlayDiv) {
                        this.overlayDiv = $("<div>").appendTo(this.valueDiv);
                        this._addClass(this.overlayDiv, "ui-progressbar-overlay");
                    }
                } else {
                    this.element.attr({
                        "aria-valuemax": this.options.max,
                        "aria-valuenow": value
                    });
                    if (this.overlayDiv) {
                        this.overlayDiv.remove();
                        this.overlayDiv = null;
                    }
                }
                if (this.oldValue !== value) {
                    this.oldValue = value;
                    this._trigger("change");
                }
                if (value === this.options.max) {
                    this._trigger("complete");
                }
            }
        });
    });
    define("skylark-jqueryui/widgets/selectable", [ "skylark-jquery", "./mouse", "../version", "../widget" ], function($) {
        return $.widget("ui.selectable", $.ui.mouse, {
            version: "@VERSION",
            options: {
                appendTo: "body",
                autoRefresh: true,
                distance: 0,
                filter: "*",
                tolerance: "touch",
                selected: null,
                selecting: null,
                start: null,
                stop: null,
                unselected: null,
                unselecting: null
            },
            _create: function() {
                var that = this;
                this._addClass("ui-selectable");
                this.dragged = false;
                this.refresh = function() {
                    that.elementPos = $(that.element[0]).offset();
                    that.selectees = $(that.options.filter, that.element[0]);
                    that._addClass(that.selectees, "ui-selectee");
                    that.selectees.each(function() {
                        var $this = $(this), selecteeOffset = $this.offset(), pos = {
                            left: selecteeOffset.left - that.elementPos.left,
                            top: selecteeOffset.top - that.elementPos.top
                        };
                        $.data(this, "selectable-item", {
                            element: this,
                            $element: $this,
                            left: pos.left,
                            top: pos.top,
                            right: pos.left + $this.outerWidth(),
                            bottom: pos.top + $this.outerHeight(),
                            startselected: false,
                            selected: $this.hasClass("ui-selected"),
                            selecting: $this.hasClass("ui-selecting"),
                            unselecting: $this.hasClass("ui-unselecting")
                        });
                    });
                };
                this.refresh();
                this._mouseInit();
                this.helper = $("<div>");
                this._addClass(this.helper, "ui-selectable-helper");
            },
            _destroy: function() {
                this.selectees.removeData("selectable-item");
                this._mouseDestroy();
            },
            _mouseStart: function(event) {
                var that = this, options = this.options;
                this.opos = [ event.pageX, event.pageY ];
                this.elementPos = $(this.element[0]).offset();
                if (this.options.disabled) {
                    return;
                }
                this.selectees = $(options.filter, this.element[0]);
                this._trigger("start", event);
                $(options.appendTo).append(this.helper);
                this.helper.css({
                    left: event.pageX,
                    top: event.pageY,
                    width: 0,
                    height: 0
                });
                if (options.autoRefresh) {
                    this.refresh();
                }
                this.selectees.filter(".ui-selected").each(function() {
                    var selectee = $.data(this, "selectable-item");
                    selectee.startselected = true;
                    if (!event.metaKey && !event.ctrlKey) {
                        that._removeClass(selectee.$element, "ui-selected");
                        selectee.selected = false;
                        that._addClass(selectee.$element, "ui-unselecting");
                        selectee.unselecting = true;
                        that._trigger("unselecting", event, {
                            unselecting: selectee.element
                        });
                    }
                });
                $(event.target).parents().addBack().each(function() {
                    var doSelect, selectee = $.data(this, "selectable-item");
                    if (selectee) {
                        doSelect = !event.metaKey && !event.ctrlKey || !selectee.$element.hasClass("ui-selected");
                        that._removeClass(selectee.$element, doSelect ? "ui-unselecting" : "ui-selected")._addClass(selectee.$element, doSelect ? "ui-selecting" : "ui-unselecting");
                        selectee.unselecting = !doSelect;
                        selectee.selecting = doSelect;
                        selectee.selected = doSelect;
                        if (doSelect) {
                            that._trigger("selecting", event, {
                                selecting: selectee.element
                            });
                        } else {
                            that._trigger("unselecting", event, {
                                unselecting: selectee.element
                            });
                        }
                        return false;
                    }
                });
            },
            _mouseDrag: function(event) {
                this.dragged = true;
                if (this.options.disabled) {
                    return;
                }
                var tmp, that = this, options = this.options, x1 = this.opos[0], y1 = this.opos[1], x2 = event.pageX, y2 = event.pageY;
                if (x1 > x2) {
                    tmp = x2;
                    x2 = x1;
                    x1 = tmp;
                }
                if (y1 > y2) {
                    tmp = y2;
                    y2 = y1;
                    y1 = tmp;
                }
                this.helper.css({
                    left: x1,
                    top: y1,
                    width: x2 - x1,
                    height: y2 - y1
                });
                this.selectees.each(function() {
                    var selectee = $.data(this, "selectable-item"), hit = false, offset = {};
                    if (!selectee || selectee.element === that.element[0]) {
                        return;
                    }
                    offset.left = selectee.left + that.elementPos.left;
                    offset.right = selectee.right + that.elementPos.left;
                    offset.top = selectee.top + that.elementPos.top;
                    offset.bottom = selectee.bottom + that.elementPos.top;
                    if (options.tolerance === "touch") {
                        hit = !(offset.left > x2 || offset.right < x1 || offset.top > y2 || offset.bottom < y1);
                    } else if (options.tolerance === "fit") {
                        hit = offset.left > x1 && offset.right < x2 && offset.top > y1 && offset.bottom < y2;
                    }
                    if (hit) {
                        if (selectee.selected) {
                            that._removeClass(selectee.$element, "ui-selected");
                            selectee.selected = false;
                        }
                        if (selectee.unselecting) {
                            that._removeClass(selectee.$element, "ui-unselecting");
                            selectee.unselecting = false;
                        }
                        if (!selectee.selecting) {
                            that._addClass(selectee.$element, "ui-selecting");
                            selectee.selecting = true;
                            that._trigger("selecting", event, {
                                selecting: selectee.element
                            });
                        }
                    } else {
                        if (selectee.selecting) {
                            if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
                                that._removeClass(selectee.$element, "ui-selecting");
                                selectee.selecting = false;
                                that._addClass(selectee.$element, "ui-selected");
                                selectee.selected = true;
                            } else {
                                that._removeClass(selectee.$element, "ui-selecting");
                                selectee.selecting = false;
                                if (selectee.startselected) {
                                    that._addClass(selectee.$element, "ui-unselecting");
                                    selectee.unselecting = true;
                                }
                                that._trigger("unselecting", event, {
                                    unselecting: selectee.element
                                });
                            }
                        }
                        if (selectee.selected) {
                            if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
                                that._removeClass(selectee.$element, "ui-selected");
                                selectee.selected = false;
                                that._addClass(selectee.$element, "ui-unselecting");
                                selectee.unselecting = true;
                                that._trigger("unselecting", event, {
                                    unselecting: selectee.element
                                });
                            }
                        }
                    }
                });
                return false;
            },
            _mouseStop: function(event) {
                var that = this;
                this.dragged = false;
                $(".ui-unselecting", this.element[0]).each(function() {
                    var selectee = $.data(this, "selectable-item");
                    that._removeClass(selectee.$element, "ui-unselecting");
                    selectee.unselecting = false;
                    selectee.startselected = false;
                    that._trigger("unselected", event, {
                        unselected: selectee.element
                    });
                });
                $(".ui-selecting", this.element[0]).each(function() {
                    var selectee = $.data(this, "selectable-item");
                    that._removeClass(selectee.$element, "ui-selecting")._addClass(selectee.$element, "ui-selected");
                    selectee.selecting = false;
                    selectee.selected = true;
                    selectee.startselected = true;
                    that._trigger("selected", event, {
                        selected: selectee.element
                    });
                });
                this._trigger("stop", event);
                this.helper.remove();
                return false;
            }
        });
    });
    define("skylark-jqueryui/widgets/selectmenu", [ "skylark-jquery", "./menu", "../escape-selector", "../form-reset-mixin", "../keycode", "../labels", "../position", "../unique-id", "../version", "../widget" ], function($) {
        return $.widget("ui.selectmenu", [ $.ui.formResetMixin, {
            version: "@VERSION",
            defaultElement: "<select>",
            options: {
                appendTo: null,
                classes: {
                    "ui-selectmenu-button-open": "ui-corner-top",
                    "ui-selectmenu-button-closed": "ui-corner-all"
                },
                disabled: null,
                icons: {
                    button: "ui-icon-triangle-1-s"
                },
                position: {
                    my: "left top",
                    at: "left bottom",
                    collision: "none"
                },
                width: false,
                change: null,
                close: null,
                focus: null,
                open: null,
                select: null
            },
            _create: function() {
                var selectmenuId = this.element.uniqueId().attr("id");
                this.ids = {
                    element: selectmenuId,
                    button: selectmenuId + "-button",
                    menu: selectmenuId + "-menu"
                };
                this._drawButton();
                this._drawMenu();
                this._bindFormResetHandler();
                this._rendered = false;
                this.menuItems = $();
            },
            _drawButton: function() {
                var icon, that = this, item = this._parseOption(this.element.find("option:selected"), this.element[0].selectedIndex);
                this.labels = this.element.labels().attr("for", this.ids.button);
                this._on(this.labels, {
                    click: function(event) {
                        this.button.focus();
                        event.preventDefault();
                    }
                });
                this.element.hide();
                this.button = $("<span>", {
                    tabindex: this.options.disabled ? -1 : 0,
                    id: this.ids.button,
                    role: "combobox",
                    "aria-expanded": "false",
                    "aria-autocomplete": "list",
                    "aria-owns": this.ids.menu,
                    "aria-haspopup": "true",
                    title: this.element.attr("title")
                }).insertAfter(this.element);
                this._addClass(this.button, "ui-selectmenu-button ui-selectmenu-button-closed", "ui-button ui-widget");
                icon = $("<span>").appendTo(this.button);
                this._addClass(icon, "ui-selectmenu-icon", "ui-icon " + this.options.icons.button);
                this.buttonItem = this._renderButtonItem(item).appendTo(this.button);
                if (this.options.width !== false) {
                    this._resizeButton();
                }
                this._on(this.button, this._buttonEvents);
                this.button.one("focusin", function() {
                    if (!that._rendered) {
                        that._refreshMenu();
                    }
                });
            },
            _drawMenu: function() {
                var that = this;
                this.menu = $("<ul>", {
                    "aria-hidden": "true",
                    "aria-labelledby": this.ids.button,
                    id: this.ids.menu
                });
                this.menuWrap = $("<div>").append(this.menu);
                this._addClass(this.menuWrap, "ui-selectmenu-menu", "ui-front");
                this.menuWrap.appendTo(this._appendTo());
                this.menuInstance = this.menu.menu({
                    classes: {
                        "ui-menu": "ui-corner-bottom"
                    },
                    role: "listbox",
                    select: function(event, ui) {
                        event.preventDefault();
                        that._setSelection();
                        that._select(ui.item.data("ui-selectmenu-item"), event);
                    },
                    focus: function(event, ui) {
                        var item = ui.item.data("ui-selectmenu-item");
                        if (that.focusIndex != null && item.index !== that.focusIndex) {
                            that._trigger("focus", event, {
                                item: item
                            });
                            if (!that.isOpen) {
                                that._select(item, event);
                            }
                        }
                        that.focusIndex = item.index;
                        that.button.attr("aria-activedescendant", that.menuItems.eq(item.index).attr("id"));
                    }
                }).menu("instance");
                this.menuInstance._off(this.menu, "mouseleave");
                this.menuInstance._closeOnDocumentClick = function() {
                    return false;
                };
                this.menuInstance._isDivider = function() {
                    return false;
                };
            },
            refresh: function() {
                this._refreshMenu();
                this.buttonItem.replaceWith(this.buttonItem = this._renderButtonItem(this._getSelectedItem().data("ui-selectmenu-item") || {}));
                if (this.options.width === null) {
                    this._resizeButton();
                }
            },
            _refreshMenu: function() {
                var item, options = this.element.find("option");
                this.menu.empty();
                this._parseOptions(options);
                this._renderMenu(this.menu, this.items);
                this.menuInstance.refresh();
                this.menuItems = this.menu.find("li").not(".ui-selectmenu-optgroup").find(".ui-menu-item-wrapper");
                this._rendered = true;
                if (!options.length) {
                    return;
                }
                item = this._getSelectedItem();
                this.menuInstance.focus(null, item);
                this._setAria(item.data("ui-selectmenu-item"));
                this._setOption("disabled", this.element.prop("disabled"));
            },
            open: function(event) {
                if (this.options.disabled) {
                    return;
                }
                if (!this._rendered) {
                    this._refreshMenu();
                } else {
                    this._removeClass(this.menu.find(".ui-state-active"), null, "ui-state-active");
                    this.menuInstance.focus(null, this._getSelectedItem());
                }
                if (!this.menuItems.length) {
                    return;
                }
                this.isOpen = true;
                this._toggleAttr();
                this._resizeMenu();
                this._position();
                this._on(this.document, this._documentClick);
                this._trigger("open", event);
            },
            _position: function() {
                this.menuWrap.position($.extend({
                    of: this.button
                }, this.options.position));
            },
            close: function(event) {
                if (!this.isOpen) {
                    return;
                }
                this.isOpen = false;
                this._toggleAttr();
                this.range = null;
                this._off(this.document);
                this._trigger("close", event);
            },
            widget: function() {
                return this.button;
            },
            menuWidget: function() {
                return this.menu;
            },
            _renderButtonItem: function(item) {
                var buttonItem = $("<span>");
                this._setText(buttonItem, item.label);
                this._addClass(buttonItem, "ui-selectmenu-text");
                return buttonItem;
            },
            _renderMenu: function(ul, items) {
                var that = this, currentOptgroup = "";
                $.each(items, function(index, item) {
                    var li;
                    if (item.optgroup !== currentOptgroup) {
                        li = $("<li>", {
                            text: item.optgroup
                        });
                        that._addClass(li, "ui-selectmenu-optgroup", "ui-menu-divider" + (item.element.parent("optgroup").prop("disabled") ? " ui-state-disabled" : ""));
                        li.appendTo(ul);
                        currentOptgroup = item.optgroup;
                    }
                    that._renderItemData(ul, item);
                });
            },
            _renderItemData: function(ul, item) {
                return this._renderItem(ul, item).data("ui-selectmenu-item", item);
            },
            _renderItem: function(ul, item) {
                var li = $("<li>"), wrapper = $("<div>", {
                    title: item.element.attr("title")
                });
                if (item.disabled) {
                    this._addClass(li, null, "ui-state-disabled");
                }
                this._setText(wrapper, item.label);
                return li.append(wrapper).appendTo(ul);
            },
            _setText: function(element, value) {
                if (value) {
                    element.text(value);
                } else {
                    element.html("&#160;");
                }
            },
            _move: function(direction, event) {
                var item, next, filter = ".ui-menu-item";
                if (this.isOpen) {
                    item = this.menuItems.eq(this.focusIndex).parent("li");
                } else {
                    item = this.menuItems.eq(this.element[0].selectedIndex).parent("li");
                    filter += ":not(.ui-state-disabled)";
                }
                if (direction === "first" || direction === "last") {
                    next = item[direction === "first" ? "prevAll" : "nextAll"](filter).eq(-1);
                } else {
                    next = item[direction + "All"](filter).eq(0);
                }
                if (next.length) {
                    this.menuInstance.focus(event, next);
                }
            },
            _getSelectedItem: function() {
                return this.menuItems.eq(this.element[0].selectedIndex).parent("li");
            },
            _toggle: function(event) {
                this[this.isOpen ? "close" : "open"](event);
            },
            _setSelection: function() {
                var selection;
                if (!this.range) {
                    return;
                }
                if (window.getSelection) {
                    selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(this.range);
                } else {
                    this.range.select();
                }
                this.button.focus();
            },
            _documentClick: {
                mousedown: function(event) {
                    if (!this.isOpen) {
                        return;
                    }
                    if (!$(event.target).closest(".ui-selectmenu-menu, #" + $.ui.escapeSelector(this.ids.button)).length) {
                        this.close(event);
                    }
                }
            },
            _buttonEvents: {
                mousedown: function() {
                    var selection;
                    if (window.getSelection) {
                        selection = window.getSelection();
                        if (selection.rangeCount) {
                            this.range = selection.getRangeAt(0);
                        }
                    } else {
                        this.range = document.selection.createRange();
                    }
                },
                click: function(event) {
                    this._setSelection();
                    this._toggle(event);
                },
                keydown: function(event) {
                    var preventDefault = true;
                    switch (event.keyCode) {
                      case $.ui.keyCode.TAB:
                      case $.ui.keyCode.ESCAPE:
                        this.close(event);
                        preventDefault = false;
                        break;

                      case $.ui.keyCode.ENTER:
                        if (this.isOpen) {
                            this._selectFocusedItem(event);
                        }
                        break;

                      case $.ui.keyCode.UP:
                        if (event.altKey) {
                            this._toggle(event);
                        } else {
                            this._move("prev", event);
                        }
                        break;

                      case $.ui.keyCode.DOWN:
                        if (event.altKey) {
                            this._toggle(event);
                        } else {
                            this._move("next", event);
                        }
                        break;

                      case $.ui.keyCode.SPACE:
                        if (this.isOpen) {
                            this._selectFocusedItem(event);
                        } else {
                            this._toggle(event);
                        }
                        break;

                      case $.ui.keyCode.LEFT:
                        this._move("prev", event);
                        break;

                      case $.ui.keyCode.RIGHT:
                        this._move("next", event);
                        break;

                      case $.ui.keyCode.HOME:
                      case $.ui.keyCode.PAGE_UP:
                        this._move("first", event);
                        break;

                      case $.ui.keyCode.END:
                      case $.ui.keyCode.PAGE_DOWN:
                        this._move("last", event);
                        break;

                      default:
                        this.menu.trigger(event);
                        preventDefault = false;
                    }
                    if (preventDefault) {
                        event.preventDefault();
                    }
                }
            },
            _selectFocusedItem: function(event) {
                var item = this.menuItems.eq(this.focusIndex).parent("li");
                if (!item.hasClass("ui-state-disabled")) {
                    this._select(item.data("ui-selectmenu-item"), event);
                }
            },
            _select: function(item, event) {
                var oldIndex = this.element[0].selectedIndex;
                this.element[0].selectedIndex = item.index;
                this.buttonItem.replaceWith(this.buttonItem = this._renderButtonItem(item));
                this._setAria(item);
                this._trigger("select", event, {
                    item: item
                });
                if (item.index !== oldIndex) {
                    this._trigger("change", event, {
                        item: item
                    });
                }
                this.close(event);
            },
            _setAria: function(item) {
                var id = this.menuItems.eq(item.index).attr("id");
                this.button.attr({
                    "aria-labelledby": id,
                    "aria-activedescendant": id
                });
                this.menu.attr("aria-activedescendant", id);
            },
            _setOption: function(key, value) {
                if (key === "icons") {
                    var icon = this.button.find("span.ui-icon");
                    this._removeClass(icon, null, this.options.icons.button)._addClass(icon, null, value.button);
                }
                this._super(key, value);
                if (key === "appendTo") {
                    this.menuWrap.appendTo(this._appendTo());
                }
                if (key === "width") {
                    this._resizeButton();
                }
            },
            _setOptionDisabled: function(value) {
                this._super(value);
                this.menuInstance.option("disabled", value);
                this.button.attr("aria-disabled", value);
                this._toggleClass(this.button, null, "ui-state-disabled", value);
                this.element.prop("disabled", value);
                if (value) {
                    this.button.attr("tabindex", -1);
                    this.close();
                } else {
                    this.button.attr("tabindex", 0);
                }
            },
            _appendTo: function() {
                var element = this.options.appendTo;
                if (element) {
                    element = element.jquery || element.nodeType ? $(element) : this.document.find(element).eq(0);
                }
                if (!element || !element[0]) {
                    element = this.element.closest(".ui-front, dialog");
                }
                if (!element.length) {
                    element = this.document[0].body;
                }
                return element;
            },
            _toggleAttr: function() {
                this.button.attr("aria-expanded", this.isOpen);
                this._removeClass(this.button, "ui-selectmenu-button-" + (this.isOpen ? "closed" : "open"))._addClass(this.button, "ui-selectmenu-button-" + (this.isOpen ? "open" : "closed"))._toggleClass(this.menuWrap, "ui-selectmenu-open", null, this.isOpen);
                this.menu.attr("aria-hidden", !this.isOpen);
            },
            _resizeButton: function() {
                var width = this.options.width;
                if (width === false) {
                    this.button.css("width", "");
                    return;
                }
                if (width === null) {
                    width = this.element.show().outerWidth();
                    this.element.hide();
                }
                this.button.outerWidth(width);
            },
            _resizeMenu: function() {
                this.menu.outerWidth(Math.max(this.button.outerWidth(), this.menu.width("").outerWidth() + 1));
            },
            _getCreateOptions: function() {
                var options = this._super();
                options.disabled = this.element.prop("disabled");
                return options;
            },
            _parseOptions: function(options) {
                var that = this, data = [];
                options.each(function(index, item) {
                    if (item.hidden) {
                        return;
                    }
                    data.push(that._parseOption($(item), index));
                });
                this.items = data;
            },
            _parseOption: function(option, index) {
                var optgroup = option.parent("optgroup");
                return {
                    element: option,
                    index: index,
                    value: option.val(),
                    label: option.text(),
                    optgroup: optgroup.attr("label") || "",
                    disabled: optgroup.prop("disabled") || option.prop("disabled")
                };
            },
            _destroy: function() {
                this._unbindFormResetHandler();
                this.menuWrap.remove();
                this.button.remove();
                this.element.show();
                this.element.removeUniqueId();
                this.labels.attr("for", this.ids.element);
            }
        } ]);
    });
    define("skylark-jqueryui/widgets/slider", [ "skylark-jquery", "./mouse", "../keycode", "../version", "../widget" ], function($) {
        return $.widget("ui.slider", $.ui.mouse, {
            version: "@VERSION",
            widgetEventPrefix: "slide",
            options: {
                animate: false,
                classes: {
                    "ui-slider": "ui-corner-all",
                    "ui-slider-handle": "ui-corner-all",
                    "ui-slider-range": "ui-corner-all ui-widget-header"
                },
                distance: 0,
                max: 100,
                min: 0,
                orientation: "horizontal",
                range: false,
                step: 1,
                value: 0,
                values: null,
                change: null,
                slide: null,
                start: null,
                stop: null
            },
            numPages: 5,
            _create: function() {
                this._keySliding = false;
                this._mouseSliding = false;
                this._animateOff = true;
                this._handleIndex = null;
                this._detectOrientation();
                this._mouseInit();
                this._calculateNewMax();
                this._addClass("ui-slider ui-slider-" + this.orientation, "ui-widget ui-widget-content");
                this._refresh();
                this._animateOff = false;
            },
            _refresh: function() {
                this._createRange();
                this._createHandles();
                this._setupEvents();
                this._refreshValue();
            },
            _createHandles: function() {
                var i, handleCount, options = this.options, existingHandles = this.element.find(".ui-slider-handle"), handle = "<span tabindex='0'></span>", handles = [];
                handleCount = options.values && options.values.length || 1;
                if (existingHandles.length > handleCount) {
                    existingHandles.slice(handleCount).remove();
                    existingHandles = existingHandles.slice(0, handleCount);
                }
                for (i = existingHandles.length; i < handleCount; i++) {
                    handles.push(handle);
                }
                this.handles = existingHandles.add($(handles.join("")).appendTo(this.element));
                this._addClass(this.handles, "ui-slider-handle", "ui-state-default");
                this.handle = this.handles.eq(0);
                this.handles.each(function(i) {
                    $(this).data("ui-slider-handle-index", i).attr("tabIndex", 0);
                });
            },
            _createRange: function() {
                var options = this.options;
                if (options.range) {
                    if (options.range === true) {
                        if (!options.values) {
                            options.values = [ this._valueMin(), this._valueMin() ];
                        } else if (options.values.length && options.values.length !== 2) {
                            options.values = [ options.values[0], options.values[0] ];
                        } else if ($.isArray(options.values)) {
                            options.values = options.values.slice(0);
                        }
                    }
                    if (!this.range || !this.range.length) {
                        this.range = $("<div>").appendTo(this.element);
                        this._addClass(this.range, "ui-slider-range");
                    } else {
                        this._removeClass(this.range, "ui-slider-range-min ui-slider-range-max");
                        this.range.css({
                            left: "",
                            bottom: ""
                        });
                    }
                    if (options.range === "min" || options.range === "max") {
                        this._addClass(this.range, "ui-slider-range-" + options.range);
                    }
                } else {
                    if (this.range) {
                        this.range.remove();
                    }
                    this.range = null;
                }
            },
            _setupEvents: function() {
                this._off(this.handles);
                this._on(this.handles, this._handleEvents);
                this._hoverable(this.handles);
                this._focusable(this.handles);
            },
            _destroy: function() {
                this.handles.remove();
                if (this.range) {
                    this.range.remove();
                }
                this._mouseDestroy();
            },
            _mouseCapture: function(event) {
                var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle, that = this, o = this.options;
                if (o.disabled) {
                    return false;
                }
                this.elementSize = {
                    width: this.element.outerWidth(),
                    height: this.element.outerHeight()
                };
                this.elementOffset = this.element.offset();
                position = {
                    x: event.pageX,
                    y: event.pageY
                };
                normValue = this._normValueFromMouse(position);
                distance = this._valueMax() - this._valueMin() + 1;
                this.handles.each(function(i) {
                    var thisDistance = Math.abs(normValue - that.values(i));
                    if (distance > thisDistance || distance === thisDistance && (i === that._lastChangedValue || that.values(i) === o.min)) {
                        distance = thisDistance;
                        closestHandle = $(this);
                        index = i;
                    }
                });
                allowed = this._start(event, index);
                if (allowed === false) {
                    return false;
                }
                this._mouseSliding = true;
                this._handleIndex = index;
                this._addClass(closestHandle, null, "ui-state-active");
                closestHandle.trigger("focus");
                offset = closestHandle.offset();
                mouseOverHandle = !$(event.target).parents().addBack().is(".ui-slider-handle");
                this._clickOffset = mouseOverHandle ? {
                    left: 0,
                    top: 0
                } : {
                    left: event.pageX - offset.left - closestHandle.width() / 2,
                    top: event.pageY - offset.top - closestHandle.height() / 2 - (parseInt(closestHandle.css("borderTopWidth"), 10) || 0) - (parseInt(closestHandle.css("borderBottomWidth"), 10) || 0) + (parseInt(closestHandle.css("marginTop"), 10) || 0)
                };
                if (!this.handles.hasClass("ui-state-hover")) {
                    this._slide(event, index, normValue);
                }
                this._animateOff = true;
                return true;
            },
            _mouseStart: function() {
                return true;
            },
            _mouseDrag: function(event) {
                var position = {
                    x: event.pageX,
                    y: event.pageY
                }, normValue = this._normValueFromMouse(position);
                this._slide(event, this._handleIndex, normValue);
                return false;
            },
            _mouseStop: function(event) {
                this._removeClass(this.handles, null, "ui-state-active");
                this._mouseSliding = false;
                this._stop(event, this._handleIndex);
                this._change(event, this._handleIndex);
                this._handleIndex = null;
                this._clickOffset = null;
                this._animateOff = false;
                return false;
            },
            _detectOrientation: function() {
                this.orientation = this.options.orientation === "vertical" ? "vertical" : "horizontal";
            },
            _normValueFromMouse: function(position) {
                var pixelTotal, pixelMouse, percentMouse, valueTotal, valueMouse;
                if (this.orientation === "horizontal") {
                    pixelTotal = this.elementSize.width;
                    pixelMouse = position.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0);
                } else {
                    pixelTotal = this.elementSize.height;
                    pixelMouse = position.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0);
                }
                percentMouse = pixelMouse / pixelTotal;
                if (percentMouse > 1) {
                    percentMouse = 1;
                }
                if (percentMouse < 0) {
                    percentMouse = 0;
                }
                if (this.orientation === "vertical") {
                    percentMouse = 1 - percentMouse;
                }
                valueTotal = this._valueMax() - this._valueMin();
                valueMouse = this._valueMin() + percentMouse * valueTotal;
                return this._trimAlignValue(valueMouse);
            },
            _uiHash: function(index, value, values) {
                var uiHash = {
                    handle: this.handles[index],
                    handleIndex: index,
                    value: value !== undefined ? value : this.value()
                };
                if (this._hasMultipleValues()) {
                    uiHash.value = value !== undefined ? value : this.values(index);
                    uiHash.values = values || this.values();
                }
                return uiHash;
            },
            _hasMultipleValues: function() {
                return this.options.values && this.options.values.length;
            },
            _start: function(event, index) {
                return this._trigger("start", event, this._uiHash(index));
            },
            _slide: function(event, index, newVal) {
                var allowed, otherVal, currentValue = this.value(), newValues = this.values();
                if (this._hasMultipleValues()) {
                    otherVal = this.values(index ? 0 : 1);
                    currentValue = this.values(index);
                    if (this.options.values.length === 2 && this.options.range === true) {
                        newVal = index === 0 ? Math.min(otherVal, newVal) : Math.max(otherVal, newVal);
                    }
                    newValues[index] = newVal;
                }
                if (newVal === currentValue) {
                    return;
                }
                allowed = this._trigger("slide", event, this._uiHash(index, newVal, newValues));
                if (allowed === false) {
                    return;
                }
                if (this._hasMultipleValues()) {
                    this.values(index, newVal);
                } else {
                    this.value(newVal);
                }
            },
            _stop: function(event, index) {
                this._trigger("stop", event, this._uiHash(index));
            },
            _change: function(event, index) {
                if (!this._keySliding && !this._mouseSliding) {
                    this._lastChangedValue = index;
                    this._trigger("change", event, this._uiHash(index));
                }
            },
            value: function(newValue) {
                if (arguments.length) {
                    this.options.value = this._trimAlignValue(newValue);
                    this._refreshValue();
                    this._change(null, 0);
                    return;
                }
                return this._value();
            },
            values: function(index, newValue) {
                var vals, newValues, i;
                if (arguments.length > 1) {
                    this.options.values[index] = this._trimAlignValue(newValue);
                    this._refreshValue();
                    this._change(null, index);
                    return;
                }
                if (arguments.length) {
                    if ($.isArray(arguments[0])) {
                        vals = this.options.values;
                        newValues = arguments[0];
                        for (i = 0; i < vals.length; i += 1) {
                            vals[i] = this._trimAlignValue(newValues[i]);
                            this._change(null, i);
                        }
                        this._refreshValue();
                    } else {
                        if (this._hasMultipleValues()) {
                            return this._values(index);
                        } else {
                            return this.value();
                        }
                    }
                } else {
                    return this._values();
                }
            },
            _setOption: function(key, value) {
                var i, valsLength = 0;
                if (key === "range" && this.options.range === true) {
                    if (value === "min") {
                        this.options.value = this._values(0);
                        this.options.values = null;
                    } else if (value === "max") {
                        this.options.value = this._values(this.options.values.length - 1);
                        this.options.values = null;
                    }
                }
                if ($.isArray(this.options.values)) {
                    valsLength = this.options.values.length;
                }
                this._super(key, value);
                switch (key) {
                  case "orientation":
                    this._detectOrientation();
                    this._removeClass("ui-slider-horizontal ui-slider-vertical")._addClass("ui-slider-" + this.orientation);
                    this._refreshValue();
                    if (this.options.range) {
                        this._refreshRange(value);
                    }
                    this.handles.css(value === "horizontal" ? "bottom" : "left", "");
                    break;

                  case "value":
                    this._animateOff = true;
                    this._refreshValue();
                    this._change(null, 0);
                    this._animateOff = false;
                    break;

                  case "values":
                    this._animateOff = true;
                    this._refreshValue();
                    for (i = valsLength - 1; i >= 0; i--) {
                        this._change(null, i);
                    }
                    this._animateOff = false;
                    break;

                  case "step":
                  case "min":
                  case "max":
                    this._animateOff = true;
                    this._calculateNewMax();
                    this._refreshValue();
                    this._animateOff = false;
                    break;

                  case "range":
                    this._animateOff = true;
                    this._refresh();
                    this._animateOff = false;
                    break;
                }
            },
            _setOptionDisabled: function(value) {
                this._super(value);
                this._toggleClass(null, "ui-state-disabled", !!value);
            },
            _value: function() {
                var val = this.options.value;
                val = this._trimAlignValue(val);
                return val;
            },
            _values: function(index) {
                var val, vals, i;
                if (arguments.length) {
                    val = this.options.values[index];
                    val = this._trimAlignValue(val);
                    return val;
                } else if (this._hasMultipleValues()) {
                    vals = this.options.values.slice();
                    for (i = 0; i < vals.length; i += 1) {
                        vals[i] = this._trimAlignValue(vals[i]);
                    }
                    return vals;
                } else {
                    return [];
                }
            },
            _trimAlignValue: function(val) {
                if (val <= this._valueMin()) {
                    return this._valueMin();
                }
                if (val >= this._valueMax()) {
                    return this._valueMax();
                }
                var step = this.options.step > 0 ? this.options.step : 1, valModStep = (val - this._valueMin()) % step, alignValue = val - valModStep;
                if (Math.abs(valModStep) * 2 >= step) {
                    alignValue += valModStep > 0 ? step : -step;
                }
                return parseFloat(alignValue.toFixed(5));
            },
            _calculateNewMax: function() {
                var max = this.options.max, min = this._valueMin(), step = this.options.step, aboveMin = Math.round((max - min) / step) * step;
                max = aboveMin + min;
                if (max > this.options.max) {
                    max -= step;
                }
                this.max = parseFloat(max.toFixed(this._precision()));
            },
            _precision: function() {
                var precision = this._precisionOf(this.options.step);
                if (this.options.min !== null) {
                    precision = Math.max(precision, this._precisionOf(this.options.min));
                }
                return precision;
            },
            _precisionOf: function(num) {
                var str = num.toString(), decimal = str.indexOf(".");
                return decimal === -1 ? 0 : str.length - decimal - 1;
            },
            _valueMin: function() {
                return this.options.min;
            },
            _valueMax: function() {
                return this.max;
            },
            _refreshRange: function(orientation) {
                if (orientation === "vertical") {
                    this.range.css({
                        width: "",
                        left: ""
                    });
                }
                if (orientation === "horizontal") {
                    this.range.css({
                        height: "",
                        bottom: ""
                    });
                }
            },
            _refreshValue: function() {
                var lastValPercent, valPercent, value, valueMin, valueMax, oRange = this.options.range, o = this.options, that = this, animate = !this._animateOff ? o.animate : false, _set = {};
                if (this._hasMultipleValues()) {
                    this.handles.each(function(i) {
                        valPercent = (that.values(i) - that._valueMin()) / (that._valueMax() - that._valueMin()) * 100;
                        _set[that.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
                        $(this).stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);
                        if (that.options.range === true) {
                            if (that.orientation === "horizontal") {
                                if (i === 0) {
                                    that.range.stop(1, 1)[animate ? "animate" : "css"]({
                                        left: valPercent + "%"
                                    }, o.animate);
                                }
                                if (i === 1) {
                                    that.range[animate ? "animate" : "css"]({
                                        width: valPercent - lastValPercent + "%"
                                    }, {
                                        queue: false,
                                        duration: o.animate
                                    });
                                }
                            } else {
                                if (i === 0) {
                                    that.range.stop(1, 1)[animate ? "animate" : "css"]({
                                        bottom: valPercent + "%"
                                    }, o.animate);
                                }
                                if (i === 1) {
                                    that.range[animate ? "animate" : "css"]({
                                        height: valPercent - lastValPercent + "%"
                                    }, {
                                        queue: false,
                                        duration: o.animate
                                    });
                                }
                            }
                        }
                        lastValPercent = valPercent;
                    });
                } else {
                    value = this.value();
                    valueMin = this._valueMin();
                    valueMax = this._valueMax();
                    valPercent = valueMax !== valueMin ? (value - valueMin) / (valueMax - valueMin) * 100 : 0;
                    _set[this.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
                    this.handle.stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);
                    if (oRange === "min" && this.orientation === "horizontal") {
                        this.range.stop(1, 1)[animate ? "animate" : "css"]({
                            width: valPercent + "%"
                        }, o.animate);
                    }
                    if (oRange === "max" && this.orientation === "horizontal") {
                        this.range.stop(1, 1)[animate ? "animate" : "css"]({
                            width: 100 - valPercent + "%"
                        }, o.animate);
                    }
                    if (oRange === "min" && this.orientation === "vertical") {
                        this.range.stop(1, 1)[animate ? "animate" : "css"]({
                            height: valPercent + "%"
                        }, o.animate);
                    }
                    if (oRange === "max" && this.orientation === "vertical") {
                        this.range.stop(1, 1)[animate ? "animate" : "css"]({
                            height: 100 - valPercent + "%"
                        }, o.animate);
                    }
                }
            },
            _handleEvents: {
                keydown: function(event) {
                    var allowed, curVal, newVal, step, index = $(event.target).data("ui-slider-handle-index");
                    switch (event.keyCode) {
                      case $.ui.keyCode.HOME:
                      case $.ui.keyCode.END:
                      case $.ui.keyCode.PAGE_UP:
                      case $.ui.keyCode.PAGE_DOWN:
                      case $.ui.keyCode.UP:
                      case $.ui.keyCode.RIGHT:
                      case $.ui.keyCode.DOWN:
                      case $.ui.keyCode.LEFT:
                        event.preventDefault();
                        if (!this._keySliding) {
                            this._keySliding = true;
                            this._addClass($(event.target), null, "ui-state-active");
                            allowed = this._start(event, index);
                            if (allowed === false) {
                                return;
                            }
                        }
                        break;
                    }
                    step = this.options.step;
                    if (this._hasMultipleValues()) {
                        curVal = newVal = this.values(index);
                    } else {
                        curVal = newVal = this.value();
                    }
                    switch (event.keyCode) {
                      case $.ui.keyCode.HOME:
                        newVal = this._valueMin();
                        break;

                      case $.ui.keyCode.END:
                        newVal = this._valueMax();
                        break;

                      case $.ui.keyCode.PAGE_UP:
                        newVal = this._trimAlignValue(curVal + (this._valueMax() - this._valueMin()) / this.numPages);
                        break;

                      case $.ui.keyCode.PAGE_DOWN:
                        newVal = this._trimAlignValue(curVal - (this._valueMax() - this._valueMin()) / this.numPages);
                        break;

                      case $.ui.keyCode.UP:
                      case $.ui.keyCode.RIGHT:
                        if (curVal === this._valueMax()) {
                            return;
                        }
                        newVal = this._trimAlignValue(curVal + step);
                        break;

                      case $.ui.keyCode.DOWN:
                      case $.ui.keyCode.LEFT:
                        if (curVal === this._valueMin()) {
                            return;
                        }
                        newVal = this._trimAlignValue(curVal - step);
                        break;
                    }
                    this._slide(event, index, newVal);
                },
                keyup: function(event) {
                    var index = $(event.target).data("ui-slider-handle-index");
                    if (this._keySliding) {
                        this._keySliding = false;
                        this._stop(event, index);
                        this._change(event, index);
                        this._removeClass($(event.target), null, "ui-state-active");
                    }
                }
            }
        });
    });
    define("skylark-jqueryui/widgets/sortable", [ "skylark-jquery", "./mouse", "../data", "../ie", "../scroll-parent", "../version", "../widget" ], function($) {
        return $.widget("ui.sortable", $.ui.mouse, {
            version: "@VERSION",
            widgetEventPrefix: "sort",
            ready: false,
            options: {
                appendTo: "parent",
                axis: false,
                connectWith: false,
                containment: false,
                cursor: "auto",
                cursorAt: false,
                dropOnEmpty: true,
                forcePlaceholderSize: false,
                forceHelperSize: false,
                grid: false,
                handle: false,
                helper: "original",
                items: "> *",
                opacity: false,
                placeholder: false,
                revert: false,
                scroll: true,
                scrollSensitivity: 20,
                scrollSpeed: 20,
                scope: "default",
                tolerance: "intersect",
                zIndex: 1e3,
                activate: null,
                beforeStop: null,
                change: null,
                deactivate: null,
                out: null,
                over: null,
                receive: null,
                remove: null,
                sort: null,
                start: null,
                stop: null,
                update: null
            },
            _isOverAxis: function(x, reference, size) {
                return x >= reference && x < reference + size;
            },
            _isFloating: function(item) {
                return /left|right/.test(item.css("float")) || /inline|table-cell/.test(item.css("display"));
            },
            _create: function() {
                this.containerCache = {};
                this._addClass("ui-sortable");
                this.refresh();
                this.offset = this.element.offset();
                this._mouseInit();
                this._setHandleClassName();
                this.ready = true;
            },
            _setOption: function(key, value) {
                this._super(key, value);
                if (key === "handle") {
                    this._setHandleClassName();
                }
            },
            _setHandleClassName: function() {
                var that = this;
                this._removeClass(this.element.find(".ui-sortable-handle"), "ui-sortable-handle");
                $.each(this.items, function() {
                    that._addClass(this.instance.options.handle ? this.item.find(this.instance.options.handle) : this.item, "ui-sortable-handle");
                });
            },
            _destroy: function() {
                this._mouseDestroy();
                for (var i = this.items.length - 1; i >= 0; i--) {
                    this.items[i].item.removeData(this.widgetName + "-item");
                }
                return this;
            },
            _mouseCapture: function(event, overrideHandle) {
                var currentItem = null, validHandle = false, that = this;
                if (this.reverting) {
                    return false;
                }
                if (this.options.disabled || this.options.type === "static") {
                    return false;
                }
                this._refreshItems(event);
                $(event.target).parents().each(function() {
                    if ($.data(this, that.widgetName + "-item") === that) {
                        currentItem = $(this);
                        return false;
                    }
                });
                if ($.data(event.target, that.widgetName + "-item") === that) {
                    currentItem = $(event.target);
                }
                if (!currentItem) {
                    return false;
                }
                if (this.options.handle && !overrideHandle) {
                    $(this.options.handle, currentItem).find("*").addBack().each(function() {
                        if (this === event.target) {
                            validHandle = true;
                        }
                    });
                    if (!validHandle) {
                        return false;
                    }
                }
                this.currentItem = currentItem;
                this._removeCurrentsFromItems();
                return true;
            },
            _mouseStart: function(event, overrideHandle, noActivation) {
                var i, body, o = this.options;
                this.currentContainer = this;
                this.refreshPositions();
                this.appendTo = $(o.appendTo !== "parent" ? o.appendTo : this.currentItem.parent());
                this.helper = this._createHelper(event);
                this._cacheHelperProportions();
                this._cacheMargins();
                this.offset = this.currentItem.offset();
                this.offset = {
                    top: this.offset.top - this.margins.top,
                    left: this.offset.left - this.margins.left
                };
                $.extend(this.offset, {
                    click: {
                        left: event.pageX - this.offset.left,
                        top: event.pageY - this.offset.top
                    },
                    relative: this._getRelativeOffset()
                });
                this.helper.css("position", "absolute");
                this.cssPosition = this.helper.css("position");
                o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt);
                this.domPosition = {
                    prev: this.currentItem.prev()[0],
                    parent: this.currentItem.parent()[0]
                };
                if (this.helper[0] !== this.currentItem[0]) {
                    this.currentItem.hide();
                }
                this._createPlaceholder();
                this.scrollParent = this.placeholder.scrollParent();
                $.extend(this.offset, {
                    parent: this._getParentOffset()
                });
                if (o.containment) {
                    this._setContainment();
                }
                if (o.cursor && o.cursor !== "auto") {
                    body = this.document.find("body");
                    this.storedCursor = body.css("cursor");
                    body.css("cursor", o.cursor);
                    this.storedStylesheet = $("<style>*{ cursor: " + o.cursor + " !important; }</style>").appendTo(body);
                }
                if (o.zIndex) {
                    if (this.helper.css("zIndex")) {
                        this._storedZIndex = this.helper.css("zIndex");
                    }
                    this.helper.css("zIndex", o.zIndex);
                }
                if (o.opacity) {
                    if (this.helper.css("opacity")) {
                        this._storedOpacity = this.helper.css("opacity");
                    }
                    this.helper.css("opacity", o.opacity);
                }
                if (this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {
                    this.overflowOffset = this.scrollParent.offset();
                }
                this._trigger("start", event, this._uiHash());
                if (!this._preserveHelperProportions) {
                    this._cacheHelperProportions();
                }
                if (!noActivation) {
                    for (i = this.containers.length - 1; i >= 0; i--) {
                        this.containers[i]._trigger("activate", event, this._uiHash(this));
                    }
                }
                if ($.ui.ddmanager) {
                    $.ui.ddmanager.current = this;
                }
                if ($.ui.ddmanager && !o.dropBehaviour) {
                    $.ui.ddmanager.prepareOffsets(this, event);
                }
                this.dragging = true;
                this._addClass(this.helper, "ui-sortable-helper");
                if (!this.helper.parent().is(this.appendTo)) {
                    this.helper.detach().appendTo(this.appendTo);
                    this.offset.parent = this._getParentOffset();
                }
                this.position = this.originalPosition = this._generatePosition(event);
                this.originalPageX = event.pageX;
                this.originalPageY = event.pageY;
                this.lastPositionAbs = this.positionAbs = this._convertPositionTo("absolute");
                this._mouseDrag(event);
                return true;
            },
            _scroll: function(event) {
                var o = this.options, scrolled = false;
                if (this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {
                    if (this.overflowOffset.top + this.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity) {
                        this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
                    } else if (event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
                        this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
                    }
                    if (this.overflowOffset.left + this.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity) {
                        this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
                    } else if (event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
                        this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
                    }
                } else {
                    if (event.pageY - this.document.scrollTop() < o.scrollSensitivity) {
                        scrolled = this.document.scrollTop(this.document.scrollTop() - o.scrollSpeed);
                    } else if (this.window.height() - (event.pageY - this.document.scrollTop()) < o.scrollSensitivity) {
                        scrolled = this.document.scrollTop(this.document.scrollTop() + o.scrollSpeed);
                    }
                    if (event.pageX - this.document.scrollLeft() < o.scrollSensitivity) {
                        scrolled = this.document.scrollLeft(this.document.scrollLeft() - o.scrollSpeed);
                    } else if (this.window.width() - (event.pageX - this.document.scrollLeft()) < o.scrollSensitivity) {
                        scrolled = this.document.scrollLeft(this.document.scrollLeft() + o.scrollSpeed);
                    }
                }
                return scrolled;
            },
            _mouseDrag: function(event) {
                var i, item, itemElement, intersection, o = this.options;
                this.position = this._generatePosition(event);
                this.positionAbs = this._convertPositionTo("absolute");
                if (!this.options.axis || this.options.axis !== "y") {
                    this.helper[0].style.left = this.position.left + "px";
                }
                if (!this.options.axis || this.options.axis !== "x") {
                    this.helper[0].style.top = this.position.top + "px";
                }
                this._contactContainers(event);
                if (this.innermostContainer !== null) {
                    if (o.scroll) {
                        if (this._scroll(event) !== false) {
                            this._refreshItemPositions(true);
                            if ($.ui.ddmanager && !o.dropBehaviour) {
                                $.ui.ddmanager.prepareOffsets(this, event);
                            }
                        }
                    }
                    this.dragDirection = {
                        vertical: this._getDragVerticalDirection(),
                        horizontal: this._getDragHorizontalDirection()
                    };
                    for (i = this.items.length - 1; i >= 0; i--) {
                        item = this.items[i];
                        itemElement = item.item[0];
                        intersection = this._intersectsWithPointer(item);
                        if (!intersection) {
                            continue;
                        }
                        if (item.instance !== this.currentContainer) {
                            continue;
                        }
                        if (itemElement !== this.currentItem[0] && this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement && !$.contains(this.placeholder[0], itemElement) && (this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)) {
                            this.direction = intersection === 1 ? "down" : "up";
                            if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
                                this._rearrange(event, item);
                            } else {
                                break;
                            }
                            this._trigger("change", event, this._uiHash());
                            break;
                        }
                    }
                }
                if ($.ui.ddmanager) {
                    $.ui.ddmanager.drag(this, event);
                }
                this._trigger("sort", event, this._uiHash());
                this.lastPositionAbs = this.positionAbs;
                return false;
            },
            _mouseStop: function(event, noPropagation) {
                if (!event) {
                    return;
                }
                if ($.ui.ddmanager && !this.options.dropBehaviour) {
                    $.ui.ddmanager.drop(this, event);
                }
                if (this.options.revert) {
                    var that = this, cur = this.placeholder.offset(), axis = this.options.axis, animation = {};
                    if (!axis || axis === "x") {
                        animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft);
                    }
                    if (!axis || axis === "y") {
                        animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop);
                    }
                    this.reverting = true;
                    $(this.helper).animate(animation, parseInt(this.options.revert, 10) || 500, function() {
                        that._clear(event);
                    });
                } else {
                    this._clear(event, noPropagation);
                }
                return false;
            },
            cancel: function() {
                if (this.dragging) {
                    this._mouseUp(new $.Event("mouseup", {
                        target: null
                    }));
                    if (this.options.helper === "original") {
                        this.currentItem.css(this._storedCSS);
                        this._removeClass(this.currentItem, "ui-sortable-helper");
                    } else {
                        this.currentItem.show();
                    }
                    for (var i = this.containers.length - 1; i >= 0; i--) {
                        this.containers[i]._trigger("deactivate", null, this._uiHash(this));
                        if (this.containers[i].containerCache.over) {
                            this.containers[i]._trigger("out", null, this._uiHash(this));
                            this.containers[i].containerCache.over = 0;
                        }
                    }
                }
                if (this.placeholder) {
                    if (this.placeholder[0].parentNode) {
                        this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
                    }
                    if (this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
                        this.helper.remove();
                    }
                    $.extend(this, {
                        helper: null,
                        dragging: false,
                        reverting: false,
                        _noFinalSort: null
                    });
                    if (this.domPosition.prev) {
                        $(this.domPosition.prev).after(this.currentItem);
                    } else {
                        $(this.domPosition.parent).prepend(this.currentItem);
                    }
                }
                return this;
            },
            serialize: function(o) {
                var items = this._getItemsAsjQuery(o && o.connected), str = [];
                o = o || {};
                $(items).each(function() {
                    var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || /(.+)[\-=_](.+)/);
                    if (res) {
                        str.push((o.key || res[1] + "[]") + "=" + (o.key && o.expression ? res[1] : res[2]));
                    }
                });
                if (!str.length && o.key) {
                    str.push(o.key + "=");
                }
                return str.join("&");
            },
            toArray: function(o) {
                var items = this._getItemsAsjQuery(o && o.connected), ret = [];
                o = o || {};
                items.each(function() {
                    ret.push($(o.item || this).attr(o.attribute || "id") || "");
                });
                return ret;
            },
            _intersectsWith: function(item) {
                var x1 = this.positionAbs.left, x2 = x1 + this.helperProportions.width, y1 = this.positionAbs.top, y2 = y1 + this.helperProportions.height, l = item.left, r = l + item.width, t = item.top, b = t + item.height, dyClick = this.offset.click.top, dxClick = this.offset.click.left, isOverElementHeight = this.options.axis === "x" || y1 + dyClick > t && y1 + dyClick < b, isOverElementWidth = this.options.axis === "y" || x1 + dxClick > l && x1 + dxClick < r, isOverElement = isOverElementHeight && isOverElementWidth;
                if (this.options.tolerance === "pointer" || this.options.forcePointerForContainers || this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"]) {
                    return isOverElement;
                } else {
                    return l < x1 + this.helperProportions.width / 2 && x2 - this.helperProportions.width / 2 < r && t < y1 + this.helperProportions.height / 2 && y2 - this.helperProportions.height / 2 < b;
                }
            },
            _intersectsWithPointer: function(item) {
                var verticalDirection, horizontalDirection, isOverElementHeight = this.options.axis === "x" || this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height), isOverElementWidth = this.options.axis === "y" || this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width), isOverElement = isOverElementHeight && isOverElementWidth;
                if (!isOverElement) {
                    return false;
                }
                verticalDirection = this.dragDirection.vertical;
                horizontalDirection = this.dragDirection.horizontal;
                return this.floating ? horizontalDirection === "right" || verticalDirection === "down" ? 2 : 1 : verticalDirection && (verticalDirection === "down" ? 2 : 1);
            },
            _intersectsWithSides: function(item) {
                var isOverBottomHalf = this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + item.height / 2, item.height), isOverRightHalf = this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + item.width / 2, item.width), verticalDirection = this.dragDirection.vertical, horizontalDirection = this.dragDirection.horizontal;
                if (this.floating && horizontalDirection) {
                    return horizontalDirection === "right" && isOverRightHalf || horizontalDirection === "left" && !isOverRightHalf;
                } else {
                    return verticalDirection && (verticalDirection === "down" && isOverBottomHalf || verticalDirection === "up" && !isOverBottomHalf);
                }
            },
            _getDragVerticalDirection: function() {
                var delta = this.positionAbs.top - this.lastPositionAbs.top;
                return delta !== 0 && (delta > 0 ? "down" : "up");
            },
            _getDragHorizontalDirection: function() {
                var delta = this.positionAbs.left - this.lastPositionAbs.left;
                return delta !== 0 && (delta > 0 ? "right" : "left");
            },
            refresh: function(event) {
                this._refreshItems(event);
                this._setHandleClassName();
                this.refreshPositions();
                return this;
            },
            _connectWith: function() {
                var options = this.options;
                return options.connectWith.constructor === String ? [ options.connectWith ] : options.connectWith;
            },
            _getItemsAsjQuery: function(connected) {
                var i, j, cur, inst, items = [], queries = [], connectWith = this._connectWith();
                if (connectWith && connected) {
                    for (i = connectWith.length - 1; i >= 0; i--) {
                        cur = $(connectWith[i], this.document[0]);
                        for (j = cur.length - 1; j >= 0; j--) {
                            inst = $.data(cur[j], this.widgetFullName);
                            if (inst && inst !== this && !inst.options.disabled) {
                                queries.push([ $.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst ]);
                            }
                        }
                    }
                }
                queries.push([ $.isFunction(this.options.items) ? this.options.items.call(this.element, null, {
                    options: this.options,
                    item: this.currentItem
                }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this ]);
                function addItems() {
                    items.push(this);
                }
                for (i = queries.length - 1; i >= 0; i--) {
                    queries[i][0].each(addItems);
                }
                return $(items);
            },
            _removeCurrentsFromItems: function() {
                var list = this.currentItem.find(":data(" + this.widgetName + "-item)");
                this.items = $.grep(this.items, function(item) {
                    for (var j = 0; j < list.length; j++) {
                        if (list[j] === item.item[0]) {
                            return false;
                        }
                    }
                    return true;
                });
            },
            _refreshItems: function(event) {
                this.items = [];
                this.containers = [ this ];
                var i, j, cur, inst, targetData, _queries, item, queriesLength, items = this.items, queries = [ [ $.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, {
                    item: this.currentItem
                }) : $(this.options.items, this.element), this ] ], connectWith = this._connectWith();
                if (connectWith && this.ready) {
                    for (i = connectWith.length - 1; i >= 0; i--) {
                        cur = $(connectWith[i], this.document[0]);
                        for (j = cur.length - 1; j >= 0; j--) {
                            inst = $.data(cur[j], this.widgetFullName);
                            if (inst && inst !== this && !inst.options.disabled) {
                                queries.push([ $.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, {
                                    item: this.currentItem
                                }) : $(inst.options.items, inst.element), inst ]);
                                this.containers.push(inst);
                            }
                        }
                    }
                }
                for (i = queries.length - 1; i >= 0; i--) {
                    targetData = queries[i][1];
                    _queries = queries[i][0];
                    for (j = 0, queriesLength = _queries.length; j < queriesLength; j++) {
                        item = $(_queries[j]);
                        item.data(this.widgetName + "-item", targetData);
                        items.push({
                            item: item,
                            instance: targetData,
                            width: 0,
                            height: 0,
                            left: 0,
                            top: 0
                        });
                    }
                }
            },
            _refreshItemPositions: function(fast) {
                var i, item, t, p;
                for (i = this.items.length - 1; i >= 0; i--) {
                    item = this.items[i];
                    if (this.currentContainer && item.instance !== this.currentContainer && item.item[0] !== this.currentItem[0]) {
                        continue;
                    }
                    t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;
                    if (!fast) {
                        item.width = t.outerWidth();
                        item.height = t.outerHeight();
                    }
                    p = t.offset();
                    item.left = p.left;
                    item.top = p.top;
                }
            },
            refreshPositions: function(fast) {
                this.floating = this.items.length ? this.options.axis === "x" || this._isFloating(this.items[0].item) : false;
                if (this.innermostContainer !== null) {
                    this._refreshItemPositions(fast);
                }
                var i, p;
                if (this.options.custom && this.options.custom.refreshContainers) {
                    this.options.custom.refreshContainers.call(this);
                } else {
                    for (i = this.containers.length - 1; i >= 0; i--) {
                        p = this.containers[i].element.offset();
                        this.containers[i].containerCache.left = p.left;
                        this.containers[i].containerCache.top = p.top;
                        this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
                        this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
                    }
                }
                return this;
            },
            _createPlaceholder: function(that) {
                that = that || this;
                var className, nodeName, o = that.options;
                if (!o.placeholder || o.placeholder.constructor === String) {
                    className = o.placeholder;
                    nodeName = that.currentItem[0].nodeName.toLowerCase();
                    o.placeholder = {
                        element: function() {
                            var element = $("<" + nodeName + ">", that.document[0]);
                            that._addClass(element, "ui-sortable-placeholder", className || that.currentItem[0].className)._removeClass(element, "ui-sortable-helper");
                            if (nodeName === "tbody") {
                                that._createTrPlaceholder(that.currentItem.find("tr").eq(0), $("<tr>", that.document[0]).appendTo(element));
                            } else if (nodeName === "tr") {
                                that._createTrPlaceholder(that.currentItem, element);
                            } else if (nodeName === "img") {
                                element.attr("src", that.currentItem.attr("src"));
                            }
                            if (!className) {
                                element.css("visibility", "hidden");
                            }
                            return element;
                        },
                        update: function(container, p) {
                            if (className && !o.forcePlaceholderSize) {
                                return;
                            }
                            if (!p.height() || o.forcePlaceholderSize && (nodeName === "tbody" || nodeName === "tr")) {
                                p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop") || 0, 10) - parseInt(that.currentItem.css("paddingBottom") || 0, 10));
                            }
                            if (!p.width()) {
                                p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft") || 0, 10) - parseInt(that.currentItem.css("paddingRight") || 0, 10));
                            }
                        }
                    };
                }
                that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));
                that.currentItem.after(that.placeholder);
                o.placeholder.update(that, that.placeholder);
            },
            _createTrPlaceholder: function(sourceTr, targetTr) {
                var that = this;
                sourceTr.children().each(function() {
                    $("<td>&#160;</td>", that.document[0]).attr("colspan", $(this).attr("colspan") || 1).appendTo(targetTr);
                });
            },
            _contactContainers: function(event) {
                var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom, floating, axis, innermostContainer = null, innermostIndex = null;
                for (i = this.containers.length - 1; i >= 0; i--) {
                    if ($.contains(this.currentItem[0], this.containers[i].element[0])) {
                        continue;
                    }
                    if (this._intersectsWith(this.containers[i].containerCache)) {
                        if (innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
                            continue;
                        }
                        innermostContainer = this.containers[i];
                        innermostIndex = i;
                    } else {
                        if (this.containers[i].containerCache.over) {
                            this.containers[i]._trigger("out", event, this._uiHash(this));
                            this.containers[i].containerCache.over = 0;
                        }
                    }
                }
                this.innermostContainer = innermostContainer;
                if (!innermostContainer) {
                    return;
                }
                if (this.containers.length === 1) {
                    if (!this.containers[innermostIndex].containerCache.over) {
                        this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                        this.containers[innermostIndex].containerCache.over = 1;
                    }
                } else {
                    dist = 1e4;
                    itemWithLeastDistance = null;
                    floating = innermostContainer.floating || this._isFloating(this.currentItem);
                    posProperty = floating ? "left" : "top";
                    sizeProperty = floating ? "width" : "height";
                    axis = floating ? "pageX" : "pageY";
                    for (j = this.items.length - 1; j >= 0; j--) {
                        if (!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
                            continue;
                        }
                        if (this.items[j].item[0] === this.currentItem[0]) {
                            continue;
                        }
                        cur = this.items[j].item.offset()[posProperty];
                        nearBottom = false;
                        if (event[axis] - cur > this.items[j][sizeProperty] / 2) {
                            nearBottom = true;
                        }
                        if (Math.abs(event[axis] - cur) < dist) {
                            dist = Math.abs(event[axis] - cur);
                            itemWithLeastDistance = this.items[j];
                            this.direction = nearBottom ? "up" : "down";
                        }
                    }
                    if (!itemWithLeastDistance && !this.options.dropOnEmpty) {
                        return;
                    }
                    if (this.currentContainer === this.containers[innermostIndex]) {
                        if (!this.currentContainer.containerCache.over) {
                            this.containers[innermostIndex]._trigger("over", event, this._uiHash());
                            this.currentContainer.containerCache.over = 1;
                        }
                        return;
                    }
                    itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
                    this._trigger("change", event, this._uiHash());
                    this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
                    this.currentContainer = this.containers[innermostIndex];
                    this.options.placeholder.update(this.currentContainer, this.placeholder);
                    this.scrollParent = this.placeholder.scrollParent();
                    if (this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {
                        this.overflowOffset = this.scrollParent.offset();
                    }
                    this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                    this.containers[innermostIndex].containerCache.over = 1;
                }
            },
            _createHelper: function(event) {
                var o = this.options, helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [ event, this.currentItem ])) : o.helper === "clone" ? this.currentItem.clone() : this.currentItem;
                if (!helper.parents("body").length) {
                    this.appendTo[0].appendChild(helper[0]);
                }
                if (helper[0] === this.currentItem[0]) {
                    this._storedCSS = {
                        width: this.currentItem[0].style.width,
                        height: this.currentItem[0].style.height,
                        position: this.currentItem.css("position"),
                        top: this.currentItem.css("top"),
                        left: this.currentItem.css("left")
                    };
                }
                if (!helper[0].style.width || o.forceHelperSize) {
                    helper.width(this.currentItem.width());
                }
                if (!helper[0].style.height || o.forceHelperSize) {
                    helper.height(this.currentItem.height());
                }
                return helper;
            },
            _adjustOffsetFromHelper: function(obj) {
                if (typeof obj === "string") {
                    obj = obj.split(" ");
                }
                if ($.isArray(obj)) {
                    obj = {
                        left: +obj[0],
                        top: +obj[1] || 0
                    };
                }
                if ("left" in obj) {
                    this.offset.click.left = obj.left + this.margins.left;
                }
                if ("right" in obj) {
                    this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
                }
                if ("top" in obj) {
                    this.offset.click.top = obj.top + this.margins.top;
                }
                if ("bottom" in obj) {
                    this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
                }
            },
            _getParentOffset: function() {
                this.offsetParent = this.helper.offsetParent();
                var po = this.offsetParent.offset();
                if (this.cssPosition === "absolute" && this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) {
                    po.left += this.scrollParent.scrollLeft();
                    po.top += this.scrollParent.scrollTop();
                }
                if (this.offsetParent[0] === this.document[0].body || this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie) {
                    po = {
                        top: 0,
                        left: 0
                    };
                }
                return {
                    top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                    left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
                };
            },
            _getRelativeOffset: function() {
                if (this.cssPosition === "relative") {
                    var p = this.currentItem.position();
                    return {
                        top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
                        left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
                    };
                } else {
                    return {
                        top: 0,
                        left: 0
                    };
                }
            },
            _cacheMargins: function() {
                this.margins = {
                    left: parseInt(this.currentItem.css("marginLeft"), 10) || 0,
                    top: parseInt(this.currentItem.css("marginTop"), 10) || 0
                };
            },
            _cacheHelperProportions: function() {
                this.helperProportions = {
                    width: this.helper.outerWidth(),
                    height: this.helper.outerHeight()
                };
            },
            _setContainment: function() {
                var ce, co, over, o = this.options;
                if (o.containment === "parent") {
                    o.containment = this.helper[0].parentNode;
                }
                if (o.containment === "document" || o.containment === "window") {
                    this.containment = [ 0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, o.containment === "document" ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left, (o.containment === "document" ? this.document.height() || document.body.parentNode.scrollHeight : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top ];
                }
                if (!/^(document|window|parent)$/.test(o.containment)) {
                    ce = $(o.containment)[0];
                    co = $(o.containment).offset();
                    over = $(ce).css("overflow") !== "hidden";
                    this.containment = [ co.left + (parseInt($(ce).css("borderLeftWidth"), 10) || 0) + (parseInt($(ce).css("paddingLeft"), 10) || 0) - this.margins.left, co.top + (parseInt($(ce).css("borderTopWidth"), 10) || 0) + (parseInt($(ce).css("paddingTop"), 10) || 0) - this.margins.top, co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"), 10) || 0) - (parseInt($(ce).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"), 10) || 0) - (parseInt($(ce).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top ];
                }
            },
            _convertPositionTo: function(d, pos) {
                if (!pos) {
                    pos = this.position;
                }
                var mod = d === "absolute" ? 1 : -1, scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
                return {
                    top: pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - (this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()) * mod,
                    left: pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - (this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod
                };
            },
            _generatePosition: function(event) {
                var top, left, o = this.options, pageX = event.pageX, pageY = event.pageY, scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
                if (this.cssPosition === "relative" && !(this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0])) {
                    this.offset.relative = this._getRelativeOffset();
                }
                if (this.originalPosition) {
                    if (this.containment) {
                        if (event.pageX - this.offset.click.left < this.containment[0]) {
                            pageX = this.containment[0] + this.offset.click.left;
                        }
                        if (event.pageY - this.offset.click.top < this.containment[1]) {
                            pageY = this.containment[1] + this.offset.click.top;
                        }
                        if (event.pageX - this.offset.click.left > this.containment[2]) {
                            pageX = this.containment[2] + this.offset.click.left;
                        }
                        if (event.pageY - this.offset.click.top > this.containment[3]) {
                            pageY = this.containment[3] + this.offset.click.top;
                        }
                    }
                    if (o.grid) {
                        top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
                        pageY = this.containment ? top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3] ? top : top - this.offset.click.top >= this.containment[1] ? top - o.grid[1] : top + o.grid[1] : top;
                        left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
                        pageX = this.containment ? left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2] ? left : left - this.offset.click.left >= this.containment[0] ? left - o.grid[0] : left + o.grid[0] : left;
                    }
                }
                return {
                    top: pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + (this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()),
                    left: pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + (this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft())
                };
            },
            _rearrange: function(event, i, a, hardRefresh) {
                a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], this.direction === "down" ? i.item[0] : i.item[0].nextSibling);
                this.counter = this.counter ? ++this.counter : 1;
                var counter = this.counter;
                this._delay(function() {
                    if (counter === this.counter) {
                        this.refreshPositions(!hardRefresh);
                    }
                });
            },
            _clear: function(event, noPropagation) {
                this.reverting = false;
                var i, delayedTriggers = [];
                if (!this._noFinalSort && this.currentItem.parent().length) {
                    this.placeholder.before(this.currentItem);
                }
                this._noFinalSort = null;
                if (this.helper[0] === this.currentItem[0]) {
                    for (i in this._storedCSS) {
                        if (this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
                            this._storedCSS[i] = "";
                        }
                    }
                    this.currentItem.css(this._storedCSS);
                    this._removeClass(this.currentItem, "ui-sortable-helper");
                } else {
                    this.currentItem.show();
                }
                if (this.fromOutside && !noPropagation) {
                    delayedTriggers.push(function(event) {
                        this._trigger("receive", event, this._uiHash(this.fromOutside));
                    });
                }
                if ((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
                    delayedTriggers.push(function(event) {
                        this._trigger("update", event, this._uiHash());
                    });
                }
                if (this !== this.currentContainer) {
                    if (!noPropagation) {
                        delayedTriggers.push(function(event) {
                            this._trigger("remove", event, this._uiHash());
                        });
                        delayedTriggers.push(function(c) {
                            return function(event) {
                                c._trigger("receive", event, this._uiHash(this));
                            };
                        }.call(this, this.currentContainer));
                        delayedTriggers.push(function(c) {
                            return function(event) {
                                c._trigger("update", event, this._uiHash(this));
                            };
                        }.call(this, this.currentContainer));
                    }
                }
                function delayEvent(type, instance, container) {
                    return function(event) {
                        container._trigger(type, event, instance._uiHash(instance));
                    };
                }
                for (i = this.containers.length - 1; i >= 0; i--) {
                    if (!noPropagation) {
                        delayedTriggers.push(delayEvent("deactivate", this, this.containers[i]));
                    }
                    if (this.containers[i].containerCache.over) {
                        delayedTriggers.push(delayEvent("out", this, this.containers[i]));
                        this.containers[i].containerCache.over = 0;
                    }
                }
                if (this.storedCursor) {
                    this.document.find("body").css("cursor", this.storedCursor);
                    this.storedStylesheet.remove();
                }
                if (this._storedOpacity) {
                    this.helper.css("opacity", this._storedOpacity);
                }
                if (this._storedZIndex) {
                    this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
                }
                this.dragging = false;
                if (!noPropagation) {
                    this._trigger("beforeStop", event, this._uiHash());
                }
                this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
                if (!this.cancelHelperRemoval) {
                    if (this.helper[0] !== this.currentItem[0]) {
                        this.helper.remove();
                    }
                    this.helper = null;
                }
                if (!noPropagation) {
                    for (i = 0; i < delayedTriggers.length; i++) {
                        delayedTriggers[i].call(this, event);
                    }
                    this._trigger("stop", event, this._uiHash());
                }
                this.fromOutside = false;
                return !this.cancelHelperRemoval;
            },
            _trigger: function() {
                if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
                    this.cancel();
                }
            },
            _uiHash: function(_inst) {
                var inst = _inst || this;
                return {
                    helper: inst.helper,
                    placeholder: inst.placeholder || $([]),
                    position: inst.position,
                    originalPosition: inst.originalPosition,
                    offset: inst.positionAbs,
                    item: inst.currentItem,
                    sender: _inst ? _inst.element : null
                };
            }
        });
    });
    define("skylark-jqueryui/widgets/spinner", [ "skylark-jquery", "./button", "../version", "../keycode", "../safe-active-element", "../widget" ], function($) {
        function spinnerModifier(fn) {
            return function() {
                var previous = this.element.val();
                fn.apply(this, arguments);
                this._refresh();
                if (previous !== this.element.val()) {
                    this._trigger("change");
                }
            };
        }
        $.widget("ui.spinner", {
            version: "@VERSION",
            defaultElement: "<input>",
            widgetEventPrefix: "spin",
            options: {
                classes: {
                    "ui-spinner": "ui-corner-all",
                    "ui-spinner-down": "ui-corner-br",
                    "ui-spinner-up": "ui-corner-tr"
                },
                culture: null,
                icons: {
                    down: "ui-icon-triangle-1-s",
                    up: "ui-icon-triangle-1-n"
                },
                incremental: true,
                max: null,
                min: null,
                numberFormat: null,
                page: 10,
                step: 1,
                change: null,
                spin: null,
                start: null,
                stop: null
            },
            _create: function() {
                this._setOption("max", this.options.max);
                this._setOption("min", this.options.min);
                this._setOption("step", this.options.step);
                if (this.value() !== "") {
                    this._value(this.element.val(), true);
                }
                this._draw();
                this._on(this._events);
                this._refresh();
                this._on(this.window, {
                    beforeunload: function() {
                        this.element.removeAttr("autocomplete");
                    }
                });
            },
            _getCreateOptions: function() {
                var options = this._super();
                var element = this.element;
                $.each([ "min", "max", "step" ], function(i, option) {
                    var value = element.attr(option);
                    if (value != null && value.length) {
                        options[option] = value;
                    }
                });
                return options;
            },
            _events: {
                keydown: function(event) {
                    if (this._start(event) && this._keydown(event)) {
                        event.preventDefault();
                    }
                },
                keyup: "_stop",
                focus: function() {
                    this.previous = this.element.val();
                },
                blur: function(event) {
                    if (this.cancelBlur) {
                        delete this.cancelBlur;
                        return;
                    }
                    this._stop();
                    this._refresh();
                    if (this.previous !== this.element.val()) {
                        this._trigger("change", event);
                    }
                },
                mousewheel: function(event, delta) {
                    var activeElement = $.ui.safeActiveElement(this.document[0]);
                    var isActive = this.element[0] === activeElement;
                    if (!isActive || !delta) {
                        return;
                    }
                    if (!this.spinning && !this._start(event)) {
                        return false;
                    }
                    this._spin((delta > 0 ? 1 : -1) * this.options.step, event);
                    clearTimeout(this.mousewheelTimer);
                    this.mousewheelTimer = this._delay(function() {
                        if (this.spinning) {
                            this._stop(event);
                        }
                    }, 100);
                    event.preventDefault();
                },
                "mousedown .ui-spinner-button": function(event) {
                    var previous;
                    previous = this.element[0] === $.ui.safeActiveElement(this.document[0]) ? this.previous : this.element.val();
                    function checkFocus() {
                        var isActive = this.element[0] === $.ui.safeActiveElement(this.document[0]);
                        if (!isActive) {
                            this.element.trigger("focus");
                            this.previous = previous;
                            this._delay(function() {
                                this.previous = previous;
                            });
                        }
                    }
                    event.preventDefault();
                    checkFocus.call(this);
                    this.cancelBlur = true;
                    this._delay(function() {
                        delete this.cancelBlur;
                        checkFocus.call(this);
                    });
                    if (this._start(event) === false) {
                        return;
                    }
                    this._repeat(null, $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, event);
                },
                "mouseup .ui-spinner-button": "_stop",
                "mouseenter .ui-spinner-button": function(event) {
                    if (!$(event.currentTarget).hasClass("ui-state-active")) {
                        return;
                    }
                    if (this._start(event) === false) {
                        return false;
                    }
                    this._repeat(null, $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, event);
                },
                "mouseleave .ui-spinner-button": "_stop"
            },
            _enhance: function() {
                this.uiSpinner = this.element.attr("autocomplete", "off").wrap("<span>").parent().append("<a></a><a></a>");
            },
            _draw: function() {
                this._enhance();
                this._addClass(this.uiSpinner, "ui-spinner", "ui-widget ui-widget-content");
                this._addClass("ui-spinner-input");
                this.element.attr("role", "spinbutton");
                this.buttons = this.uiSpinner.children("a").attr("tabIndex", -1).attr("aria-hidden", true).button({
                    classes: {
                        "ui-button": ""
                    }
                });
                this._removeClass(this.buttons, "ui-corner-all");
                this._addClass(this.buttons.first(), "ui-spinner-button ui-spinner-up");
                this._addClass(this.buttons.last(), "ui-spinner-button ui-spinner-down");
                this.buttons.first().button({
                    icon: this.options.icons.up,
                    showLabel: false
                });
                this.buttons.last().button({
                    icon: this.options.icons.down,
                    showLabel: false
                });
                if (this.buttons.height() > Math.ceil(this.uiSpinner.height() * .5) && this.uiSpinner.height() > 0) {
                    this.uiSpinner.height(this.uiSpinner.height());
                }
            },
            _keydown: function(event) {
                var options = this.options, keyCode = $.ui.keyCode;
                switch (event.keyCode) {
                  case keyCode.UP:
                    this._repeat(null, 1, event);
                    return true;

                  case keyCode.DOWN:
                    this._repeat(null, -1, event);
                    return true;

                  case keyCode.PAGE_UP:
                    this._repeat(null, options.page, event);
                    return true;

                  case keyCode.PAGE_DOWN:
                    this._repeat(null, -options.page, event);
                    return true;
                }
                return false;
            },
            _start: function(event) {
                if (!this.spinning && this._trigger("start", event) === false) {
                    return false;
                }
                if (!this.counter) {
                    this.counter = 1;
                }
                this.spinning = true;
                return true;
            },
            _repeat: function(i, steps, event) {
                i = i || 500;
                clearTimeout(this.timer);
                this.timer = this._delay(function() {
                    this._repeat(40, steps, event);
                }, i);
                this._spin(steps * this.options.step, event);
            },
            _spin: function(step, event) {
                var value = this.value() || 0;
                if (!this.counter) {
                    this.counter = 1;
                }
                value = this._adjustValue(value + step * this._increment(this.counter));
                if (!this.spinning || this._trigger("spin", event, {
                    value: value
                }) !== false) {
                    this._value(value);
                    this.counter++;
                }
            },
            _increment: function(i) {
                var incremental = this.options.incremental;
                if (incremental) {
                    return $.isFunction(incremental) ? incremental(i) : Math.floor(i * i * i / 5e4 - i * i / 500 + 17 * i / 200 + 1);
                }
                return 1;
            },
            _precision: function() {
                var precision = this._precisionOf(this.options.step);
                if (this.options.min !== null) {
                    precision = Math.max(precision, this._precisionOf(this.options.min));
                }
                return precision;
            },
            _precisionOf: function(num) {
                var str = num.toString(), decimal = str.indexOf(".");
                return decimal === -1 ? 0 : str.length - decimal - 1;
            },
            _adjustValue: function(value) {
                var base, aboveMin, options = this.options;
                base = options.min !== null ? options.min : 0;
                aboveMin = value - base;
                aboveMin = Math.round(aboveMin / options.step) * options.step;
                value = base + aboveMin;
                value = parseFloat(value.toFixed(this._precision()));
                if (options.max !== null && value > options.max) {
                    return options.max;
                }
                if (options.min !== null && value < options.min) {
                    return options.min;
                }
                return value;
            },
            _stop: function(event) {
                if (!this.spinning) {
                    return;
                }
                clearTimeout(this.timer);
                clearTimeout(this.mousewheelTimer);
                this.counter = 0;
                this.spinning = false;
                this._trigger("stop", event);
            },
            _setOption: function(key, value) {
                var prevValue, first, last;
                if (key === "culture" || key === "numberFormat") {
                    prevValue = this._parse(this.element.val());
                    this.options[key] = value;
                    this.element.val(this._format(prevValue));
                    return;
                }
                if (key === "max" || key === "min" || key === "step") {
                    if (typeof value === "string") {
                        value = this._parse(value);
                    }
                }
                if (key === "icons") {
                    first = this.buttons.first().find(".ui-icon");
                    this._removeClass(first, null, this.options.icons.up);
                    this._addClass(first, null, value.up);
                    last = this.buttons.last().find(".ui-icon");
                    this._removeClass(last, null, this.options.icons.down);
                    this._addClass(last, null, value.down);
                }
                this._super(key, value);
            },
            _setOptionDisabled: function(value) {
                this._super(value);
                this._toggleClass(this.uiSpinner, null, "ui-state-disabled", !!value);
                this.element.prop("disabled", !!value);
                this.buttons.button(value ? "disable" : "enable");
            },
            _setOptions: spinnerModifier(function(options) {
                this._super(options);
            }),
            _parse: function(val) {
                if (typeof val === "string" && val !== "") {
                    val = window.Globalize && this.options.numberFormat ? Globalize.parseFloat(val, 10, this.options.culture) : +val;
                }
                return val === "" || isNaN(val) ? null : val;
            },
            _format: function(value) {
                if (value === "") {
                    return "";
                }
                return window.Globalize && this.options.numberFormat ? Globalize.format(value, this.options.numberFormat, this.options.culture) : value;
            },
            _refresh: function() {
                this.element.attr({
                    "aria-valuemin": this.options.min,
                    "aria-valuemax": this.options.max,
                    "aria-valuenow": this._parse(this.element.val())
                });
            },
            isValid: function() {
                var value = this.value();
                if (value === null) {
                    return false;
                }
                return value === this._adjustValue(value);
            },
            _value: function(value, allowAny) {
                var parsed;
                if (value !== "") {
                    parsed = this._parse(value);
                    if (parsed !== null) {
                        if (!allowAny) {
                            parsed = this._adjustValue(parsed);
                        }
                        value = this._format(parsed);
                    }
                }
                this.element.val(value);
                this._refresh();
            },
            _destroy: function() {
                this.element.prop("disabled", false).removeAttr("autocomplete role aria-valuemin aria-valuemax aria-valuenow");
                this.uiSpinner.replaceWith(this.element);
            },
            stepUp: spinnerModifier(function(steps) {
                this._stepUp(steps);
            }),
            _stepUp: function(steps) {
                if (this._start()) {
                    this._spin((steps || 1) * this.options.step);
                    this._stop();
                }
            },
            stepDown: spinnerModifier(function(steps) {
                this._stepDown(steps);
            }),
            _stepDown: function(steps) {
                if (this._start()) {
                    this._spin((steps || 1) * -this.options.step);
                    this._stop();
                }
            },
            pageUp: spinnerModifier(function(pages) {
                this._stepUp((pages || 1) * this.options.page);
            }),
            pageDown: spinnerModifier(function(pages) {
                this._stepDown((pages || 1) * this.options.page);
            }),
            value: function(newVal) {
                if (!arguments.length) {
                    return this._parse(this.element.val());
                }
                spinnerModifier(this._value).call(this, newVal);
            },
            widget: function() {
                return this.uiSpinner;
            }
        });
        if ($.uiBackCompat !== false) {
            $.widget("ui.spinner", $.ui.spinner, {
                _enhance: function() {
                    this.uiSpinner = this.element.attr("autocomplete", "off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml());
                },
                _uiSpinnerHtml: function() {
                    return "<span>";
                },
                _buttonHtml: function() {
                    return "<a></a><a></a>";
                }
            });
        }
        return $.ui.spinner;
    });
    define("skylark-jqueryui/widgets/tabs", [ "skylark-jquery", "../escape-selector", "../keycode", "../safe-active-element", "../unique-id", "../version", "../widget" ], function($) {
        $.widget("ui.tabs", {
            version: "@VERSION",
            delay: 300,
            options: {
                active: null,
                classes: {
                    "ui-tabs": "ui-corner-all",
                    "ui-tabs-nav": "ui-corner-all",
                    "ui-tabs-panel": "ui-corner-bottom",
                    "ui-tabs-tab": "ui-corner-top"
                },
                collapsible: false,
                event: "click",
                heightStyle: "content",
                hide: null,
                show: null,
                activate: null,
                beforeActivate: null,
                beforeLoad: null,
                load: null
            },
            _isLocal: function() {
                var rhash = /#.*$/;
                return function(anchor) {
                    var anchorUrl, locationUrl;
                    anchorUrl = anchor.href.replace(rhash, "");
                    locationUrl = location.href.replace(rhash, "");
                    try {
                        anchorUrl = decodeURIComponent(anchorUrl);
                    } catch (error) {}
                    try {
                        locationUrl = decodeURIComponent(locationUrl);
                    } catch (error) {}
                    return anchor.hash.length > 1 && anchorUrl === locationUrl;
                };
            }(),
            _create: function() {
                var that = this, options = this.options;
                this.running = false;
                this._addClass("ui-tabs", "ui-widget ui-widget-content");
                this._toggleClass("ui-tabs-collapsible", null, options.collapsible);
                this._processTabs();
                options.active = this._initialActive();
                if ($.isArray(options.disabled)) {
                    options.disabled = $.uniqueSort(options.disabled.concat($.map(this.tabs.filter(".ui-state-disabled"), function(li) {
                        return that.tabs.index(li);
                    }))).sort();
                }
                if (this.options.active !== false && this.anchors.length) {
                    this.active = this._findActive(options.active);
                } else {
                    this.active = $();
                }
                this._refresh();
                if (this.active.length) {
                    this.load(options.active);
                }
            },
            _initialActive: function() {
                var active = this.options.active, collapsible = this.options.collapsible, locationHash = location.hash.substring(1);
                if (active === null) {
                    if (locationHash) {
                        this.tabs.each(function(i, tab) {
                            if ($(tab).attr("aria-controls") === locationHash) {
                                active = i;
                                return false;
                            }
                        });
                    }
                    if (active === null) {
                        active = this.tabs.index(this.tabs.filter(".ui-tabs-active"));
                    }
                    if (active === null || active === -1) {
                        active = this.tabs.length ? 0 : false;
                    }
                }
                if (active !== false) {
                    active = this.tabs.index(this.tabs.eq(active));
                    if (active === -1) {
                        active = collapsible ? false : 0;
                    }
                }
                if (!collapsible && active === false && this.anchors.length) {
                    active = 0;
                }
                return active;
            },
            _getCreateEventData: function() {
                return {
                    tab: this.active,
                    panel: !this.active.length ? $() : this._getPanelForTab(this.active)
                };
            },
            _tabKeydown: function(event) {
                var focusedTab = $($.ui.safeActiveElement(this.document[0])).closest("li"), selectedIndex = this.tabs.index(focusedTab), goingForward = true;
                if (this._handlePageNav(event)) {
                    return;
                }
                switch (event.keyCode) {
                  case $.ui.keyCode.RIGHT:
                  case $.ui.keyCode.DOWN:
                    selectedIndex++;
                    break;

                  case $.ui.keyCode.UP:
                  case $.ui.keyCode.LEFT:
                    goingForward = false;
                    selectedIndex--;
                    break;

                  case $.ui.keyCode.END:
                    selectedIndex = this.anchors.length - 1;
                    break;

                  case $.ui.keyCode.HOME:
                    selectedIndex = 0;
                    break;

                  case $.ui.keyCode.SPACE:
                    event.preventDefault();
                    clearTimeout(this.activating);
                    this._activate(selectedIndex);
                    return;

                  case $.ui.keyCode.ENTER:
                    event.preventDefault();
                    clearTimeout(this.activating);
                    this._activate(selectedIndex === this.options.active ? false : selectedIndex);
                    return;

                  default:
                    return;
                }
                event.preventDefault();
                clearTimeout(this.activating);
                selectedIndex = this._focusNextTab(selectedIndex, goingForward);
                if (!event.ctrlKey && !event.metaKey) {
                    focusedTab.attr("aria-selected", "false");
                    this.tabs.eq(selectedIndex).attr("aria-selected", "true");
                    this.activating = this._delay(function() {
                        this.option("active", selectedIndex);
                    }, this.delay);
                }
            },
            _panelKeydown: function(event) {
                if (this._handlePageNav(event)) {
                    return;
                }
                if (event.ctrlKey && event.keyCode === $.ui.keyCode.UP) {
                    event.preventDefault();
                    this.active.trigger("focus");
                }
            },
            _handlePageNav: function(event) {
                if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP) {
                    this._activate(this._focusNextTab(this.options.active - 1, false));
                    return true;
                }
                if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN) {
                    this._activate(this._focusNextTab(this.options.active + 1, true));
                    return true;
                }
            },
            _findNextTab: function(index, goingForward) {
                var lastTabIndex = this.tabs.length - 1;
                function constrain() {
                    if (index > lastTabIndex) {
                        index = 0;
                    }
                    if (index < 0) {
                        index = lastTabIndex;
                    }
                    return index;
                }
                while ($.inArray(constrain(), this.options.disabled) !== -1) {
                    index = goingForward ? index + 1 : index - 1;
                }
                return index;
            },
            _focusNextTab: function(index, goingForward) {
                index = this._findNextTab(index, goingForward);
                this.tabs.eq(index).trigger("focus");
                return index;
            },
            _setOption: function(key, value) {
                if (key === "active") {
                    this._activate(value);
                    return;
                }
                this._super(key, value);
                if (key === "collapsible") {
                    this._toggleClass("ui-tabs-collapsible", null, value);
                    if (!value && this.options.active === false) {
                        this._activate(0);
                    }
                }
                if (key === "event") {
                    this._setupEvents(value);
                }
                if (key === "heightStyle") {
                    this._setupHeightStyle(value);
                }
            },
            _sanitizeSelector: function(hash) {
                return hash ? hash.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&") : "";
            },
            refresh: function() {
                var options = this.options, lis = this.tablist.children(":has(a[href])");
                options.disabled = $.map(lis.filter(".ui-state-disabled"), function(tab) {
                    return lis.index(tab);
                });
                this._processTabs();
                if (options.active === false || !this.anchors.length) {
                    options.active = false;
                    this.active = $();
                } else if (this.active.length && !$.contains(this.tablist[0], this.active[0])) {
                    if (this.tabs.length === options.disabled.length) {
                        options.active = false;
                        this.active = $();
                    } else {
                        this._activate(this._findNextTab(Math.max(0, options.active - 1), false));
                    }
                } else {
                    options.active = this.tabs.index(this.active);
                }
                this._refresh();
            },
            _refresh: function() {
                this._setOptionDisabled(this.options.disabled);
                this._setupEvents(this.options.event);
                this._setupHeightStyle(this.options.heightStyle);
                this.tabs.not(this.active).attr({
                    "aria-selected": "false",
                    "aria-expanded": "false",
                    tabIndex: -1
                });
                this.panels.not(this._getPanelForTab(this.active)).hide().attr({
                    "aria-hidden": "true"
                });
                if (!this.active.length) {
                    this.tabs.eq(0).attr("tabIndex", 0);
                } else {
                    this.active.attr({
                        "aria-selected": "true",
                        "aria-expanded": "true",
                        tabIndex: 0
                    });
                    this._addClass(this.active, "ui-tabs-active", "ui-state-active");
                    this._getPanelForTab(this.active).show().attr({
                        "aria-hidden": "false"
                    });
                }
            },
            _processTabs: function() {
                var that = this, prevTabs = this.tabs, prevAnchors = this.anchors, prevPanels = this.panels;
                this.tablist = this._getList().attr("role", "tablist");
                this._addClass(this.tablist, "ui-tabs-nav", "ui-helper-reset ui-helper-clearfix ui-widget-header");
                this.tablist.on("mousedown" + this.eventNamespace, "> li", function(event) {
                    if ($(this).is(".ui-state-disabled")) {
                        event.preventDefault();
                    }
                }).on("focus" + this.eventNamespace, ".ui-tabs-anchor", function() {
                    if ($(this).closest("li").is(".ui-state-disabled")) {
                        this.blur();
                    }
                });
                this.tabs = this.tablist.find("> li:has(a[href])").attr({
                    role: "tab",
                    tabIndex: -1
                });
                this._addClass(this.tabs, "ui-tabs-tab", "ui-state-default");
                this.anchors = this.tabs.map(function() {
                    return $("a", this)[0];
                }).attr({
                    tabIndex: -1
                });
                this._addClass(this.anchors, "ui-tabs-anchor");
                this.panels = $();
                this.anchors.each(function(i, anchor) {
                    var selector, panel, panelId, anchorId = $(anchor).uniqueId().attr("id"), tab = $(anchor).closest("li"), originalAriaControls = tab.attr("aria-controls");
                    if (that._isLocal(anchor)) {
                        selector = anchor.hash;
                        panelId = selector.substring(1);
                        panel = that.element.find(that._sanitizeSelector(selector));
                    } else {
                        panelId = tab.attr("aria-controls") || $({}).uniqueId()[0].id;
                        selector = "#" + panelId;
                        panel = that.element.find(selector);
                        if (!panel.length) {
                            panel = that._createPanel(panelId);
                            panel.insertAfter(that.panels[i - 1] || that.tablist);
                        }
                        panel.attr("aria-live", "polite");
                    }
                    if (panel.length) {
                        that.panels = that.panels.add(panel);
                    }
                    if (originalAriaControls) {
                        tab.data("ui-tabs-aria-controls", originalAriaControls);
                    }
                    tab.attr({
                        "aria-controls": panelId,
                        "aria-labelledby": anchorId
                    });
                    panel.attr("aria-labelledby", anchorId);
                });
                this.panels.attr("role", "tabpanel");
                this._addClass(this.panels, "ui-tabs-panel", "ui-widget-content");
                if (prevTabs) {
                    this._off(prevTabs.not(this.tabs));
                    this._off(prevAnchors.not(this.anchors));
                    this._off(prevPanels.not(this.panels));
                }
            },
            _getList: function() {
                return this.tablist || this.element.find("ol, ul").eq(0);
            },
            _createPanel: function(id) {
                return $("<div>").attr("id", id).data("ui-tabs-destroy", true);
            },
            _setOptionDisabled: function(disabled) {
                var currentItem, li, i;
                if ($.isArray(disabled)) {
                    if (!disabled.length) {
                        disabled = false;
                    } else if (disabled.length === this.anchors.length) {
                        disabled = true;
                    }
                }
                for (i = 0; li = this.tabs[i]; i++) {
                    currentItem = $(li);
                    if (disabled === true || $.inArray(i, disabled) !== -1) {
                        currentItem.attr("aria-disabled", "true");
                        this._addClass(currentItem, null, "ui-state-disabled");
                    } else {
                        currentItem.removeAttr("aria-disabled");
                        this._removeClass(currentItem, null, "ui-state-disabled");
                    }
                }
                this.options.disabled = disabled;
                this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, disabled === true);
            },
            _setupEvents: function(event) {
                var events = {};
                if (event) {
                    $.each(event.split(" "), function(index, eventName) {
                        events[eventName] = "_eventHandler";
                    });
                }
                this._off(this.anchors.add(this.tabs).add(this.panels));
                this._on(true, this.anchors, {
                    click: function(event) {
                        event.preventDefault();
                    }
                });
                this._on(this.anchors, events);
                this._on(this.tabs, {
                    keydown: "_tabKeydown"
                });
                this._on(this.panels, {
                    keydown: "_panelKeydown"
                });
                this._focusable(this.tabs);
                this._hoverable(this.tabs);
            },
            _setupHeightStyle: function(heightStyle) {
                var maxHeight, parent = this.element.parent();
                if (heightStyle === "fill") {
                    maxHeight = parent.height();
                    maxHeight -= this.element.outerHeight() - this.element.height();
                    this.element.siblings(":visible").each(function() {
                        var elem = $(this), position = elem.css("position");
                        if (position === "absolute" || position === "fixed") {
                            return;
                        }
                        maxHeight -= elem.outerHeight(true);
                    });
                    this.element.children().not(this.panels).each(function() {
                        maxHeight -= $(this).outerHeight(true);
                    });
                    this.panels.each(function() {
                        $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));
                    }).css("overflow", "auto");
                } else if (heightStyle === "auto") {
                    maxHeight = 0;
                    this.panels.each(function() {
                        maxHeight = Math.max(maxHeight, $(this).height("").height());
                    }).height(maxHeight);
                }
            },
            _eventHandler: function(event) {
                var options = this.options, active = this.active, anchor = $(event.currentTarget), tab = anchor.closest("li"), clickedIsActive = tab[0] === active[0], collapsing = clickedIsActive && options.collapsible, toShow = collapsing ? $() : this._getPanelForTab(tab), toHide = !active.length ? $() : this._getPanelForTab(active), eventData = {
                    oldTab: active,
                    oldPanel: toHide,
                    newTab: collapsing ? $() : tab,
                    newPanel: toShow
                };
                event.preventDefault();
                if (tab.hasClass("ui-state-disabled") || tab.hasClass("ui-tabs-loading") || this.running || clickedIsActive && !options.collapsible || this._trigger("beforeActivate", event, eventData) === false) {
                    return;
                }
                options.active = collapsing ? false : this.tabs.index(tab);
                this.active = clickedIsActive ? $() : tab;
                if (this.xhr) {
                    this.xhr.abort();
                }
                if (!toHide.length && !toShow.length) {
                    $.error("jQuery UI Tabs: Mismatching fragment identifier.");
                }
                if (toShow.length) {
                    this.load(this.tabs.index(tab), event);
                }
                this._toggle(event, eventData);
            },
            _toggle: function(event, eventData) {
                var that = this, toShow = eventData.newPanel, toHide = eventData.oldPanel;
                this.running = true;
                function complete() {
                    that.running = false;
                    that._trigger("activate", event, eventData);
                }
                function show() {
                    that._addClass(eventData.newTab.closest("li"), "ui-tabs-active", "ui-state-active");
                    if (toShow.length && that.options.show) {
                        that._show(toShow, that.options.show, complete);
                    } else {
                        toShow.show();
                        complete();
                    }
                }
                if (toHide.length && this.options.hide) {
                    this._hide(toHide, this.options.hide, function() {
                        that._removeClass(eventData.oldTab.closest("li"), "ui-tabs-active", "ui-state-active");
                        show();
                    });
                } else {
                    this._removeClass(eventData.oldTab.closest("li"), "ui-tabs-active", "ui-state-active");
                    toHide.hide();
                    show();
                }
                toHide.attr("aria-hidden", "true");
                eventData.oldTab.attr({
                    "aria-selected": "false",
                    "aria-expanded": "false"
                });
                if (toShow.length && toHide.length) {
                    eventData.oldTab.attr("tabIndex", -1);
                } else if (toShow.length) {
                    this.tabs.filter(function() {
                        return $(this).attr("tabIndex") === 0;
                    }).attr("tabIndex", -1);
                }
                toShow.attr("aria-hidden", "false");
                eventData.newTab.attr({
                    "aria-selected": "true",
                    "aria-expanded": "true",
                    tabIndex: 0
                });
            },
            _activate: function(index) {
                var anchor, active = this._findActive(index);
                if (active[0] === this.active[0]) {
                    return;
                }
                if (!active.length) {
                    active = this.active;
                }
                anchor = active.find(".ui-tabs-anchor")[0];
                this._eventHandler({
                    target: anchor,
                    currentTarget: anchor,
                    preventDefault: $.noop
                });
            },
            _findActive: function(index) {
                return index === false ? $() : this.tabs.eq(index);
            },
            _getIndex: function(index) {
                if (typeof index === "string") {
                    index = this.anchors.index(this.anchors.filter("[href$='" + $.ui.escapeSelector(index) + "']"));
                }
                return index;
            },
            _destroy: function() {
                if (this.xhr) {
                    this.xhr.abort();
                }
                this.tablist.removeAttr("role").off(this.eventNamespace);
                this.anchors.removeAttr("role tabIndex").removeUniqueId();
                this.tabs.add(this.panels).each(function() {
                    if ($.data(this, "ui-tabs-destroy")) {
                        $(this).remove();
                    } else {
                        $(this).removeAttr("role tabIndex " + "aria-live aria-busy aria-selected aria-labelledby aria-hidden aria-expanded");
                    }
                });
                this.tabs.each(function() {
                    var li = $(this), prev = li.data("ui-tabs-aria-controls");
                    if (prev) {
                        li.attr("aria-controls", prev).removeData("ui-tabs-aria-controls");
                    } else {
                        li.removeAttr("aria-controls");
                    }
                });
                this.panels.show();
                if (this.options.heightStyle !== "content") {
                    this.panels.css("height", "");
                }
            },
            enable: function(index) {
                var disabled = this.options.disabled;
                if (disabled === false) {
                    return;
                }
                if (index === undefined) {
                    disabled = false;
                } else {
                    index = this._getIndex(index);
                    if ($.isArray(disabled)) {
                        disabled = $.map(disabled, function(num) {
                            return num !== index ? num : null;
                        });
                    } else {
                        disabled = $.map(this.tabs, function(li, num) {
                            return num !== index ? num : null;
                        });
                    }
                }
                this._setOptionDisabled(disabled);
            },
            disable: function(index) {
                var disabled = this.options.disabled;
                if (disabled === true) {
                    return;
                }
                if (index === undefined) {
                    disabled = true;
                } else {
                    index = this._getIndex(index);
                    if ($.inArray(index, disabled) !== -1) {
                        return;
                    }
                    if ($.isArray(disabled)) {
                        disabled = $.merge([ index ], disabled).sort();
                    } else {
                        disabled = [ index ];
                    }
                }
                this._setOptionDisabled(disabled);
            },
            load: function(index, event) {
                index = this._getIndex(index);
                var that = this, tab = this.tabs.eq(index), anchor = tab.find(".ui-tabs-anchor"), panel = this._getPanelForTab(tab), eventData = {
                    tab: tab,
                    panel: panel
                }, complete = function(jqXHR, status) {
                    if (status === "abort") {
                        that.panels.stop(false, true);
                    }
                    that._removeClass(tab, "ui-tabs-loading");
                    panel.removeAttr("aria-busy");
                    if (jqXHR === that.xhr) {
                        delete that.xhr;
                    }
                };
                if (this._isLocal(anchor[0])) {
                    return;
                }
                this.xhr = $.ajax(this._ajaxSettings(anchor, event, eventData));
                if (this.xhr && this.xhr.statusText !== "canceled") {
                    this._addClass(tab, "ui-tabs-loading");
                    panel.attr("aria-busy", "true");
                    this.xhr.done(function(response, status, jqXHR) {
                        setTimeout(function() {
                            panel.html(response);
                            that._trigger("load", event, eventData);
                            complete(jqXHR, status);
                        }, 1);
                    }).fail(function(jqXHR, status) {
                        setTimeout(function() {
                            complete(jqXHR, status);
                        }, 1);
                    });
                }
            },
            _ajaxSettings: function(anchor, event, eventData) {
                var that = this;
                return {
                    url: anchor.attr("href").replace(/#.*$/, ""),
                    beforeSend: function(jqXHR, settings) {
                        return that._trigger("beforeLoad", event, $.extend({
                            jqXHR: jqXHR,
                            ajaxSettings: settings
                        }, eventData));
                    }
                };
            },
            _getPanelForTab: function(tab) {
                var id = $(tab).attr("aria-controls");
                return this.element.find(this._sanitizeSelector("#" + id));
            }
        });
        if ($.uiBackCompat !== false) {
            $.widget("ui.tabs", $.ui.tabs, {
                _processTabs: function() {
                    this._superApply(arguments);
                    this._addClass(this.tabs, "ui-tab");
                }
            });
        }
        return $.ui.tabs;
    });
    define("skylark-jqueryui/widgets/tooltip", [ "skylark-jquery", "../keycode", "../position", "../unique-id", "../version", "../widget" ], function($) {
        $.widget("ui.tooltip", {
            version: "@VERSION",
            options: {
                classes: {
                    "ui-tooltip": "ui-corner-all ui-widget-shadow"
                },
                content: function() {
                    var title = $(this).attr("title") || "";
                    return $("<a>").text(title).html();
                },
                hide: true,
                items: "[title]:not([disabled])",
                position: {
                    my: "left top+15",
                    at: "left bottom",
                    collision: "flipfit flip"
                },
                show: true,
                track: false,
                close: null,
                open: null
            },
            _addDescribedBy: function(elem, id) {
                var describedby = (elem.attr("aria-describedby") || "").split(/\s+/);
                describedby.push(id);
                elem.data("ui-tooltip-id", id).attr("aria-describedby", $.trim(describedby.join(" ")));
            },
            _removeDescribedBy: function(elem) {
                var id = elem.data("ui-tooltip-id"), describedby = (elem.attr("aria-describedby") || "").split(/\s+/), index = $.inArray(id, describedby);
                if (index !== -1) {
                    describedby.splice(index, 1);
                }
                elem.removeData("ui-tooltip-id");
                describedby = $.trim(describedby.join(" "));
                if (describedby) {
                    elem.attr("aria-describedby", describedby);
                } else {
                    elem.removeAttr("aria-describedby");
                }
            },
            _create: function() {
                this._on({
                    mouseover: "open",
                    focusin: "open"
                });
                this.tooltips = {};
                this.parents = {};
                this.liveRegion = $("<div>").attr({
                    role: "log",
                    "aria-live": "assertive",
                    "aria-relevant": "additions"
                }).appendTo(this.document[0].body);
                this._addClass(this.liveRegion, null, "ui-helper-hidden-accessible");
                this.disabledTitles = $([]);
            },
            _setOption: function(key, value) {
                var that = this;
                this._super(key, value);
                if (key === "content") {
                    $.each(this.tooltips, function(id, tooltipData) {
                        that._updateContent(tooltipData.element);
                    });
                }
            },
            _setOptionDisabled: function(value) {
                this[value ? "_disable" : "_enable"]();
            },
            _disable: function() {
                var that = this;
                $.each(this.tooltips, function(id, tooltipData) {
                    var event = $.Event("blur");
                    event.target = event.currentTarget = tooltipData.element[0];
                    that.close(event, true);
                });
                this.disabledTitles = this.disabledTitles.add(this.element.find(this.options.items).addBack().filter(function() {
                    var element = $(this);
                    if (element.is("[title]")) {
                        return element.data("ui-tooltip-title", element.attr("title")).removeAttr("title");
                    }
                }));
            },
            _enable: function() {
                this.disabledTitles.each(function() {
                    var element = $(this);
                    if (element.data("ui-tooltip-title")) {
                        element.attr("title", element.data("ui-tooltip-title"));
                    }
                });
                this.disabledTitles = $([]);
            },
            open: function(event) {
                var that = this, target = $(event ? event.target : this.element).closest(this.options.items);
                if (!target.length || target.data("ui-tooltip-id")) {
                    return;
                }
                if (target.attr("title")) {
                    target.data("ui-tooltip-title", target.attr("title"));
                }
                target.data("ui-tooltip-open", true);
                if (event && event.type === "mouseover") {
                    target.parents().each(function() {
                        var parent = $(this), blurEvent;
                        if (parent.data("ui-tooltip-open")) {
                            blurEvent = $.Event("blur");
                            blurEvent.target = blurEvent.currentTarget = this;
                            that.close(blurEvent, true);
                        }
                        if (parent.attr("title")) {
                            parent.uniqueId();
                            that.parents[this.id] = {
                                element: this,
                                title: parent.attr("title")
                            };
                            parent.attr("title", "");
                        }
                    });
                }
                this._registerCloseHandlers(event, target);
                this._updateContent(target, event);
            },
            _updateContent: function(target, event) {
                var content, contentOption = this.options.content, that = this, eventType = event ? event.type : null;
                if (typeof contentOption === "string" || contentOption.nodeType || contentOption.jquery) {
                    return this._open(event, target, contentOption);
                }
                content = contentOption.call(target[0], function(response) {
                    that._delay(function() {
                        if (!target.data("ui-tooltip-open")) {
                            return;
                        }
                        if (event) {
                            event.type = eventType;
                        }
                        this._open(event, target, response);
                    });
                });
                if (content) {
                    this._open(event, target, content);
                }
            },
            _open: function(event, target, content) {
                var tooltipData, tooltip, delayedShow, a11yContent, positionOption = $.extend({}, this.options.position);
                if (!content) {
                    return;
                }
                tooltipData = this._find(target);
                if (tooltipData) {
                    tooltipData.tooltip.find(".ui-tooltip-content").html(content);
                    return;
                }
                if (target.is("[title]")) {
                    if (event && event.type === "mouseover") {
                        target.attr("title", "");
                    } else {
                        target.removeAttr("title");
                    }
                }
                tooltipData = this._tooltip(target);
                tooltip = tooltipData.tooltip;
                this._addDescribedBy(target, tooltip.attr("id"));
                tooltip.find(".ui-tooltip-content").html(content);
                this.liveRegion.children().hide();
                a11yContent = $("<div>").html(tooltip.find(".ui-tooltip-content").html());
                a11yContent.removeAttr("name").find("[name]").removeAttr("name");
                a11yContent.removeAttr("id").find("[id]").removeAttr("id");
                a11yContent.appendTo(this.liveRegion);
                function position(event) {
                    positionOption.of = event;
                    if (tooltip.is(":hidden")) {
                        return;
                    }
                    tooltip.position(positionOption);
                }
                if (this.options.track && event && /^mouse/.test(event.type)) {
                    this._on(this.document, {
                        mousemove: position
                    });
                    position(event);
                } else {
                    tooltip.position($.extend({
                        of: target
                    }, this.options.position));
                }
                tooltip.hide();
                this._show(tooltip, this.options.show);
                if (this.options.track && this.options.show && this.options.show.delay) {
                    delayedShow = this.delayedShow = setInterval(function() {
                        if (tooltip.is(":visible")) {
                            position(positionOption.of);
                            clearInterval(delayedShow);
                        }
                    }, $.fx.interval);
                }
                this._trigger("open", event, {
                    tooltip: tooltip
                });
            },
            _registerCloseHandlers: function(event, target) {
                var events = {
                    keyup: function(event) {
                        if (event.keyCode === $.ui.keyCode.ESCAPE) {
                            var fakeEvent = $.Event(event);
                            fakeEvent.currentTarget = target[0];
                            this.close(fakeEvent, true);
                        }
                    }
                };
                if (target[0] !== this.element[0]) {
                    events.remove = function() {
                        this._removeTooltip(this._find(target).tooltip);
                    };
                }
                if (!event || event.type === "mouseover") {
                    events.mouseleave = "close";
                }
                if (!event || event.type === "focusin") {
                    events.focusout = "close";
                }
                this._on(true, target, events);
            },
            close: function(event) {
                var tooltip, that = this, target = $(event ? event.currentTarget : this.element), tooltipData = this._find(target);
                if (!tooltipData) {
                    target.removeData("ui-tooltip-open");
                    return;
                }
                tooltip = tooltipData.tooltip;
                if (tooltipData.closing) {
                    return;
                }
                clearInterval(this.delayedShow);
                if (target.data("ui-tooltip-title") && !target.attr("title")) {
                    target.attr("title", target.data("ui-tooltip-title"));
                }
                this._removeDescribedBy(target);
                tooltipData.hiding = true;
                tooltip.stop(true);
                this._hide(tooltip, this.options.hide, function() {
                    that._removeTooltip($(this));
                });
                target.removeData("ui-tooltip-open");
                this._off(target, "mouseleave focusout keyup");
                if (target[0] !== this.element[0]) {
                    this._off(target, "remove");
                }
                this._off(this.document, "mousemove");
                if (event && event.type === "mouseleave") {
                    $.each(this.parents, function(id, parent) {
                        $(parent.element).attr("title", parent.title);
                        delete that.parents[id];
                    });
                }
                tooltipData.closing = true;
                this._trigger("close", event, {
                    tooltip: tooltip
                });
                if (!tooltipData.hiding) {
                    tooltipData.closing = false;
                }
            },
            _tooltip: function(element) {
                var tooltip = $("<div>").attr("role", "tooltip"), content = $("<div>").appendTo(tooltip), id = tooltip.uniqueId().attr("id");
                this._addClass(content, "ui-tooltip-content");
                this._addClass(tooltip, "ui-tooltip", "ui-widget ui-widget-content");
                tooltip.appendTo(this._appendTo(element));
                return this.tooltips[id] = {
                    element: element,
                    tooltip: tooltip
                };
            },
            _find: function(target) {
                var id = target.data("ui-tooltip-id");
                return id ? this.tooltips[id] : null;
            },
            _removeTooltip: function(tooltip) {
                clearInterval(this.delayedShow);
                tooltip.remove();
                delete this.tooltips[tooltip.attr("id")];
            },
            _appendTo: function(target) {
                var element = target.closest(".ui-front, dialog");
                if (!element.length) {
                    element = this.document[0].body;
                }
                return element;
            },
            _destroy: function() {
                var that = this;
                $.each(this.tooltips, function(id, tooltipData) {
                    var event = $.Event("blur"), element = tooltipData.element;
                    event.target = event.currentTarget = element[0];
                    that.close(event, true);
                    $("#" + id).remove();
                    if (element.data("ui-tooltip-title")) {
                        if (!element.attr("title")) {
                            element.attr("title", element.data("ui-tooltip-title"));
                        }
                        element.removeData("ui-tooltip-title");
                    }
                });
                this.liveRegion.remove();
            }
        });
        if ($.uiBackCompat !== false) {
            $.widget("ui.tooltip", $.ui.tooltip, {
                options: {
                    tooltipClass: null
                },
                _tooltip: function() {
                    var tooltipData = this._superApply(arguments);
                    if (this.options.tooltipClass) {
                        tooltipData.tooltip.addClass(this.options.tooltipClass);
                    }
                    return tooltipData;
                }
            });
        }
        return $.ui.tooltip;
    });
    define("skylark-jqueryui/effect", [ "skylark-jquery", "./version" ], function($) {
        var dataSpace = "ui-effects-", dataSpaceStyle = "ui-effects-style", dataSpaceAnimated = "ui-effects-animated", jQuery = $;
        $.effects = {
            effect: {}
        };
        (function(jQuery, undefined) {
            var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor " + "borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor", rplusequals = /^([\-+])=\s*(\d+\.?\d*)/, stringParsers = [ {
                re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                parse: function(execResult) {
                    return [ execResult[1], execResult[2], execResult[3], execResult[4] ];
                }
            }, {
                re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                parse: function(execResult) {
                    return [ execResult[1] * 2.55, execResult[2] * 2.55, execResult[3] * 2.55, execResult[4] ];
                }
            }, {
                re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
                parse: function(execResult) {
                    return [ parseInt(execResult[1], 16), parseInt(execResult[2], 16), parseInt(execResult[3], 16) ];
                }
            }, {
                re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
                parse: function(execResult) {
                    return [ parseInt(execResult[1] + execResult[1], 16), parseInt(execResult[2] + execResult[2], 16), parseInt(execResult[3] + execResult[3], 16) ];
                }
            }, {
                re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                space: "hsla",
                parse: function(execResult) {
                    return [ execResult[1], execResult[2] / 100, execResult[3] / 100, execResult[4] ];
                }
            } ], color = jQuery.Color = function(color, green, blue, alpha) {
                return new jQuery.Color.fn.parse(color, green, blue, alpha);
            }, spaces = {
                rgba: {
                    props: {
                        red: {
                            idx: 0,
                            type: "byte"
                        },
                        green: {
                            idx: 1,
                            type: "byte"
                        },
                        blue: {
                            idx: 2,
                            type: "byte"
                        }
                    }
                },
                hsla: {
                    props: {
                        hue: {
                            idx: 0,
                            type: "degrees"
                        },
                        saturation: {
                            idx: 1,
                            type: "percent"
                        },
                        lightness: {
                            idx: 2,
                            type: "percent"
                        }
                    }
                }
            }, propTypes = {
                "byte": {
                    floor: true,
                    max: 255
                },
                percent: {
                    max: 1
                },
                degrees: {
                    mod: 360,
                    floor: true
                }
            }, support = color.support = {}, supportElem = jQuery("<p>")[0], colors, each = jQuery.each;
            supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
            support.rgba = supportElem.style.backgroundColor.indexOf("rgba") > -1;
            each(spaces, function(spaceName, space) {
                space.cache = "_" + spaceName;
                space.props.alpha = {
                    idx: 3,
                    type: "percent",
                    def: 1
                };
            });
            function clamp(value, prop, allowEmpty) {
                var type = propTypes[prop.type] || {};
                if (value == null) {
                    return allowEmpty || !prop.def ? null : prop.def;
                }
                value = type.floor ? ~~value : parseFloat(value);
                if (isNaN(value)) {
                    return prop.def;
                }
                if (type.mod) {
                    return (value + type.mod) % type.mod;
                }
                return 0 > value ? 0 : type.max < value ? type.max : value;
            }
            function stringParse(string) {
                var inst = color(), rgba = inst._rgba = [];
                string = string.toLowerCase();
                each(stringParsers, function(i, parser) {
                    var parsed, match = parser.re.exec(string), values = match && parser.parse(match), spaceName = parser.space || "rgba";
                    if (values) {
                        parsed = inst[spaceName](values);
                        inst[spaces[spaceName].cache] = parsed[spaces[spaceName].cache];
                        rgba = inst._rgba = parsed._rgba;
                        return false;
                    }
                });
                if (rgba.length) {
                    if (rgba.join() === "0,0,0,0") {
                        jQuery.extend(rgba, colors.transparent);
                    }
                    return inst;
                }
                return colors[string];
            }
            color.fn = jQuery.extend(color.prototype, {
                parse: function(red, green, blue, alpha) {
                    if (red === undefined) {
                        this._rgba = [ null, null, null, null ];
                        return this;
                    }
                    if (red.jquery || red.nodeType) {
                        red = jQuery(red).css(green);
                        green = undefined;
                    }
                    var inst = this, type = jQuery.type(red), rgba = this._rgba = [];
                    if (green !== undefined) {
                        red = [ red, green, blue, alpha ];
                        type = "array";
                    }
                    if (type === "string") {
                        return this.parse(stringParse(red) || colors._default);
                    }
                    if (type === "array") {
                        each(spaces.rgba.props, function(key, prop) {
                            rgba[prop.idx] = clamp(red[prop.idx], prop);
                        });
                        return this;
                    }
                    if (type === "object") {
                        if (red instanceof color) {
                            each(spaces, function(spaceName, space) {
                                if (red[space.cache]) {
                                    inst[space.cache] = red[space.cache].slice();
                                }
                            });
                        } else {
                            each(spaces, function(spaceName, space) {
                                var cache = space.cache;
                                each(space.props, function(key, prop) {
                                    if (!inst[cache] && space.to) {
                                        if (key === "alpha" || red[key] == null) {
                                            return;
                                        }
                                        inst[cache] = space.to(inst._rgba);
                                    }
                                    inst[cache][prop.idx] = clamp(red[key], prop, true);
                                });
                                if (inst[cache] && jQuery.inArray(null, inst[cache].slice(0, 3)) < 0) {
                                    inst[cache][3] = 1;
                                    if (space.from) {
                                        inst._rgba = space.from(inst[cache]);
                                    }
                                }
                            });
                        }
                        return this;
                    }
                },
                is: function(compare) {
                    var is = color(compare), same = true, inst = this;
                    each(spaces, function(_, space) {
                        var localCache, isCache = is[space.cache];
                        if (isCache) {
                            localCache = inst[space.cache] || space.to && space.to(inst._rgba) || [];
                            each(space.props, function(_, prop) {
                                if (isCache[prop.idx] != null) {
                                    same = isCache[prop.idx] === localCache[prop.idx];
                                    return same;
                                }
                            });
                        }
                        return same;
                    });
                    return same;
                },
                _space: function() {
                    var used = [], inst = this;
                    each(spaces, function(spaceName, space) {
                        if (inst[space.cache]) {
                            used.push(spaceName);
                        }
                    });
                    return used.pop();
                },
                transition: function(other, distance) {
                    var end = color(other), spaceName = end._space(), space = spaces[spaceName], startColor = this.alpha() === 0 ? color("transparent") : this, start = startColor[space.cache] || space.to(startColor._rgba), result = start.slice();
                    end = end[space.cache];
                    each(space.props, function(key, prop) {
                        var index = prop.idx, startValue = start[index], endValue = end[index], type = propTypes[prop.type] || {};
                        if (endValue === null) {
                            return;
                        }
                        if (startValue === null) {
                            result[index] = endValue;
                        } else {
                            if (type.mod) {
                                if (endValue - startValue > type.mod / 2) {
                                    startValue += type.mod;
                                } else if (startValue - endValue > type.mod / 2) {
                                    startValue -= type.mod;
                                }
                            }
                            result[index] = clamp((endValue - startValue) * distance + startValue, prop);
                        }
                    });
                    return this[spaceName](result);
                },
                blend: function(opaque) {
                    if (this._rgba[3] === 1) {
                        return this;
                    }
                    var rgb = this._rgba.slice(), a = rgb.pop(), blend = color(opaque)._rgba;
                    return color(jQuery.map(rgb, function(v, i) {
                        return (1 - a) * blend[i] + a * v;
                    }));
                },
                toRgbaString: function() {
                    var prefix = "rgba(", rgba = jQuery.map(this._rgba, function(v, i) {
                        return v == null ? i > 2 ? 1 : 0 : v;
                    });
                    if (rgba[3] === 1) {
                        rgba.pop();
                        prefix = "rgb(";
                    }
                    return prefix + rgba.join() + ")";
                },
                toHslaString: function() {
                    var prefix = "hsla(", hsla = jQuery.map(this.hsla(), function(v, i) {
                        if (v == null) {
                            v = i > 2 ? 1 : 0;
                        }
                        if (i && i < 3) {
                            v = Math.round(v * 100) + "%";
                        }
                        return v;
                    });
                    if (hsla[3] === 1) {
                        hsla.pop();
                        prefix = "hsl(";
                    }
                    return prefix + hsla.join() + ")";
                },
                toHexString: function(includeAlpha) {
                    var rgba = this._rgba.slice(), alpha = rgba.pop();
                    if (includeAlpha) {
                        rgba.push(~~(alpha * 255));
                    }
                    return "#" + jQuery.map(rgba, function(v) {
                        v = (v || 0).toString(16);
                        return v.length === 1 ? "0" + v : v;
                    }).join("");
                },
                toString: function() {
                    return this._rgba[3] === 0 ? "transparent" : this.toRgbaString();
                }
            });
            color.fn.parse.prototype = color.fn;
            function hue2rgb(p, q, h) {
                h = (h + 1) % 1;
                if (h * 6 < 1) {
                    return p + (q - p) * h * 6;
                }
                if (h * 2 < 1) {
                    return q;
                }
                if (h * 3 < 2) {
                    return p + (q - p) * (2 / 3 - h) * 6;
                }
                return p;
            }
            spaces.hsla.to = function(rgba) {
                if (rgba[0] == null || rgba[1] == null || rgba[2] == null) {
                    return [ null, null, null, rgba[3] ];
                }
                var r = rgba[0] / 255, g = rgba[1] / 255, b = rgba[2] / 255, a = rgba[3], max = Math.max(r, g, b), min = Math.min(r, g, b), diff = max - min, add = max + min, l = add * .5, h, s;
                if (min === max) {
                    h = 0;
                } else if (r === max) {
                    h = 60 * (g - b) / diff + 360;
                } else if (g === max) {
                    h = 60 * (b - r) / diff + 120;
                } else {
                    h = 60 * (r - g) / diff + 240;
                }
                if (diff === 0) {
                    s = 0;
                } else if (l <= .5) {
                    s = diff / add;
                } else {
                    s = diff / (2 - add);
                }
                return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
            };
            spaces.hsla.from = function(hsla) {
                if (hsla[0] == null || hsla[1] == null || hsla[2] == null) {
                    return [ null, null, null, hsla[3] ];
                }
                var h = hsla[0] / 360, s = hsla[1], l = hsla[2], a = hsla[3], q = l <= .5 ? l * (1 + s) : l + s - l * s, p = 2 * l - q;
                return [ Math.round(hue2rgb(p, q, h + 1 / 3) * 255), Math.round(hue2rgb(p, q, h) * 255), Math.round(hue2rgb(p, q, h - 1 / 3) * 255), a ];
            };
            each(spaces, function(spaceName, space) {
                var props = space.props, cache = space.cache, to = space.to, from = space.from;
                color.fn[spaceName] = function(value) {
                    if (to && !this[cache]) {
                        this[cache] = to(this._rgba);
                    }
                    if (value === undefined) {
                        return this[cache].slice();
                    }
                    var ret, type = jQuery.type(value), arr = type === "array" || type === "object" ? value : arguments, local = this[cache].slice();
                    each(props, function(key, prop) {
                        var val = arr[type === "object" ? key : prop.idx];
                        if (val == null) {
                            val = local[prop.idx];
                        }
                        local[prop.idx] = clamp(val, prop);
                    });
                    if (from) {
                        ret = color(from(local));
                        ret[cache] = local;
                        return ret;
                    } else {
                        return color(local);
                    }
                };
                each(props, function(key, prop) {
                    if (color.fn[key]) {
                        return;
                    }
                    color.fn[key] = function(value) {
                        var vtype = jQuery.type(value), fn = key === "alpha" ? this._hsla ? "hsla" : "rgba" : spaceName, local = this[fn](), cur = local[prop.idx], match;
                        if (vtype === "undefined") {
                            return cur;
                        }
                        if (vtype === "function") {
                            value = value.call(this, cur);
                            vtype = jQuery.type(value);
                        }
                        if (value == null && prop.empty) {
                            return this;
                        }
                        if (vtype === "string") {
                            match = rplusequals.exec(value);
                            if (match) {
                                value = cur + parseFloat(match[2]) * (match[1] === "+" ? 1 : -1);
                            }
                        }
                        local[prop.idx] = value;
                        return this[fn](local);
                    };
                });
            });
            color.hook = function(hook) {
                var hooks = hook.split(" ");
                each(hooks, function(i, hook) {
                    jQuery.cssHooks[hook] = {
                        set: function(elem, value) {
                            var parsed, curElem, backgroundColor = "";
                            if (value !== "transparent" && (jQuery.type(value) !== "string" || (parsed = stringParse(value)))) {
                                value = color(parsed || value);
                                if (!support.rgba && value._rgba[3] !== 1) {
                                    curElem = hook === "backgroundColor" ? elem.parentNode : elem;
                                    while ((backgroundColor === "" || backgroundColor === "transparent") && curElem && curElem.style) {
                                        try {
                                            backgroundColor = jQuery.css(curElem, "backgroundColor");
                                            curElem = curElem.parentNode;
                                        } catch (e) {}
                                    }
                                    value = value.blend(backgroundColor && backgroundColor !== "transparent" ? backgroundColor : "_default");
                                }
                                value = value.toRgbaString();
                            }
                            try {
                                elem.style[hook] = value;
                            } catch (e) {}
                        }
                    };
                    jQuery.fx.step[hook] = function(fx) {
                        if (!fx.colorInit) {
                            fx.start = color(fx.elem, hook);
                            fx.end = color(fx.end);
                            fx.colorInit = true;
                        }
                        jQuery.cssHooks[hook].set(fx.elem, fx.start.transition(fx.end, fx.pos));
                    };
                });
            };
            color.hook(stepHooks);
            jQuery.cssHooks.borderColor = {
                expand: function(value) {
                    var expanded = {};
                    each([ "Top", "Right", "Bottom", "Left" ], function(i, part) {
                        expanded["border" + part + "Color"] = value;
                    });
                    return expanded;
                }
            };
            colors = jQuery.Color.names = {
                aqua: "#00ffff",
                black: "#000000",
                blue: "#0000ff",
                fuchsia: "#ff00ff",
                gray: "#808080",
                green: "#008000",
                lime: "#00ff00",
                maroon: "#800000",
                navy: "#000080",
                olive: "#808000",
                purple: "#800080",
                red: "#ff0000",
                silver: "#c0c0c0",
                teal: "#008080",
                white: "#ffffff",
                yellow: "#ffff00",
                transparent: [ null, null, null, 0 ],
                _default: "#ffffff"
            };
        })(jQuery);
        (function() {
            var classAnimationActions = [ "add", "remove", "toggle" ], shorthandStyles = {
                border: 1,
                borderBottom: 1,
                borderColor: 1,
                borderLeft: 1,
                borderRight: 1,
                borderTop: 1,
                borderWidth: 1,
                margin: 1,
                padding: 1
            };
            $.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function(_, prop) {
                $.fx.step[prop] = function(fx) {
                    if (fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr) {
                        jQuery.style(fx.elem, prop, fx.end);
                        fx.setAttr = true;
                    }
                };
            });
            function camelCase(string) {
                return string.replace(/-([\da-z])/gi, function(all, letter) {
                    return letter.toUpperCase();
                });
            }
            function getElementStyles(elem) {
                var key, len, style = elem.ownerDocument.defaultView ? elem.ownerDocument.defaultView.getComputedStyle(elem, null) : elem.currentStyle, styles = {};
                if (style && style.length && style[0] && style[style[0]]) {
                    len = style.length;
                    while (len--) {
                        key = style[len];
                        if (typeof style[key] === "string") {
                            styles[camelCase(key)] = style[key];
                        }
                    }
                } else {
                    for (key in style) {
                        if (typeof style[key] === "string") {
                            styles[key] = style[key];
                        }
                    }
                }
                return styles;
            }
            function styleDifference(oldStyle, newStyle) {
                var diff = {}, name, value;
                for (name in newStyle) {
                    value = newStyle[name];
                    if (oldStyle[name] !== value) {
                        if (!shorthandStyles[name]) {
                            if ($.fx.step[name] || !isNaN(parseFloat(value))) {
                                diff[name] = value;
                            }
                        }
                    }
                }
                return diff;
            }
            if (!$.fn.addBack) {
                $.fn.addBack = function(selector) {
                    return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
                };
            }
            $.effects.animateClass = function(value, duration, easing, callback) {
                var o = $.speed(duration, easing, callback);
                return this.queue(function() {
                    var animated = $(this), baseClass = animated.attr("class") || "", applyClassChange, allAnimations = o.children ? animated.find("*").addBack() : animated;
                    allAnimations = allAnimations.map(function() {
                        var el = $(this);
                        return {
                            el: el,
                            start: getElementStyles(this)
                        };
                    });
                    applyClassChange = function() {
                        $.each(classAnimationActions, function(i, action) {
                            if (value[action]) {
                                animated[action + "Class"](value[action]);
                            }
                        });
                    };
                    applyClassChange();
                    allAnimations = allAnimations.map(function() {
                        this.end = getElementStyles(this.el[0]);
                        this.diff = styleDifference(this.start, this.end);
                        return this;
                    });
                    animated.attr("class", baseClass);
                    allAnimations = allAnimations.map(function() {
                        var styleInfo = this, dfd = $.Deferred(), opts = $.extend({}, o, {
                            queue: false,
                            complete: function() {
                                dfd.resolve(styleInfo);
                            }
                        });
                        this.el.animate(this.diff, opts);
                        return dfd.promise();
                    });
                    $.when.apply($, allAnimations.get()).done(function() {
                        applyClassChange();
                        $.each(arguments, function() {
                            var el = this.el;
                            $.each(this.diff, function(key) {
                                el.css(key, "");
                            });
                        });
                        o.complete.call(animated[0]);
                    });
                });
            };
            $.fn.extend({
                addClass: function(orig) {
                    return function(classNames, speed, easing, callback) {
                        return speed ? $.effects.animateClass.call(this, {
                            add: classNames
                        }, speed, easing, callback) : orig.apply(this, arguments);
                    };
                }($.fn.addClass),
                removeClass: function(orig) {
                    return function(classNames, speed, easing, callback) {
                        return arguments.length > 1 ? $.effects.animateClass.call(this, {
                            remove: classNames
                        }, speed, easing, callback) : orig.apply(this, arguments);
                    };
                }($.fn.removeClass),
                toggleClass: function(orig) {
                    return function(classNames, force, speed, easing, callback) {
                        if (typeof force === "boolean" || force === undefined) {
                            if (!speed) {
                                return orig.apply(this, arguments);
                            } else {
                                return $.effects.animateClass.call(this, force ? {
                                    add: classNames
                                } : {
                                    remove: classNames
                                }, speed, easing, callback);
                            }
                        } else {
                            return $.effects.animateClass.call(this, {
                                toggle: classNames
                            }, force, speed, easing);
                        }
                    };
                }($.fn.toggleClass),
                switchClass: function(remove, add, speed, easing, callback) {
                    return $.effects.animateClass.call(this, {
                        add: add,
                        remove: remove
                    }, speed, easing, callback);
                }
            });
        })();
        (function() {
            if ($.expr && $.expr.filters && $.expr.filters.animated) {
                $.expr.filters.animated = function(orig) {
                    return function(elem) {
                        return !!$(elem).data(dataSpaceAnimated) || orig(elem);
                    };
                }($.expr.filters.animated);
            }
            if ($.uiBackCompat !== false) {
                $.extend($.effects, {
                    save: function(element, set) {
                        var i = 0, length = set.length;
                        for (;i < length; i++) {
                            if (set[i] !== null) {
                                element.data(dataSpace + set[i], element[0].style[set[i]]);
                            }
                        }
                    },
                    restore: function(element, set) {
                        var val, i = 0, length = set.length;
                        for (;i < length; i++) {
                            if (set[i] !== null) {
                                val = element.data(dataSpace + set[i]);
                                element.css(set[i], val);
                            }
                        }
                    },
                    setMode: function(el, mode) {
                        if (mode === "toggle") {
                            mode = el.is(":hidden") ? "show" : "hide";
                        }
                        return mode;
                    },
                    createWrapper: function(element) {
                        if (element.parent().is(".ui-effects-wrapper")) {
                            return element.parent();
                        }
                        var props = {
                            width: element.outerWidth(true),
                            height: element.outerHeight(true),
                            "float": element.css("float")
                        }, wrapper = $("<div></div>").addClass("ui-effects-wrapper").css({
                            fontSize: "100%",
                            background: "transparent",
                            border: "none",
                            margin: 0,
                            padding: 0
                        }), size = {
                            width: element.width(),
                            height: element.height()
                        }, active = document.activeElement;
                        try {
                            active.id;
                        } catch (e) {
                            active = document.body;
                        }
                        element.wrap(wrapper);
                        if (element[0] === active || $.contains(element[0], active)) {
                            $(active).trigger("focus");
                        }
                        wrapper = element.parent();
                        if (element.css("position") === "static") {
                            wrapper.css({
                                position: "relative"
                            });
                            element.css({
                                position: "relative"
                            });
                        } else {
                            $.extend(props, {
                                position: element.css("position"),
                                zIndex: element.css("z-index")
                            });
                            $.each([ "top", "left", "bottom", "right" ], function(i, pos) {
                                props[pos] = element.css(pos);
                                if (isNaN(parseInt(props[pos], 10))) {
                                    props[pos] = "auto";
                                }
                            });
                            element.css({
                                position: "relative",
                                top: 0,
                                left: 0,
                                right: "auto",
                                bottom: "auto"
                            });
                        }
                        element.css(size);
                        return wrapper.css(props).show();
                    },
                    removeWrapper: function(element) {
                        var active = document.activeElement;
                        if (element.parent().is(".ui-effects-wrapper")) {
                            element.parent().replaceWith(element);
                            if (element[0] === active || $.contains(element[0], active)) {
                                $(active).trigger("focus");
                            }
                        }
                        return element;
                    }
                });
            }
            $.extend($.effects, {
                version: "@VERSION",
                define: function(name, mode, effect) {
                    if (!effect) {
                        effect = mode;
                        mode = "effect";
                    }
                    $.effects.effect[name] = effect;
                    $.effects.effect[name].mode = mode;
                    return effect;
                },
                scaledDimensions: function(element, percent, direction) {
                    if (percent === 0) {
                        return {
                            height: 0,
                            width: 0,
                            outerHeight: 0,
                            outerWidth: 0
                        };
                    }
                    var x = direction !== "horizontal" ? (percent || 100) / 100 : 1, y = direction !== "vertical" ? (percent || 100) / 100 : 1;
                    return {
                        height: element.height() * y,
                        width: element.width() * x,
                        outerHeight: element.outerHeight() * y,
                        outerWidth: element.outerWidth() * x
                    };
                },
                clipToBox: function(animation) {
                    return {
                        width: animation.clip.right - animation.clip.left,
                        height: animation.clip.bottom - animation.clip.top,
                        left: animation.clip.left,
                        top: animation.clip.top
                    };
                },
                unshift: function(element, queueLength, count) {
                    var queue = element.queue();
                    if (queueLength > 1) {
                        queue.splice.apply(queue, [ 1, 0 ].concat(queue.splice(queueLength, count)));
                    }
                    element.dequeue();
                },
                saveStyle: function(element) {
                    element.data(dataSpaceStyle, element[0].style.cssText);
                },
                restoreStyle: function(element) {
                    element[0].style.cssText = element.data(dataSpaceStyle) || "";
                    element.removeData(dataSpaceStyle);
                },
                mode: function(element, mode) {
                    var hidden = element.is(":hidden");
                    if (mode === "toggle") {
                        mode = hidden ? "show" : "hide";
                    }
                    if (hidden ? mode === "hide" : mode === "show") {
                        mode = "none";
                    }
                    return mode;
                },
                getBaseline: function(origin, original) {
                    var y, x;
                    switch (origin[0]) {
                      case "top":
                        y = 0;
                        break;

                      case "middle":
                        y = .5;
                        break;

                      case "bottom":
                        y = 1;
                        break;

                      default:
                        y = origin[0] / original.height;
                    }
                    switch (origin[1]) {
                      case "left":
                        x = 0;
                        break;

                      case "center":
                        x = .5;
                        break;

                      case "right":
                        x = 1;
                        break;

                      default:
                        x = origin[1] / original.width;
                    }
                    return {
                        x: x,
                        y: y
                    };
                },
                createPlaceholder: function(element) {
                    var placeholder, cssPosition = element.css("position"), position = element.position();
                    element.css({
                        marginTop: element.css("marginTop"),
                        marginBottom: element.css("marginBottom"),
                        marginLeft: element.css("marginLeft"),
                        marginRight: element.css("marginRight")
                    }).outerWidth(element.outerWidth()).outerHeight(element.outerHeight());
                    if (/^(static|relative)/.test(cssPosition)) {
                        cssPosition = "absolute";
                        placeholder = $("<" + element[0].nodeName + ">").insertAfter(element).css({
                            display: /^(inline|ruby)/.test(element.css("display")) ? "inline-block" : "block",
                            visibility: "hidden",
                            marginTop: element.css("marginTop"),
                            marginBottom: element.css("marginBottom"),
                            marginLeft: element.css("marginLeft"),
                            marginRight: element.css("marginRight"),
                            "float": element.css("float")
                        }).outerWidth(element.outerWidth()).outerHeight(element.outerHeight()).addClass("ui-effects-placeholder");
                        element.data(dataSpace + "placeholder", placeholder);
                    }
                    element.css({
                        position: cssPosition,
                        left: position.left,
                        top: position.top
                    });
                    return placeholder;
                },
                removePlaceholder: function(element) {
                    var dataKey = dataSpace + "placeholder", placeholder = element.data(dataKey);
                    if (placeholder) {
                        placeholder.remove();
                        element.removeData(dataKey);
                    }
                },
                cleanUp: function(element) {
                    $.effects.restoreStyle(element);
                    $.effects.removePlaceholder(element);
                },
                setTransition: function(element, list, factor, value) {
                    value = value || {};
                    $.each(list, function(i, x) {
                        var unit = element.cssUnit(x);
                        if (unit[0] > 0) {
                            value[x] = unit[0] * factor + unit[1];
                        }
                    });
                    return value;
                }
            });
            function _normalizeArguments(effect, options, speed, callback) {
                if ($.isPlainObject(effect)) {
                    options = effect;
                    effect = effect.effect;
                }
                effect = {
                    effect: effect
                };
                if (options == null) {
                    options = {};
                }
                if ($.isFunction(options)) {
                    callback = options;
                    speed = null;
                    options = {};
                }
                if (typeof options === "number" || $.fx.speeds[options]) {
                    callback = speed;
                    speed = options;
                    options = {};
                }
                if ($.isFunction(speed)) {
                    callback = speed;
                    speed = null;
                }
                if (options) {
                    $.extend(effect, options);
                }
                speed = speed || options.duration;
                effect.duration = $.fx.off ? 0 : typeof speed === "number" ? speed : speed in $.fx.speeds ? $.fx.speeds[speed] : $.fx.speeds._default;
                effect.complete = callback || options.complete;
                return effect;
            }
            function standardAnimationOption(option) {
                if (!option || typeof option === "number" || $.fx.speeds[option]) {
                    return true;
                }
                if (typeof option === "string" && !$.effects.effect[option]) {
                    return true;
                }
                if ($.isFunction(option)) {
                    return true;
                }
                if (typeof option === "object" && !option.effect) {
                    return true;
                }
                return false;
            }
            $.fn.extend({
                effect: function() {
                    var args = _normalizeArguments.apply(this, arguments), effectMethod = $.effects.effect[args.effect], defaultMode = effectMethod.mode, queue = args.queue, queueName = queue || "fx", complete = args.complete, mode = args.mode, modes = [], prefilter = function(next) {
                        var el = $(this), normalizedMode = $.effects.mode(el, mode) || defaultMode;
                        el.data(dataSpaceAnimated, true);
                        modes.push(normalizedMode);
                        if (defaultMode && (normalizedMode === "show" || normalizedMode === defaultMode && normalizedMode === "hide")) {
                            el.show();
                        }
                        if (!defaultMode || normalizedMode !== "none") {
                            $.effects.saveStyle(el);
                        }
                        if ($.isFunction(next)) {
                            next();
                        }
                    };
                    if ($.fx.off || !effectMethod) {
                        if (mode) {
                            return this[mode](args.duration, complete);
                        } else {
                            return this.each(function() {
                                if (complete) {
                                    complete.call(this);
                                }
                            });
                        }
                    }
                    function run(next) {
                        var elem = $(this);
                        function cleanup() {
                            elem.removeData(dataSpaceAnimated);
                            $.effects.cleanUp(elem);
                            if (args.mode === "hide") {
                                elem.hide();
                            }
                            done();
                        }
                        function done() {
                            if ($.isFunction(complete)) {
                                complete.call(elem[0]);
                            }
                            if ($.isFunction(next)) {
                                next();
                            }
                        }
                        args.mode = modes.shift();
                        if ($.uiBackCompat !== false && !defaultMode) {
                            if (elem.is(":hidden") ? mode === "hide" : mode === "show") {
                                elem[mode]();
                                done();
                            } else {
                                effectMethod.call(elem[0], args, done);
                            }
                        } else {
                            if (args.mode === "none") {
                                elem[mode]();
                                done();
                            } else {
                                effectMethod.call(elem[0], args, cleanup);
                            }
                        }
                    }
                    return this.each(prefilter).each(run);
                },
                show: function(orig) {
                    return function(option) {
                        if (standardAnimationOption(option)) {
                            return orig.apply(this, arguments);
                        } else {
                            var args = _normalizeArguments.apply(this, arguments);
                            args.mode = "show";
                            return this.effect.call(this, args);
                        }
                    };
                }($.fn.show),
                hide: function(orig) {
                    return function(option) {
                        if (standardAnimationOption(option)) {
                            return orig.apply(this, arguments);
                        } else {
                            var args = _normalizeArguments.apply(this, arguments);
                            args.mode = "hide";
                            return this.effect.call(this, args);
                        }
                    };
                }($.fn.hide),
                toggle: function(orig) {
                    return function(option) {
                        if (standardAnimationOption(option) || typeof option === "boolean") {
                            return orig.apply(this, arguments);
                        } else {
                            var args = _normalizeArguments.apply(this, arguments);
                            args.mode = "toggle";
                            return this.effect.call(this, args);
                        }
                    };
                }($.fn.toggle),
                cssUnit: function(key) {
                    var style = this.css(key), val = [];
                    $.each([ "em", "px", "%", "pt" ], function(i, unit) {
                        if (style.indexOf(unit) > 0) {
                            val = [ parseFloat(style), unit ];
                        }
                    });
                    return val;
                },
                cssClip: function(clipObj) {
                    if (clipObj) {
                        return this.css("clip", "rect(" + clipObj.top + "px " + clipObj.right + "px " + clipObj.bottom + "px " + clipObj.left + "px)");
                    }
                    return parseClip(this.css("clip"), this);
                },
                transfer: function(options, done) {
                    var element = $(this), target = $(options.to), targetFixed = target.css("position") === "fixed", body = $("body"), fixTop = targetFixed ? body.scrollTop() : 0, fixLeft = targetFixed ? body.scrollLeft() : 0, endPosition = target.offset(), animation = {
                        top: endPosition.top - fixTop,
                        left: endPosition.left - fixLeft,
                        height: target.innerHeight(),
                        width: target.innerWidth()
                    }, startPosition = element.offset(), transfer = $("<div class='ui-effects-transfer'></div>").appendTo("body").addClass(options.className).css({
                        top: startPosition.top - fixTop,
                        left: startPosition.left - fixLeft,
                        height: element.innerHeight(),
                        width: element.innerWidth(),
                        position: targetFixed ? "fixed" : "absolute"
                    }).animate(animation, options.duration, options.easing, function() {
                        transfer.remove();
                        if ($.isFunction(done)) {
                            done();
                        }
                    });
                }
            });
            function parseClip(str, element) {
                var outerWidth = element.outerWidth(), outerHeight = element.outerHeight(), clipRegex = /^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/, values = clipRegex.exec(str) || [ "", 0, outerWidth, outerHeight, 0 ];
                return {
                    top: parseFloat(values[1]) || 0,
                    right: values[2] === "auto" ? outerWidth : parseFloat(values[2]),
                    bottom: values[3] === "auto" ? outerHeight : parseFloat(values[3]),
                    left: parseFloat(values[4]) || 0
                };
            }
            $.fx.step.clip = function(fx) {
                if (!fx.clipInit) {
                    fx.start = $(fx.elem).cssClip();
                    if (typeof fx.end === "string") {
                        fx.end = parseClip(fx.end, fx.elem);
                    }
                    fx.clipInit = true;
                }
                $(fx.elem).cssClip({
                    top: fx.pos * (fx.end.top - fx.start.top) + fx.start.top,
                    right: fx.pos * (fx.end.right - fx.start.right) + fx.start.right,
                    bottom: fx.pos * (fx.end.bottom - fx.start.bottom) + fx.start.bottom,
                    left: fx.pos * (fx.end.left - fx.start.left) + fx.start.left
                });
            };
        })();
        (function() {
            var baseEasings = {};
            $.each([ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function(i, name) {
                baseEasings[name] = function(p) {
                    return Math.pow(p, i + 2);
                };
            });
            $.extend(baseEasings, {
                Sine: function(p) {
                    return 1 - Math.cos(p * Math.PI / 2);
                },
                Circ: function(p) {
                    return 1 - Math.sqrt(1 - p * p);
                },
                Elastic: function(p) {
                    return p === 0 || p === 1 ? p : -Math.pow(2, 8 * (p - 1)) * Math.sin(((p - 1) * 80 - 7.5) * Math.PI / 15);
                },
                Back: function(p) {
                    return p * p * (3 * p - 2);
                },
                Bounce: function(p) {
                    var pow2, bounce = 4;
                    while (p < ((pow2 = Math.pow(2, --bounce)) - 1) / 11) {}
                    return 1 / Math.pow(4, 3 - bounce) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - p, 2);
                }
            });
            $.each(baseEasings, function(name, easeIn) {
                $.easing["easeIn" + name] = easeIn;
                $.easing["easeOut" + name] = function(p) {
                    return 1 - easeIn(1 - p);
                };
                $.easing["easeInOut" + name] = function(p) {
                    return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn(p * -2 + 2) / 2;
                };
            });
        })();
        return $.effects;
    });
    define("skylark-jqueryui/effects/effect-blind", [ "skylark-jquery", "../version", "../effect" ], function($) {
        return $.effects.define("blind", "hide", function(options, done) {
            var map = {
                up: [ "bottom", "top" ],
                vertical: [ "bottom", "top" ],
                down: [ "top", "bottom" ],
                left: [ "right", "left" ],
                horizontal: [ "right", "left" ],
                right: [ "left", "right" ]
            }, element = $(this), direction = options.direction || "up", start = element.cssClip(), animate = {
                clip: $.extend({}, start)
            }, placeholder = $.effects.createPlaceholder(element);
            animate.clip[map[direction][0]] = animate.clip[map[direction][1]];
            if (options.mode === "show") {
                element.cssClip(animate.clip);
                if (placeholder) {
                    placeholder.css($.effects.clipToBox(animate));
                }
                animate.clip = start;
            }
            if (placeholder) {
                placeholder.animate($.effects.clipToBox(animate), options.duration, options.easing);
            }
            element.animate(animate, {
                queue: false,
                duration: options.duration,
                easing: options.easing,
                complete: done
            });
        });
    });
    define("skylark-jqueryui/effects/effect-bounce", [ "skylark-jquery", "../version", "../effect" ], function($) {
        return $.effects.define("bounce", function(options, done) {
            var upAnim, downAnim, refValue, element = $(this), mode = options.mode, hide = mode === "hide", show = mode === "show", direction = options.direction || "up", start, distance = options.distance, times = options.times || 5, anims = times * 2 + (show || hide ? 1 : 0), speed = options.duration / anims, easing = options.easing, ref = direction === "up" || direction === "down" ? "top" : "left", motion = direction === "up" || direction === "left", i = 0, queuelen = element.queue().length;
            $.effects.createPlaceholder(element);
            var skylark = $.skylark, langx = skylark.langx, Deferred = langx.Deferred;
            var funcs = [];
            refValue = element.css(ref);
            if (!distance) {
                distance = element[ref === "top" ? "outerHeight" : "outerWidth"]() / 3;
            }
            start = element.position()[ref];
            if (show) {
                downAnim = {
                    opacity: 1
                };
                downAnim[ref] = refValue;
                element.css("opacity", 0).css(ref, start + (motion ? -distance * 2 : distance * 2));
                funcs.push(doAnimate(element, downAnim, speed, easing));
            }
            if (hide) {
                distance = distance / Math.pow(2, times - 1);
            }
            downAnim = {};
            downAnim[ref] = refValue;
            function doAnimate(element, properties, duration, ease) {
                return function() {
                    var d = new Deferred();
                    element.animate(properties, duration, easing, function() {
                        d.resolve();
                    });
                    return d.promise;
                };
            }
            for (;i < times; i++) {
                upAnim = {};
                upAnim[ref] = start + (motion ? -distance : distance);
                funcs.push(doAnimate(element, upAnim, speed, easing));
                funcs.push(doAnimate(element, downAnim, speed, easing));
                distance = hide ? distance * 2 : distance / 2;
            }
            if (hide) {
                upAnim = {
                    opacity: 0
                };
                upAnim[ref] = start + (motion ? -1 * distance : distance);
                funcs.push(doAnimate(element, upAnim, speed, easing));
            }
            funcs.push(done);
            funcs.reduce(function(prev, curr, index, array) {
                return prev.then(curr);
            }, Deferred.resolve());
        });
    });
    define("skylark-jqueryui/effects/effect-clip", [ "skylark-jquery", "../version", "../effect" ], function($) {
        return $.effects.define("clip", "hide", function(options, done) {
            var start, animate = {}, element = $(this), direction = options.direction || "vertical", both = direction === "both", horizontal = both || direction === "horizontal", vertical = both || direction === "vertical";
            start = element.cssClip();
            animate.clip = {
                top: vertical ? (start.bottom - start.top) / 2 : start.top,
                right: horizontal ? (start.right - start.left) / 2 : start.right,
                bottom: vertical ? (start.bottom - start.top) / 2 : start.bottom,
                left: horizontal ? (start.right - start.left) / 2 : start.left
            };
            $.effects.createPlaceholder(element);
            if (options.mode === "show") {
                element.cssClip(animate.clip);
                animate.clip = start;
            }
            element.animate(animate, {
                queue: false,
                duration: options.duration,
                easing: options.easing,
                complete: done
            });
        });
    });
    define("skylark-jqueryui/effects/effect-drop", [ "skylark-jquery", "../version", "../effect" ], function($) {
        return $.effects.define("drop", "hide", function(options, done) {
            var distance, element = $(this), mode = options.mode, show = mode === "show", direction = options.direction || "left", ref = direction === "up" || direction === "down" ? "top" : "left", motion = direction === "up" || direction === "left" ? -1 : 1, oppositeMotion = motion * -1, animation = {
                opacity: 0
            }, start = element.position()[ref];
            $.effects.createPlaceholder(element);
            distance = options.distance || element[ref === "top" ? "outerHeight" : "outerWidth"](true) / 2;
            animation[ref] = start + motion * distance;
            if (show) {
                element.css(animation);
                animation[ref] = start + oppositeMotion * distance;
                animation.opacity = 1;
            }
            element.animate(animation, {
                queue: false,
                duration: options.duration,
                easing: options.easing,
                complete: done
            });
        });
    });
    define("skylark-jqueryui/effects/effect-explode", [ "skylark-jquery", "../version", "../effect" ], function($) {
        return $.effects.define("explode", "hide", function(options, done) {
            var i, j, left, top, mx, my, rows = options.pieces ? Math.round(Math.sqrt(options.pieces)) : 3, cells = rows, element = $(this), mode = options.mode, show = mode === "show", offset = element.show().css("visibility", "hidden").offset(), width = Math.ceil(element.outerWidth() / cells), height = Math.ceil(element.outerHeight() / rows), pieces = [];
            function childComplete() {
                pieces.push(this);
                if (pieces.length === rows * cells) {
                    animComplete();
                }
            }
            for (i = 0; i < rows; i++) {
                top = offset.top + i * height;
                my = i - (rows - 1) / 2;
                for (j = 0; j < cells; j++) {
                    left = offset.left + j * width;
                    mx = j - (cells - 1) / 2;
                    element.clone().appendTo("body").wrap("<div></div>").css({
                        position: "absolute",
                        visibility: "visible",
                        left: -j * width,
                        top: -i * height
                    }).parent().addClass("ui-effects-explode").css({
                        position: "absolute",
                        overflow: "hidden",
                        width: width,
                        height: height,
                        left: left + (show ? mx * width : 0),
                        top: top + (show ? my * height : 0),
                        opacity: show ? 0 : 1
                    }).animate({
                        left: left + (show ? 0 : mx * width),
                        top: top + (show ? 0 : my * height),
                        opacity: show ? 1 : 0
                    }, options.duration || 500, options.easing, childComplete);
                }
            }
            function animComplete() {
                element.css({
                    visibility: "visible"
                });
                $(pieces).remove();
                done();
            }
        });
    });
    define("skylark-jqueryui/effects/effect-fade", [ "skylark-jquery", "../version", "../effect" ], function($) {
        return $.effects.define("fade", "toggle", function(options, done) {
            var show = options.mode === "show";
            $(this).css("opacity", show ? 0 : 1).animate({
                opacity: show ? 1 : 0
            }, {
                queue: false,
                duration: options.duration,
                easing: options.easing,
                complete: done
            });
        });
    });
    define("skylark-jqueryui/effects/effect-fold", [ "skylark-jquery", "../version", "../effect" ], function($) {
        return $.effects.define("fold", "hide", function(options, done) {
            var element = $(this), mode = options.mode, show = mode === "show", hide = mode === "hide", size = options.size || 15, percent = /([0-9]+)%/.exec(size), horizFirst = !!options.horizFirst, ref = horizFirst ? [ "right", "bottom" ] : [ "bottom", "right" ], duration = options.duration / 2, placeholder = $.effects.createPlaceholder(element), start = element.cssClip(), animation1 = {
                clip: $.extend({}, start)
            }, animation2 = {
                clip: $.extend({}, start)
            }, distance = [ start[ref[0]], start[ref[1]] ], queuelen = element.queue().length;
            if (percent) {
                size = parseInt(percent[1], 10) / 100 * distance[hide ? 0 : 1];
            }
            animation1.clip[ref[0]] = size;
            animation2.clip[ref[0]] = size;
            animation2.clip[ref[1]] = 0;
            if (show) {
                element.cssClip(animation2.clip);
                if (placeholder) {
                    placeholder.css($.effects.clipToBox(animation2));
                }
                animation2.clip = start;
            }
            var skylark = $.skylark, langx = skylark.langx, Deferred = langx.Deferred;
            var funcs = [];
            function doAnimate(element, properties, duration, ease) {
                return function() {
                    var d = new Deferred();
                    element.animate(properties, duration, ease, function() {
                        d.resolve();
                    });
                    return d.promise;
                };
            }
            if (placeholder) {
                funcs.push(doAnimate(placeholder, $.effects.clipToBox(animation1), duration, options.easing));
                funcs.push(doAnimate(placeholder, $.effects.clipToBox(animation2), duration, options.easing));
            }
            funcs.push(doAnimate(element, animation1, duration, options.easing));
            funcs.push(doAnimate(element, animation2, duration, options.easing));
            funcs.push(done);
            funcs.reduce(function(prev, curr, index, array) {
                return prev.then(curr);
            }, Deferred.resolve());
        });
    });
    define("skylark-jqueryui/effects/effect-highlight", [ "skylark-jquery", "../version", "../effect" ], function($) {
        return $.effects.define("highlight", "show", function(options, done) {
            var element = $(this), animation = {
                backgroundColor: element.css("backgroundColor")
            };
            if (options.mode === "hide") {
                animation.opacity = 0;
            }
            $.effects.saveStyle(element);
            element.css({
                backgroundImage: "none",
                backgroundColor: options.color || "#ffff99"
            }).animate(animation, {
                queue: false,
                duration: options.duration,
                easing: options.easing,
                complete: done
            });
        });
    });
    define("skylark-jqueryui/effects/effect-size", [ "skylark-jquery", "../version", "../effect" ], function($) {
        return $.effects.define("size", function(options, done) {
            var baseline, factor, temp, element = $(this), cProps = [ "fontSize" ], vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ], hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ], mode = options.mode, restore = mode !== "effect", scale = options.scale || "both", origin = options.origin || [ "middle", "center" ], position = element.css("position"), pos = element.position(), original = $.effects.scaledDimensions(element), from = options.from || original, to = options.to || $.effects.scaledDimensions(element, 0);
            $.effects.createPlaceholder(element);
            if (mode === "show") {
                temp = from;
                from = to;
                to = temp;
            }
            factor = {
                from: {
                    y: from.height / original.height,
                    x: from.width / original.width
                },
                to: {
                    y: to.height / original.height,
                    x: to.width / original.width
                }
            };
            if (scale === "box" || scale === "both") {
                if (factor.from.y !== factor.to.y) {
                    from = $.effects.setTransition(element, vProps, factor.from.y, from);
                    to = $.effects.setTransition(element, vProps, factor.to.y, to);
                }
                if (factor.from.x !== factor.to.x) {
                    from = $.effects.setTransition(element, hProps, factor.from.x, from);
                    to = $.effects.setTransition(element, hProps, factor.to.x, to);
                }
            }
            if (scale === "content" || scale === "both") {
                if (factor.from.y !== factor.to.y) {
                    from = $.effects.setTransition(element, cProps, factor.from.y, from);
                    to = $.effects.setTransition(element, cProps, factor.to.y, to);
                }
            }
            if (origin) {
                baseline = $.effects.getBaseline(origin, original);
                from.top = (original.outerHeight - from.outerHeight) * baseline.y + pos.top;
                from.left = (original.outerWidth - from.outerWidth) * baseline.x + pos.left;
                to.top = (original.outerHeight - to.outerHeight) * baseline.y + pos.top;
                to.left = (original.outerWidth - to.outerWidth) * baseline.x + pos.left;
            }
            element.css(from);
            if (scale === "content" || scale === "both") {
                vProps = vProps.concat([ "marginTop", "marginBottom" ]).concat(cProps);
                hProps = hProps.concat([ "marginLeft", "marginRight" ]);
                element.find("*[width]").each(function() {
                    var child = $(this), childOriginal = $.effects.scaledDimensions(child), childFrom = {
                        height: childOriginal.height * factor.from.y,
                        width: childOriginal.width * factor.from.x,
                        outerHeight: childOriginal.outerHeight * factor.from.y,
                        outerWidth: childOriginal.outerWidth * factor.from.x
                    }, childTo = {
                        height: childOriginal.height * factor.to.y,
                        width: childOriginal.width * factor.to.x,
                        outerHeight: childOriginal.height * factor.to.y,
                        outerWidth: childOriginal.width * factor.to.x
                    };
                    if (factor.from.y !== factor.to.y) {
                        childFrom = $.effects.setTransition(child, vProps, factor.from.y, childFrom);
                        childTo = $.effects.setTransition(child, vProps, factor.to.y, childTo);
                    }
                    if (factor.from.x !== factor.to.x) {
                        childFrom = $.effects.setTransition(child, hProps, factor.from.x, childFrom);
                        childTo = $.effects.setTransition(child, hProps, factor.to.x, childTo);
                    }
                    if (restore) {
                        $.effects.saveStyle(child);
                    }
                    child.css(childFrom);
                    child.animate(childTo, options.duration, options.easing, function() {
                        if (restore) {
                            $.effects.restoreStyle(child);
                        }
                    });
                });
            }
            element.animate(to, {
                queue: false,
                duration: options.duration,
                easing: options.easing,
                complete: function() {
                    var offset = element.offset();
                    if (to.opacity === 0) {
                        element.css("opacity", from.opacity);
                    }
                    if (!restore) {
                        element.css("position", position === "static" ? "relative" : position).offset(offset);
                        $.effects.saveStyle(element);
                    }
                    done();
                }
            });
        });
    });
    define("skylark-jqueryui/effects/effect-scale", [ "skylark-jquery", "../version", "../effect", "./effect-size" ], function($) {
        return $.effects.define("scale", function(options, done) {
            var el = $(this), mode = options.mode, percent = parseInt(options.percent, 10) || (parseInt(options.percent, 10) === 0 ? 0 : mode !== "effect" ? 0 : 100), newOptions = $.extend(true, {
                from: $.effects.scaledDimensions(el),
                to: $.effects.scaledDimensions(el, percent, options.direction || "both"),
                origin: options.origin || [ "middle", "center" ]
            }, options);
            if (options.fade) {
                newOptions.from.opacity = 1;
                newOptions.to.opacity = 0;
            }
            $.effects.effect.size.call(this, newOptions, done);
        });
    });
    define("skylark-jqueryui/effects/effect-puff", [ "skylark-jquery", "../version", "../effect", "./effect-scale" ], function($) {
        return $.effects.define("puff", "hide", function(options, done) {
            var newOptions = $.extend(true, {}, options, {
                fade: true,
                percent: parseInt(options.percent, 10) || 150
            });
            $.effects.effect.scale.call(this, newOptions, done);
        });
    });
    define("skylark-jqueryui/effects/effect-pulsate", [ "skylark-jquery", "../version", "../effect" ], function($) {
        return $.effects.define("pulsate", "show", function(options, done) {
            var element = $(this), mode = options.mode, show = mode === "show", hide = mode === "hide", showhide = show || hide, anims = (options.times || 5) * 2 + (showhide ? 1 : 0), duration = options.duration / anims, animateTo = 0, i = 1, queuelen = element.queue().length;
            if (show || !element.is(":visible")) {
                element.css("opacity", 0).show();
                animateTo = 1;
            }
            var skylark = $.skylark, langx = skylark.langx, Deferred = langx.Deferred;
            var funcs = [];
            function doAnimate(element, properties, duration, ease) {
                return function() {
                    var d = new Deferred();
                    element.animate(properties, duration, ease, function() {
                        d.resolve();
                    });
                    return d.promise;
                };
            }
            for (;i < anims; i++) {
                funcs.push(doAnimate(element, {
                    opacity: animateTo
                }, duration, options.easing));
                animateTo = 1 - animateTo;
            }
            funcs.push(doAnimate(element, {
                opacity: animateTo
            }, duration, options.easing));
            funcs.push(done);
            funcs.reduce(function(prev, curr, index, array) {
                return prev.then(curr);
            }, Deferred.resolve());
        });
    });
    define("skylark-jqueryui/effects/effect-shake", [ "skylark-jquery", "../version", "../effect" ], function($) {
        return $.effects.define("shake", function(options, done) {
            var i = 1, element = $(this), direction = options.direction || "left", distance = options.distance || 20, times = options.times || 3, anims = times * 2 + 1, speed = Math.round(options.duration / anims), ref = direction === "up" || direction === "down" ? "top" : "left", positiveMotion = direction === "up" || direction === "left", animation0 = {}, animation = {}, animation1 = {}, animation2 = {}, queuelen = element.queue().length;
            $.effects.createPlaceholder(element);
            var skylark = $.skylark, langx = skylark.langx, Deferred = langx.Deferred;
            start = element.position()[ref], funcs = [];
            function doAnimate(element, properties, duration, ease) {
                return function() {
                    var d = new Deferred();
                    element.animate(properties, duration, ease, function() {
                        d.resolve();
                    });
                    return d.promise;
                };
            }
            animation0[ref] = start;
            animation[ref] = start + (positiveMotion ? -1 : 1) * distance;
            animation1[ref] = animation[ref] + (positiveMotion ? 1 : -1) * distance * 2;
            animation2[ref] = animation1[ref] + (positiveMotion ? -1 : 1) * distance * 2;
            funcs.push(doAnimate(element, animation, speed, options.easing));
            for (;i < times; i++) {
                funcs.push(doAnimate(element, animation1, speed, options.easing));
                funcs.push(doAnimate(element, animation2, speed, options.easing));
            }
            funcs.push(doAnimate(element, animation0, speed / 2, options.easing));
            funcs.push(done);
            funcs.reduce(function(prev, curr, index, array) {
                return prev.then(curr);
            }, Deferred.resolve());
        });
    });
    define("skylark-jqueryui/effects/effect-slide", [ "skylark-jquery", "../version", "../effect" ], function($) {
        return $.effects.define("slide", "show", function(options, done) {
            var startClip, startRef, element = $(this), map = {
                up: [ "bottom", "top" ],
                down: [ "top", "bottom" ],
                left: [ "right", "left" ],
                right: [ "left", "right" ]
            }, mode = options.mode, direction = options.direction || "left", ref = direction === "up" || direction === "down" ? "top" : "left", positiveMotion = direction === "up" || direction === "left", distance = options.distance || element[ref === "top" ? "outerHeight" : "outerWidth"](true), animation = {};
            $.effects.createPlaceholder(element);
            startClip = element.cssClip();
            startRef = element.position()[ref];
            animation[ref] = (positiveMotion ? -1 : 1) * distance + startRef;
            animation.clip = element.cssClip();
            animation.clip[map[direction][1]] = animation.clip[map[direction][0]];
            if (mode === "show") {
                element.cssClip(animation.clip);
                element.css(ref, animation[ref]);
                animation.clip = startClip;
                animation[ref] = startRef;
            }
            element.animate(animation, {
                queue: false,
                duration: options.duration,
                easing: options.easing,
                complete: done
            });
        });
    });
    define("skylark-jqueryui/effects/effect-transfer", [ "skylark-jquery", "../version", "../effect" ], function($) {
        var effect;
        if ($.uiBackCompat !== false) {
            effect = $.effects.define("transfer", function(options, done) {
                $(this).transfer(options, done);
            });
        }
        return effect;
    });
    define("skylark-jqueryui/main", [ "skylark-jquery", "./data", "./disable-selection", "./focusable", "./form", "./ie", "./keycode", "./labels", "./jquery-1-7", "./plugin", "./safe-active-element", "./safe-blur", "./scroll-parent", "./tabbable", "./unique-id", "./version", "./widgets/accordion", "./widgets/autocomplete", "./widgets/button", "./widgets/checkboxradio", "./widgets/controlgroup", "./widgets/datepicker", "./widgets/dialog", "./widgets/draggable", "./widgets/menu", "./widgets/mouse", "./widgets/progressbar", "./widgets/resizable", "./widgets/selectable", "./widgets/selectmenu", "./widgets/slider", "./widgets/sortable", "./widgets/spinner", "./widgets/tabs", "./widgets/tooltip", "./effect", "./effects/effect-blind", "./effects/effect-bounce", "./effects/effect-clip", "./effects/effect-drop", "./effects/effect-explode", "./effects/effect-fade", "./effects/effect-fold", "./effects/effect-highlight", "./effects/effect-puff", "./effects/effect-pulsate", "./effects/effect-scale", "./effects/effect-shake", "./effects/effect-size", "./effects/effect-slide", "./effects/effect-transfer" ], function($) {
        return $;
    });
    define("skylark-jqueryui", [ "skylark-jqueryui/main" ], function(main) {
        return main;
    });
}, this);

var matched, browser;

jQuery.uaMatch = function(ua) {
    ua = ua.toLowerCase();
    var match = /(chrome)[ \/]([\w.]+)/.exec(ua) || /(webkit)[ \/]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];
    return {
        browser: match[1] || "",
        version: match[2] || "0"
    };
};

matched = jQuery.uaMatch(navigator.userAgent);

browser = {};

if (matched.browser) {
    browser[matched.browser] = true;
    browser.version = matched.version;
}

if (browser.chrome) {
    browser.webkit = true;
} else if (browser.webkit) {
    browser.safari = true;
}

jQuery.browser = browser;

(function() {
    (function(n) {
        var x = this || (0, eval)("this"), u = x.document, M = x.navigator, v = x.jQuery, F = x.JSON;
        (function(n) {
            "function" === typeof define && define.amd ? define([ "exports", "require" ], n) : "object" === typeof exports && "object" === typeof module ? n(module.exports || exports) : n(x.ko = {});
        })(function(N, O) {
            function J(a, c) {
                return null === a || typeof a in T ? a === c : !1;
            }
            function U(b, c) {
                var d;
                return function() {
                    d || (d = a.a.setTimeout(function() {
                        d = n;
                        b();
                    }, c));
                };
            }
            function V(b, c) {
                var d;
                return function() {
                    clearTimeout(d);
                    d = a.a.setTimeout(b, c);
                };
            }
            function W(a, c) {
                c && c !== I ? "beforeChange" === c ? this.Kb(a) : this.Ha(a, c) : this.Lb(a);
            }
            function X(a, c) {
                null !== c && c.k && c.k();
            }
            function Y(a, c) {
                var d = this.Hc, e = d[s];
                e.R || (this.lb && this.Ma[c] ? (d.Pb(c, a, this.Ma[c]), this.Ma[c] = null, --this.lb) : e.r[c] || d.Pb(c, a, e.s ? {
                    ia: a
                } : d.uc(a)));
            }
            function K(b, c, d, e) {
                a.d[b] = {
                    init: function(b, g, k, l, m) {
                        var h, r;
                        a.m(function() {
                            var q = a.a.c(g()), p = !d !== !q, A = !r;
                            if (A || c || p !== h) A && a.va.Aa() && (r = a.a.ua(a.f.childNodes(b), !0)), p ? (A || a.f.da(b, a.a.ua(r)), 
                            a.eb(e ? e(m, q) : m, b)) : a.f.xa(b), h = p;
                        }, null, {
                            i: b
                        });
                        return {
                            controlsDescendantBindings: !0
                        };
                    }
                };
                a.h.ta[b] = !1;
                a.f.Z[b] = !0;
            }
            var a = "undefined" !== typeof N ? N : {};
            a.b = function(b, c) {
                for (var d = b.split("."), e = a, f = 0; f < d.length - 1; f++) e = e[d[f]];
                e[d[d.length - 1]] = c;
            };
            a.G = function(a, c, d) {
                a[c] = d;
            };
            a.version = "3.4.0";
            a.b("version", a.version);
            a.options = {
                deferUpdates: !1,
                useOnlyNativeEvents: !1
            };
            a.a = function() {
                function b(a, b) {
                    for (var c in a) a.hasOwnProperty(c) && b(c, a[c]);
                }
                function c(a, b) {
                    if (b) for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
                    return a;
                }
                function d(a, b) {
                    a.__proto__ = b;
                    return a;
                }
                function e(b, c, d, e) {
                    var h = b[c].match(r) || [];
                    a.a.q(d.match(r), function(b) {
                        a.a.pa(h, b, e);
                    });
                    b[c] = h.join(" ");
                }
                var f = {
                    __proto__: []
                } instanceof Array, g = "function" === typeof Symbol, k = {}, l = {};
                k[M && /Firefox\/2/i.test(M.userAgent) ? "KeyboardEvent" : "UIEvents"] = [ "keyup", "keydown", "keypress" ];
                k.MouseEvents = "click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave".split(" ");
                b(k, function(a, b) {
                    if (b.length) for (var c = 0, d = b.length; c < d; c++) l[b[c]] = a;
                });
                var m = {
                    propertychange: !0
                }, h = u && function() {
                    for (var a = 3, b = u.createElement("div"), c = b.getElementsByTagName("i"); b.innerHTML = "<!--[if gt IE " + ++a + "]><i></i><![endif]-->", 
                    c[0]; ) ;
                    return 4 < a ? a : n;
                }(), r = /\S+/g;
                return {
                    cc: [ "authenticity_token", /^__RequestVerificationToken(_.*)?$/ ],
                    q: function(a, b) {
                        for (var c = 0, d = a.length; c < d; c++) b(a[c], c);
                    },
                    o: function(a, b) {
                        if ("function" == typeof Array.prototype.indexOf) return Array.prototype.indexOf.call(a, b);
                        for (var c = 0, d = a.length; c < d; c++) if (a[c] === b) return c;
                        return -1;
                    },
                    Sb: function(a, b, c) {
                        for (var d = 0, e = a.length; d < e; d++) if (b.call(c, a[d], d)) return a[d];
                        return null;
                    },
                    La: function(b, c) {
                        var d = a.a.o(b, c);
                        0 < d ? b.splice(d, 1) : 0 === d && b.shift();
                    },
                    Tb: function(b) {
                        b = b || [];
                        for (var c = [], d = 0, e = b.length; d < e; d++) 0 > a.a.o(c, b[d]) && c.push(b[d]);
                        return c;
                    },
                    fb: function(a, b) {
                        a = a || [];
                        for (var c = [], d = 0, e = a.length; d < e; d++) c.push(b(a[d], d));
                        return c;
                    },
                    Ka: function(a, b) {
                        a = a || [];
                        for (var c = [], d = 0, e = a.length; d < e; d++) b(a[d], d) && c.push(a[d]);
                        return c;
                    },
                    ra: function(a, b) {
                        if (b instanceof Array) a.push.apply(a, b); else for (var c = 0, d = b.length; c < d; c++) a.push(b[c]);
                        return a;
                    },
                    pa: function(b, c, d) {
                        var e = a.a.o(a.a.zb(b), c);
                        0 > e ? d && b.push(c) : d || b.splice(e, 1);
                    },
                    ka: f,
                    extend: c,
                    Xa: d,
                    Ya: f ? d : c,
                    D: b,
                    Ca: function(a, b) {
                        if (!a) return a;
                        var c = {}, d;
                        for (d in a) a.hasOwnProperty(d) && (c[d] = b(a[d], d, a));
                        return c;
                    },
                    ob: function(b) {
                        for (;b.firstChild; ) a.removeNode(b.firstChild);
                    },
                    jc: function(b) {
                        b = a.a.V(b);
                        for (var c = (b[0] && b[0].ownerDocument || u).createElement("div"), d = 0, e = b.length; d < e; d++) c.appendChild(a.$(b[d]));
                        return c;
                    },
                    ua: function(b, c) {
                        for (var d = 0, e = b.length, h = []; d < e; d++) {
                            var m = b[d].cloneNode(!0);
                            h.push(c ? a.$(m) : m);
                        }
                        return h;
                    },
                    da: function(b, c) {
                        a.a.ob(b);
                        if (c) for (var d = 0, e = c.length; d < e; d++) b.appendChild(c[d]);
                    },
                    qc: function(b, c) {
                        var d = b.nodeType ? [ b ] : b;
                        if (0 < d.length) {
                            for (var e = d[0], h = e.parentNode, m = 0, l = c.length; m < l; m++) h.insertBefore(c[m], e);
                            m = 0;
                            for (l = d.length; m < l; m++) a.removeNode(d[m]);
                        }
                    },
                    za: function(a, b) {
                        if (a.length) {
                            for (b = 8 === b.nodeType && b.parentNode || b; a.length && a[0].parentNode !== b; ) a.splice(0, 1);
                            for (;1 < a.length && a[a.length - 1].parentNode !== b; ) a.length--;
                            if (1 < a.length) {
                                var c = a[0], d = a[a.length - 1];
                                for (a.length = 0; c !== d; ) a.push(c), c = c.nextSibling;
                                a.push(d);
                            }
                        }
                        return a;
                    },
                    sc: function(a, b) {
                        7 > h ? a.setAttribute("selected", b) : a.selected = b;
                    },
                    $a: function(a) {
                        return null === a || a === n ? "" : a.trim ? a.trim() : a.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g, "");
                    },
                    nd: function(a, b) {
                        a = a || "";
                        return b.length > a.length ? !1 : a.substring(0, b.length) === b;
                    },
                    Mc: function(a, b) {
                        if (a === b) return !0;
                        if (11 === a.nodeType) return !1;
                        if (b.contains) return b.contains(3 === a.nodeType ? a.parentNode : a);
                        if (b.compareDocumentPosition) return 16 == (b.compareDocumentPosition(a) & 16);
                        for (;a && a != b; ) a = a.parentNode;
                        return !!a;
                    },
                    nb: function(b) {
                        return a.a.Mc(b, b.ownerDocument.documentElement);
                    },
                    Qb: function(b) {
                        return !!a.a.Sb(b, a.a.nb);
                    },
                    A: function(a) {
                        return a && a.tagName && a.tagName.toLowerCase();
                    },
                    Wb: function(b) {
                        return a.onError ? function() {
                            try {
                                return b.apply(this, arguments);
                            } catch (c) {
                                throw a.onError && a.onError(c), c;
                            }
                        } : b;
                    },
                    setTimeout: function(b, c) {
                        return setTimeout(a.a.Wb(b), c);
                    },
                    $b: function(b) {
                        setTimeout(function() {
                            a.onError && a.onError(b);
                            throw b;
                        }, 0);
                    },
                    p: function(b, c, d) {
                        var e = a.a.Wb(d);
                        d = h && m[c];
                        if (a.options.useOnlyNativeEvents || d || !v) if (d || "function" != typeof b.addEventListener) if ("undefined" != typeof b.attachEvent) {
                            var l = function(a) {
                                e.call(b, a);
                            }, f = "on" + c;
                            b.attachEvent(f, l);
                            a.a.F.oa(b, function() {
                                b.detachEvent(f, l);
                            });
                        } else throw Error("Browser doesn't support addEventListener or attachEvent"); else b.addEventListener(c, e, !1); else v(b).bind(c, e);
                    },
                    Da: function(b, c) {
                        if (!b || !b.nodeType) throw Error("element must be a DOM node when calling triggerEvent");
                        var d;
                        "input" === a.a.A(b) && b.type && "click" == c.toLowerCase() ? (d = b.type, d = "checkbox" == d || "radio" == d) : d = !1;
                        if (a.options.useOnlyNativeEvents || !v || d) if ("function" == typeof u.createEvent) if ("function" == typeof b.dispatchEvent) d = u.createEvent(l[c] || "HTMLEvents"), 
                        d.initEvent(c, !0, !0, x, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, b), b.dispatchEvent(d); else throw Error("The supplied element doesn't support dispatchEvent"); else if (d && b.click) b.click(); else if ("undefined" != typeof b.fireEvent) b.fireEvent("on" + c); else throw Error("Browser doesn't support triggering events"); else v(b).trigger(c);
                    },
                    c: function(b) {
                        return a.H(b) ? b() : b;
                    },
                    zb: function(b) {
                        return a.H(b) ? b.t() : b;
                    },
                    bb: function(b, c, d) {
                        var h;
                        c && ("object" === typeof b.classList ? (h = b.classList[d ? "add" : "remove"], 
                        a.a.q(c.match(r), function(a) {
                            h.call(b.classList, a);
                        })) : "string" === typeof b.className.baseVal ? e(b.className, "baseVal", c, d) : e(b, "className", c, d));
                    },
                    Za: function(b, c) {
                        var d = a.a.c(c);
                        if (null === d || d === n) d = "";
                        var e = a.f.firstChild(b);
                        !e || 3 != e.nodeType || a.f.nextSibling(e) ? a.f.da(b, [ b.ownerDocument.createTextNode(d) ]) : e.data = d;
                        a.a.Rc(b);
                    },
                    rc: function(a, b) {
                        a.name = b;
                        if (7 >= h) try {
                            a.mergeAttributes(u.createElement("<input name='" + a.name + "'/>"), !1);
                        } catch (c) {}
                    },
                    Rc: function(a) {
                        9 <= h && (a = 1 == a.nodeType ? a : a.parentNode, a.style && (a.style.zoom = a.style.zoom));
                    },
                    Nc: function(a) {
                        if (h) {
                            var b = a.style.width;
                            a.style.width = 0;
                            a.style.width = b;
                        }
                    },
                    hd: function(b, c) {
                        b = a.a.c(b);
                        c = a.a.c(c);
                        for (var d = [], e = b; e <= c; e++) d.push(e);
                        return d;
                    },
                    V: function(a) {
                        for (var b = [], c = 0, d = a.length; c < d; c++) b.push(a[c]);
                        return b;
                    },
                    Yb: function(a) {
                        return g ? Symbol(a) : a;
                    },
                    rd: 6 === h,
                    sd: 7 === h,
                    C: h,
                    ec: function(b, c) {
                        for (var d = a.a.V(b.getElementsByTagName("input")).concat(a.a.V(b.getElementsByTagName("textarea"))), e = "string" == typeof c ? function(a) {
                            return a.name === c;
                        } : function(a) {
                            return c.test(a.name);
                        }, h = [], m = d.length - 1; 0 <= m; m--) e(d[m]) && h.push(d[m]);
                        return h;
                    },
                    ed: function(b) {
                        return "string" == typeof b && (b = a.a.$a(b)) ? F && F.parse ? F.parse(b) : new Function("return " + b)() : null;
                    },
                    Eb: function(b, c, d) {
                        if (!F || !F.stringify) throw Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
                        return F.stringify(a.a.c(b), c, d);
                    },
                    fd: function(c, d, e) {
                        e = e || {};
                        var h = e.params || {}, m = e.includeFields || this.cc, l = c;
                        if ("object" == typeof c && "form" === a.a.A(c)) for (var l = c.action, f = m.length - 1; 0 <= f; f--) for (var g = a.a.ec(c, m[f]), k = g.length - 1; 0 <= k; k--) h[g[k].name] = g[k].value;
                        d = a.a.c(d);
                        var r = u.createElement("form");
                        r.style.display = "none";
                        r.action = l;
                        r.method = "post";
                        for (var n in d) c = u.createElement("input"), c.type = "hidden", c.name = n, c.value = a.a.Eb(a.a.c(d[n])), 
                        r.appendChild(c);
                        b(h, function(a, b) {
                            var c = u.createElement("input");
                            c.type = "hidden";
                            c.name = a;
                            c.value = b;
                            r.appendChild(c);
                        });
                        u.body.appendChild(r);
                        e.submitter ? e.submitter(r) : r.submit();
                        setTimeout(function() {
                            r.parentNode.removeChild(r);
                        }, 0);
                    }
                };
            }();
            a.b("utils", a.a);
            a.b("utils.arrayForEach", a.a.q);
            a.b("utils.arrayFirst", a.a.Sb);
            a.b("utils.arrayFilter", a.a.Ka);
            a.b("utils.arrayGetDistinctValues", a.a.Tb);
            a.b("utils.arrayIndexOf", a.a.o);
            a.b("utils.arrayMap", a.a.fb);
            a.b("utils.arrayPushAll", a.a.ra);
            a.b("utils.arrayRemoveItem", a.a.La);
            a.b("utils.extend", a.a.extend);
            a.b("utils.fieldsIncludedWithJsonPost", a.a.cc);
            a.b("utils.getFormFields", a.a.ec);
            a.b("utils.peekObservable", a.a.zb);
            a.b("utils.postJson", a.a.fd);
            a.b("utils.parseJson", a.a.ed);
            a.b("utils.registerEventHandler", a.a.p);
            a.b("utils.stringifyJson", a.a.Eb);
            a.b("utils.range", a.a.hd);
            a.b("utils.toggleDomNodeCssClass", a.a.bb);
            a.b("utils.triggerEvent", a.a.Da);
            a.b("utils.unwrapObservable", a.a.c);
            a.b("utils.objectForEach", a.a.D);
            a.b("utils.addOrRemoveItem", a.a.pa);
            a.b("utils.setTextContent", a.a.Za);
            a.b("unwrap", a.a.c);
            Function.prototype.bind || (Function.prototype.bind = function(a) {
                var c = this;
                if (1 === arguments.length) return function() {
                    return c.apply(a, arguments);
                };
                var d = Array.prototype.slice.call(arguments, 1);
                return function() {
                    var e = d.slice(0);
                    e.push.apply(e, arguments);
                    return c.apply(a, e);
                };
            });
            a.a.e = new function() {
                function a(b, g) {
                    var k = b[d];
                    if (!k || "null" === k || !e[k]) {
                        if (!g) return n;
                        k = b[d] = "ko" + c++;
                        e[k] = {};
                    }
                    return e[k];
                }
                var c = 0, d = "__ko__" + new Date().getTime(), e = {};
                return {
                    get: function(c, d) {
                        var e = a(c, !1);
                        return e === n ? n : e[d];
                    },
                    set: function(c, d, e) {
                        if (e !== n || a(c, !1) !== n) a(c, !0)[d] = e;
                    },
                    clear: function(a) {
                        var b = a[d];
                        return b ? (delete e[b], a[d] = null, !0) : !1;
                    },
                    I: function() {
                        return c++ + d;
                    }
                };
            }();
            a.b("utils.domData", a.a.e);
            a.b("utils.domData.clear", a.a.e.clear);
            a.a.F = new function() {
                function b(b, c) {
                    var e = a.a.e.get(b, d);
                    e === n && c && (e = [], a.a.e.set(b, d, e));
                    return e;
                }
                function c(d) {
                    var e = b(d, !1);
                    if (e) for (var e = e.slice(0), l = 0; l < e.length; l++) e[l](d);
                    a.a.e.clear(d);
                    a.a.F.cleanExternalData(d);
                    if (f[d.nodeType]) for (e = d.firstChild; d = e; ) e = d.nextSibling, 8 === d.nodeType && c(d);
                }
                var d = a.a.e.I(), e = {
                    1: !0,
                    8: !0,
                    9: !0
                }, f = {
                    1: !0,
                    9: !0
                };
                return {
                    oa: function(a, c) {
                        if ("function" != typeof c) throw Error("Callback must be a function");
                        b(a, !0).push(c);
                    },
                    pc: function(c, e) {
                        var l = b(c, !1);
                        l && (a.a.La(l, e), 0 == l.length && a.a.e.set(c, d, n));
                    },
                    $: function(b) {
                        if (e[b.nodeType] && (c(b), f[b.nodeType])) {
                            var d = [];
                            a.a.ra(d, b.getElementsByTagName("*"));
                            for (var l = 0, m = d.length; l < m; l++) c(d[l]);
                        }
                        return b;
                    },
                    removeNode: function(b) {
                        a.$(b);
                        b.parentNode && b.parentNode.removeChild(b);
                    },
                    cleanExternalData: function(a) {
                        v && "function" == typeof v.cleanData && v.cleanData([ a ]);
                    }
                };
            }();
            a.$ = a.a.F.$;
            a.removeNode = a.a.F.removeNode;
            a.b("cleanNode", a.$);
            a.b("removeNode", a.removeNode);
            a.b("utils.domNodeDisposal", a.a.F);
            a.b("utils.domNodeDisposal.addDisposeCallback", a.a.F.oa);
            a.b("utils.domNodeDisposal.removeDisposeCallback", a.a.F.pc);
            (function() {
                var b = [ 0, "", "" ], c = [ 1, "<table>", "</table>" ], d = [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ], e = [ 1, "<select multiple='multiple'>", "</select>" ], f = {
                    thead: c,
                    tbody: c,
                    tfoot: c,
                    tr: [ 2, "<table><tbody>", "</tbody></table>" ],
                    td: d,
                    th: d,
                    option: e,
                    optgroup: e
                }, g = 8 >= a.a.C;
                a.a.ma = function(c, d) {
                    var e;
                    if (v) if (v.parseHTML) e = v.parseHTML(c, d) || []; else {
                        if ((e = v.clean([ c ], d)) && e[0]) {
                            for (var h = e[0]; h.parentNode && 11 !== h.parentNode.nodeType; ) h = h.parentNode;
                            h.parentNode && h.parentNode.removeChild(h);
                        }
                    } else {
                        (e = d) || (e = u);
                        var h = e.parentWindow || e.defaultView || x, r = a.a.$a(c).toLowerCase(), q = e.createElement("div"), p;
                        p = (r = r.match(/^<([a-z]+)[ >]/)) && f[r[1]] || b;
                        r = p[0];
                        p = "ignored<div>" + p[1] + c + p[2] + "</div>";
                        "function" == typeof h.innerShiv ? q.appendChild(h.innerShiv(p)) : (g && e.appendChild(q), 
                        q.innerHTML = p, g && q.parentNode.removeChild(q));
                        for (;r--; ) q = q.lastChild;
                        e = a.a.V(q.lastChild.childNodes);
                    }
                    return e;
                };
                a.a.Cb = function(b, c) {
                    a.a.ob(b);
                    c = a.a.c(c);
                    if (null !== c && c !== n) if ("string" != typeof c && (c = c.toString()), v) v(b).html(c); else for (var d = a.a.ma(c, b.ownerDocument), e = 0; e < d.length; e++) b.appendChild(d[e]);
                };
            })();
            a.b("utils.parseHtmlFragment", a.a.ma);
            a.b("utils.setHtml", a.a.Cb);
            a.M = function() {
                function b(c, e) {
                    if (c) if (8 == c.nodeType) {
                        var f = a.M.lc(c.nodeValue);
                        null != f && e.push({
                            Lc: c,
                            cd: f
                        });
                    } else if (1 == c.nodeType) for (var f = 0, g = c.childNodes, k = g.length; f < k; f++) b(g[f], e);
                }
                var c = {};
                return {
                    wb: function(a) {
                        if ("function" != typeof a) throw Error("You can only pass a function to ko.memoization.memoize()");
                        var b = (4294967296 * (1 + Math.random()) | 0).toString(16).substring(1) + (4294967296 * (1 + Math.random()) | 0).toString(16).substring(1);
                        c[b] = a;
                        return "<!--[ko_memo:" + b + "]-->";
                    },
                    xc: function(a, b) {
                        var f = c[a];
                        if (f === n) throw Error("Couldn't find any memo with ID " + a + ". Perhaps it's already been unmemoized.");
                        try {
                            return f.apply(null, b || []), !0;
                        } finally {
                            delete c[a];
                        }
                    },
                    yc: function(c, e) {
                        var f = [];
                        b(c, f);
                        for (var g = 0, k = f.length; g < k; g++) {
                            var l = f[g].Lc, m = [ l ];
                            e && a.a.ra(m, e);
                            a.M.xc(f[g].cd, m);
                            l.nodeValue = "";
                            l.parentNode && l.parentNode.removeChild(l);
                        }
                    },
                    lc: function(a) {
                        return (a = a.match(/^\[ko_memo\:(.*?)\]$/)) ? a[1] : null;
                    }
                };
            }();
            a.b("memoization", a.M);
            a.b("memoization.memoize", a.M.wb);
            a.b("memoization.unmemoize", a.M.xc);
            a.b("memoization.parseMemoText", a.M.lc);
            a.b("memoization.unmemoizeDomNodeAndDescendants", a.M.yc);
            a.Y = function() {
                function b() {
                    if (e) for (var b = e, c = 0, m; g < e; ) if (m = d[g++]) {
                        if (g > b) {
                            if (5e3 <= ++c) {
                                g = e;
                                a.a.$b(Error("'Too much recursion' after processing " + c + " task groups."));
                                break;
                            }
                            b = e;
                        }
                        try {
                            m();
                        } catch (h) {
                            a.a.$b(h);
                        }
                    }
                }
                function c() {
                    b();
                    g = e = d.length = 0;
                }
                var d = [], e = 0, f = 1, g = 0;
                return {
                    scheduler: x.MutationObserver ? function(a) {
                        var b = u.createElement("div");
                        new MutationObserver(a).observe(b, {
                            attributes: !0
                        });
                        return function() {
                            b.classList.toggle("foo");
                        };
                    }(c) : u && "onreadystatechange" in u.createElement("script") ? function(a) {
                        var b = u.createElement("script");
                        b.onreadystatechange = function() {
                            b.onreadystatechange = null;
                            u.documentElement.removeChild(b);
                            b = null;
                            a();
                        };
                        u.documentElement.appendChild(b);
                    } : function(a) {
                        setTimeout(a, 0);
                    },
                    Wa: function(b) {
                        e || a.Y.scheduler(c);
                        d[e++] = b;
                        return f++;
                    },
                    cancel: function(a) {
                        a -= f - e;
                        a >= g && a < e && (d[a] = null);
                    },
                    resetForTesting: function() {
                        var a = e - g;
                        g = e = d.length = 0;
                        return a;
                    },
                    md: b
                };
            }();
            a.b("tasks", a.Y);
            a.b("tasks.schedule", a.Y.Wa);
            a.b("tasks.runEarly", a.Y.md);
            a.ya = {
                throttle: function(b, c) {
                    b.throttleEvaluation = c;
                    var d = null;
                    return a.B({
                        read: b,
                        write: function(e) {
                            clearTimeout(d);
                            d = a.a.setTimeout(function() {
                                b(e);
                            }, c);
                        }
                    });
                },
                rateLimit: function(a, c) {
                    var d, e, f;
                    "number" == typeof c ? d = c : (d = c.timeout, e = c.method);
                    a.cb = !1;
                    f = "notifyWhenChangesStop" == e ? V : U;
                    a.Ta(function(a) {
                        return f(a, d);
                    });
                },
                deferred: function(b, c) {
                    if (!0 !== c) throw Error("The 'deferred' extender only accepts the value 'true', because it is not supported to turn deferral off once enabled.");
                    b.cb || (b.cb = !0, b.Ta(function(c) {
                        var e;
                        return function() {
                            a.Y.cancel(e);
                            e = a.Y.Wa(c);
                            b.notifySubscribers(n, "dirty");
                        };
                    }));
                },
                notify: function(a, c) {
                    a.equalityComparer = "always" == c ? null : J;
                }
            };
            var T = {
                undefined: 1,
                "boolean": 1,
                number: 1,
                string: 1
            };
            a.b("extenders", a.ya);
            a.vc = function(b, c, d) {
                this.ia = b;
                this.gb = c;
                this.Kc = d;
                this.R = !1;
                a.G(this, "dispose", this.k);
            };
            a.vc.prototype.k = function() {
                this.R = !0;
                this.Kc();
            };
            a.J = function() {
                a.a.Ya(this, D);
                D.rb(this);
            };
            var I = "change", D = {
                rb: function(a) {
                    a.K = {};
                    a.Nb = 1;
                },
                X: function(b, c, d) {
                    var e = this;
                    d = d || I;
                    var f = new a.vc(e, c ? b.bind(c) : b, function() {
                        a.a.La(e.K[d], f);
                        e.Ia && e.Ia(d);
                    });
                    e.sa && e.sa(d);
                    e.K[d] || (e.K[d] = []);
                    e.K[d].push(f);
                    return f;
                },
                notifySubscribers: function(b, c) {
                    c = c || I;
                    c === I && this.zc();
                    if (this.Pa(c)) try {
                        a.l.Ub();
                        for (var d = this.K[c].slice(0), e = 0, f; f = d[e]; ++e) f.R || f.gb(b);
                    } finally {
                        a.l.end();
                    }
                },
                Na: function() {
                    return this.Nb;
                },
                Uc: function(a) {
                    return this.Na() !== a;
                },
                zc: function() {
                    ++this.Nb;
                },
                Ta: function(b) {
                    var c = this, d = a.H(c), e, f, g;
                    c.Ha || (c.Ha = c.notifySubscribers, c.notifySubscribers = W);
                    var k = b(function() {
                        c.Mb = !1;
                        d && g === c && (g = c());
                        e = !1;
                        c.tb(f, g) && c.Ha(f = g);
                    });
                    c.Lb = function(a) {
                        c.Mb = e = !0;
                        g = a;
                        k();
                    };
                    c.Kb = function(a) {
                        e || (f = a, c.Ha(a, "beforeChange"));
                    };
                },
                Pa: function(a) {
                    return this.K[a] && this.K[a].length;
                },
                Sc: function(b) {
                    if (b) return this.K[b] && this.K[b].length || 0;
                    var c = 0;
                    a.a.D(this.K, function(a, b) {
                        "dirty" !== a && (c += b.length);
                    });
                    return c;
                },
                tb: function(a, c) {
                    return !this.equalityComparer || !this.equalityComparer(a, c);
                },
                extend: function(b) {
                    var c = this;
                    b && a.a.D(b, function(b, e) {
                        var f = a.ya[b];
                        "function" == typeof f && (c = f(c, e) || c);
                    });
                    return c;
                }
            };
            a.G(D, "subscribe", D.X);
            a.G(D, "extend", D.extend);
            a.G(D, "getSubscriptionsCount", D.Sc);
            a.a.ka && a.a.Xa(D, Function.prototype);
            a.J.fn = D;
            a.hc = function(a) {
                return null != a && "function" == typeof a.X && "function" == typeof a.notifySubscribers;
            };
            a.b("subscribable", a.J);
            a.b("isSubscribable", a.hc);
            a.va = a.l = function() {
                function b(a) {
                    d.push(e);
                    e = a;
                }
                function c() {
                    e = d.pop();
                }
                var d = [], e, f = 0;
                return {
                    Ub: b,
                    end: c,
                    oc: function(b) {
                        if (e) {
                            if (!a.hc(b)) throw Error("Only subscribable things can act as dependencies");
                            e.gb.call(e.Gc, b, b.Cc || (b.Cc = ++f));
                        }
                    },
                    w: function(a, d, e) {
                        try {
                            return b(), a.apply(d, e || []);
                        } finally {
                            c();
                        }
                    },
                    Aa: function() {
                        if (e) return e.m.Aa();
                    },
                    Sa: function() {
                        if (e) return e.Sa;
                    }
                };
            }();
            a.b("computedContext", a.va);
            a.b("computedContext.getDependenciesCount", a.va.Aa);
            a.b("computedContext.isInitial", a.va.Sa);
            a.b("ignoreDependencies", a.qd = a.l.w);
            var E = a.a.Yb("_latestValue");
            a.N = function(b) {
                function c() {
                    if (0 < arguments.length) return c.tb(c[E], arguments[0]) && (c.ga(), c[E] = arguments[0], 
                    c.fa()), this;
                    a.l.oc(c);
                    return c[E];
                }
                c[E] = b;
                a.a.ka || a.a.extend(c, a.J.fn);
                a.J.fn.rb(c);
                a.a.Ya(c, B);
                a.options.deferUpdates && a.ya.deferred(c, !0);
                return c;
            };
            var B = {
                equalityComparer: J,
                t: function() {
                    return this[E];
                },
                fa: function() {
                    this.notifySubscribers(this[E]);
                },
                ga: function() {
                    this.notifySubscribers(this[E], "beforeChange");
                }
            };
            a.a.ka && a.a.Xa(B, a.J.fn);
            var H = a.N.gd = "__ko_proto__";
            B[H] = a.N;
            a.Oa = function(b, c) {
                return null === b || b === n || b[H] === n ? !1 : b[H] === c ? !0 : a.Oa(b[H], c);
            };
            a.H = function(b) {
                return a.Oa(b, a.N);
            };
            a.Ba = function(b) {
                return "function" == typeof b && b[H] === a.N || "function" == typeof b && b[H] === a.B && b.Vc ? !0 : !1;
            };
            a.b("observable", a.N);
            a.b("isObservable", a.H);
            a.b("isWriteableObservable", a.Ba);
            a.b("isWritableObservable", a.Ba);
            a.b("observable.fn", B);
            a.G(B, "peek", B.t);
            a.G(B, "valueHasMutated", B.fa);
            a.G(B, "valueWillMutate", B.ga);
            a.la = function(b) {
                b = b || [];
                if ("object" != typeof b || !("length" in b)) throw Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");
                b = a.N(b);
                a.a.Ya(b, a.la.fn);
                return b.extend({
                    trackArrayChanges: !0
                });
            };
            a.la.fn = {
                remove: function(b) {
                    for (var c = this.t(), d = [], e = "function" != typeof b || a.H(b) ? function(a) {
                        return a === b;
                    } : b, f = 0; f < c.length; f++) {
                        var g = c[f];
                        e(g) && (0 === d.length && this.ga(), d.push(g), c.splice(f, 1), f--);
                    }
                    d.length && this.fa();
                    return d;
                },
                removeAll: function(b) {
                    if (b === n) {
                        var c = this.t(), d = c.slice(0);
                        this.ga();
                        c.splice(0, c.length);
                        this.fa();
                        return d;
                    }
                    return b ? this.remove(function(c) {
                        return 0 <= a.a.o(b, c);
                    }) : [];
                },
                destroy: function(b) {
                    var c = this.t(), d = "function" != typeof b || a.H(b) ? function(a) {
                        return a === b;
                    } : b;
                    this.ga();
                    for (var e = c.length - 1; 0 <= e; e--) d(c[e]) && (c[e]._destroy = !0);
                    this.fa();
                },
                destroyAll: function(b) {
                    return b === n ? this.destroy(function() {
                        return !0;
                    }) : b ? this.destroy(function(c) {
                        return 0 <= a.a.o(b, c);
                    }) : [];
                },
                indexOf: function(b) {
                    var c = this();
                    return a.a.o(c, b);
                },
                replace: function(a, c) {
                    var d = this.indexOf(a);
                    0 <= d && (this.ga(), this.t()[d] = c, this.fa());
                }
            };
            a.a.ka && a.a.Xa(a.la.fn, a.N.fn);
            a.a.q("pop push reverse shift sort splice unshift".split(" "), function(b) {
                a.la.fn[b] = function() {
                    var a = this.t();
                    this.ga();
                    this.Vb(a, b, arguments);
                    var d = a[b].apply(a, arguments);
                    this.fa();
                    return d === a ? this : d;
                };
            });
            a.a.q([ "slice" ], function(b) {
                a.la.fn[b] = function() {
                    var a = this();
                    return a[b].apply(a, arguments);
                };
            });
            a.b("observableArray", a.la);
            a.ya.trackArrayChanges = function(b, c) {
                function d() {
                    if (!e) {
                        e = !0;
                        var c = b.notifySubscribers;
                        b.notifySubscribers = function(a, b) {
                            b && b !== I || ++k;
                            return c.apply(this, arguments);
                        };
                        var d = [].concat(b.t() || []);
                        f = null;
                        g = b.X(function(c) {
                            c = [].concat(c || []);
                            if (b.Pa("arrayChange")) {
                                var e;
                                if (!f || 1 < k) f = a.a.ib(d, c, b.hb);
                                e = f;
                            }
                            d = c;
                            f = null;
                            k = 0;
                            e && e.length && b.notifySubscribers(e, "arrayChange");
                        });
                    }
                }
                b.hb = {};
                c && "object" == typeof c && a.a.extend(b.hb, c);
                b.hb.sparse = !0;
                if (!b.Vb) {
                    var e = !1, f = null, g, k = 0, l = b.sa, m = b.Ia;
                    b.sa = function(a) {
                        l && l.call(b, a);
                        "arrayChange" === a && d();
                    };
                    b.Ia = function(a) {
                        m && m.call(b, a);
                        "arrayChange" !== a || b.Pa("arrayChange") || (g.k(), e = !1);
                    };
                    b.Vb = function(b, c, d) {
                        function m(a, b, c) {
                            return l[l.length] = {
                                status: a,
                                value: b,
                                index: c
                            };
                        }
                        if (e && !k) {
                            var l = [], g = b.length, t = d.length, G = 0;
                            switch (c) {
                              case "push":
                                G = g;

                              case "unshift":
                                for (c = 0; c < t; c++) m("added", d[c], G + c);
                                break;

                              case "pop":
                                G = g - 1;

                              case "shift":
                                g && m("deleted", b[G], G);
                                break;

                              case "splice":
                                c = Math.min(Math.max(0, 0 > d[0] ? g + d[0] : d[0]), g);
                                for (var g = 1 === t ? g : Math.min(c + (d[1] || 0), g), t = c + t - 2, G = Math.max(g, t), P = [], n = [], Q = 2; c < G; ++c, 
                                ++Q) c < g && n.push(m("deleted", b[c], c)), c < t && P.push(m("added", d[Q], c));
                                a.a.dc(n, P);
                                break;

                              default:
                                return;
                            }
                            f = l;
                        }
                    };
                }
            };
            var s = a.a.Yb("_state");
            a.m = a.B = function(b, c, d) {
                function e() {
                    if (0 < arguments.length) {
                        if ("function" === typeof f) f.apply(g.pb, arguments); else throw Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");
                        return this;
                    }
                    a.l.oc(e);
                    (g.S || g.s && e.Qa()) && e.aa();
                    return g.T;
                }
                "object" === typeof b ? d = b : (d = d || {}, b && (d.read = b));
                if ("function" != typeof d.read) throw Error("Pass a function that returns the value of the ko.computed");
                var f = d.write, g = {
                    T: n,
                    S: !0,
                    Ra: !1,
                    Fb: !1,
                    R: !1,
                    Va: !1,
                    s: !1,
                    jd: d.read,
                    pb: c || d.owner,
                    i: d.disposeWhenNodeIsRemoved || d.i || null,
                    wa: d.disposeWhen || d.wa,
                    mb: null,
                    r: {},
                    L: 0,
                    bc: null
                };
                e[s] = g;
                e.Vc = "function" === typeof f;
                a.a.ka || a.a.extend(e, a.J.fn);
                a.J.fn.rb(e);
                a.a.Ya(e, z);
                d.pure ? (g.Va = !0, g.s = !0, a.a.extend(e, $)) : d.deferEvaluation && a.a.extend(e, aa);
                a.options.deferUpdates && a.ya.deferred(e, !0);
                g.i && (g.Fb = !0, g.i.nodeType || (g.i = null));
                g.s || d.deferEvaluation || e.aa();
                g.i && e.ba() && a.a.F.oa(g.i, g.mb = function() {
                    e.k();
                });
                return e;
            };
            var z = {
                equalityComparer: J,
                Aa: function() {
                    return this[s].L;
                },
                Pb: function(a, c, d) {
                    if (this[s].Va && c === this) throw Error("A 'pure' computed must not be called recursively");
                    this[s].r[a] = d;
                    d.Ga = this[s].L++;
                    d.na = c.Na();
                },
                Qa: function() {
                    var a, c, d = this[s].r;
                    for (a in d) if (d.hasOwnProperty(a) && (c = d[a], c.ia.Uc(c.na))) return !0;
                },
                bd: function() {
                    this.Fa && !this[s].Ra && this.Fa();
                },
                ba: function() {
                    return this[s].S || 0 < this[s].L;
                },
                ld: function() {
                    this.Mb || this.ac();
                },
                uc: function(a) {
                    if (a.cb && !this[s].i) {
                        var c = a.X(this.bd, this, "dirty"), d = a.X(this.ld, this);
                        return {
                            ia: a,
                            k: function() {
                                c.k();
                                d.k();
                            }
                        };
                    }
                    return a.X(this.ac, this);
                },
                ac: function() {
                    var b = this, c = b.throttleEvaluation;
                    c && 0 <= c ? (clearTimeout(this[s].bc), this[s].bc = a.a.setTimeout(function() {
                        b.aa(!0);
                    }, c)) : b.Fa ? b.Fa() : b.aa(!0);
                },
                aa: function(b) {
                    var c = this[s], d = c.wa;
                    if (!c.Ra && !c.R) {
                        if (c.i && !a.a.nb(c.i) || d && d()) {
                            if (!c.Fb) {
                                this.k();
                                return;
                            }
                        } else c.Fb = !1;
                        c.Ra = !0;
                        try {
                            this.Qc(b);
                        } finally {
                            c.Ra = !1;
                        }
                        c.L || this.k();
                    }
                },
                Qc: function(b) {
                    var c = this[s], d = c.Va ? n : !c.L, e = {
                        Hc: this,
                        Ma: c.r,
                        lb: c.L
                    };
                    a.l.Ub({
                        Gc: e,
                        gb: Y,
                        m: this,
                        Sa: d
                    });
                    c.r = {};
                    c.L = 0;
                    e = this.Pc(c, e);
                    this.tb(c.T, e) && (c.s || this.notifySubscribers(c.T, "beforeChange"), c.T = e, 
                    c.s ? this.zc() : b && this.notifySubscribers(c.T));
                    d && this.notifySubscribers(c.T, "awake");
                },
                Pc: function(b, c) {
                    try {
                        var d = b.jd;
                        return b.pb ? d.call(b.pb) : d();
                    } finally {
                        a.l.end(), c.lb && !b.s && a.a.D(c.Ma, X), b.S = !1;
                    }
                },
                t: function() {
                    var a = this[s];
                    (a.S && !a.L || a.s && this.Qa()) && this.aa();
                    return a.T;
                },
                Ta: function(b) {
                    a.J.fn.Ta.call(this, b);
                    this.Fa = function() {
                        this.Kb(this[s].T);
                        this[s].S = !0;
                        this.Lb(this);
                    };
                },
                k: function() {
                    var b = this[s];
                    !b.s && b.r && a.a.D(b.r, function(a, b) {
                        b.k && b.k();
                    });
                    b.i && b.mb && a.a.F.pc(b.i, b.mb);
                    b.r = null;
                    b.L = 0;
                    b.R = !0;
                    b.S = !1;
                    b.s = !1;
                    b.i = null;
                }
            }, $ = {
                sa: function(b) {
                    var c = this, d = c[s];
                    if (!d.R && d.s && "change" == b) {
                        d.s = !1;
                        if (d.S || c.Qa()) d.r = null, d.L = 0, d.S = !0, c.aa(); else {
                            var e = [];
                            a.a.D(d.r, function(a, b) {
                                e[b.Ga] = a;
                            });
                            a.a.q(e, function(a, b) {
                                var e = d.r[a], l = c.uc(e.ia);
                                l.Ga = b;
                                l.na = e.na;
                                d.r[a] = l;
                            });
                        }
                        d.R || c.notifySubscribers(d.T, "awake");
                    }
                },
                Ia: function(b) {
                    var c = this[s];
                    c.R || "change" != b || this.Pa("change") || (a.a.D(c.r, function(a, b) {
                        b.k && (c.r[a] = {
                            ia: b.ia,
                            Ga: b.Ga,
                            na: b.na
                        }, b.k());
                    }), c.s = !0, this.notifySubscribers(n, "asleep"));
                },
                Na: function() {
                    var b = this[s];
                    b.s && (b.S || this.Qa()) && this.aa();
                    return a.J.fn.Na.call(this);
                }
            }, aa = {
                sa: function(a) {
                    "change" != a && "beforeChange" != a || this.t();
                }
            };
            a.a.ka && a.a.Xa(z, a.J.fn);
            var R = a.N.gd;
            a.m[R] = a.N;
            z[R] = a.m;
            a.Xc = function(b) {
                return a.Oa(b, a.m);
            };
            a.Yc = function(b) {
                return a.Oa(b, a.m) && b[s] && b[s].Va;
            };
            a.b("computed", a.m);
            a.b("dependentObservable", a.m);
            a.b("isComputed", a.Xc);
            a.b("isPureComputed", a.Yc);
            a.b("computed.fn", z);
            a.G(z, "peek", z.t);
            a.G(z, "dispose", z.k);
            a.G(z, "isActive", z.ba);
            a.G(z, "getDependenciesCount", z.Aa);
            a.nc = function(b, c) {
                if ("function" === typeof b) return a.m(b, c, {
                    pure: !0
                });
                b = a.a.extend({}, b);
                b.pure = !0;
                return a.m(b, c);
            };
            a.b("pureComputed", a.nc);
            (function() {
                function b(a, f, g) {
                    g = g || new d();
                    a = f(a);
                    if ("object" != typeof a || null === a || a === n || a instanceof RegExp || a instanceof Date || a instanceof String || a instanceof Number || a instanceof Boolean) return a;
                    var k = a instanceof Array ? [] : {};
                    g.save(a, k);
                    c(a, function(c) {
                        var d = f(a[c]);
                        switch (typeof d) {
                          case "boolean":
                          case "number":
                          case "string":
                          case "function":
                            k[c] = d;
                            break;

                          case "object":
                          case "undefined":
                            var h = g.get(d);
                            k[c] = h !== n ? h : b(d, f, g);
                        }
                    });
                    return k;
                }
                function c(a, b) {
                    if (a instanceof Array) {
                        for (var c = 0; c < a.length; c++) b(c);
                        "function" == typeof a.toJSON && b("toJSON");
                    } else for (c in a) b(c);
                }
                function d() {
                    this.keys = [];
                    this.Ib = [];
                }
                a.wc = function(c) {
                    if (0 == arguments.length) throw Error("When calling ko.toJS, pass the object you want to convert.");
                    return b(c, function(b) {
                        for (var c = 0; a.H(b) && 10 > c; c++) b = b();
                        return b;
                    });
                };
                a.toJSON = function(b, c, d) {
                    b = a.wc(b);
                    return a.a.Eb(b, c, d);
                };
                d.prototype = {
                    save: function(b, c) {
                        var d = a.a.o(this.keys, b);
                        0 <= d ? this.Ib[d] = c : (this.keys.push(b), this.Ib.push(c));
                    },
                    get: function(b) {
                        b = a.a.o(this.keys, b);
                        return 0 <= b ? this.Ib[b] : n;
                    }
                };
            })();
            a.b("toJS", a.wc);
            a.b("toJSON", a.toJSON);
            (function() {
                a.j = {
                    u: function(b) {
                        switch (a.a.A(b)) {
                          case "option":
                            return !0 === b.__ko__hasDomDataOptionValue__ ? a.a.e.get(b, a.d.options.xb) : 7 >= a.a.C ? b.getAttributeNode("value") && b.getAttributeNode("value").specified ? b.value : b.text : b.value;

                          case "select":
                            return 0 <= b.selectedIndex ? a.j.u(b.options[b.selectedIndex]) : n;

                          default:
                            return b.value;
                        }
                    },
                    ha: function(b, c, d) {
                        switch (a.a.A(b)) {
                          case "option":
                            switch (typeof c) {
                              case "string":
                                a.a.e.set(b, a.d.options.xb, n);
                                "__ko__hasDomDataOptionValue__" in b && delete b.__ko__hasDomDataOptionValue__;
                                b.value = c;
                                break;

                              default:
                                a.a.e.set(b, a.d.options.xb, c), b.__ko__hasDomDataOptionValue__ = !0, b.value = "number" === typeof c ? c : "";
                            }
                            break;

                          case "select":
                            if ("" === c || null === c) c = n;
                            for (var e = -1, f = 0, g = b.options.length, k; f < g; ++f) if (k = a.j.u(b.options[f]), 
                            k == c || "" == k && c === n) {
                                e = f;
                                break;
                            }
                            if (d || 0 <= e || c === n && 1 < b.size) b.selectedIndex = e;
                            break;

                          default:
                            if (null === c || c === n) c = "";
                            b.value = c;
                        }
                    }
                };
            })();
            a.b("selectExtensions", a.j);
            a.b("selectExtensions.readValue", a.j.u);
            a.b("selectExtensions.writeValue", a.j.ha);
            a.h = function() {
                function b(b) {
                    b = a.a.$a(b);
                    123 === b.charCodeAt(0) && (b = b.slice(1, -1));
                    var c = [], d = b.match(e), r, k = [], p = 0;
                    if (d) {
                        d.push(",");
                        for (var A = 0, y; y = d[A]; ++A) {
                            var t = y.charCodeAt(0);
                            if (44 === t) {
                                if (0 >= p) {
                                    c.push(r && k.length ? {
                                        key: r,
                                        value: k.join("")
                                    } : {
                                        unknown: r || k.join("")
                                    });
                                    r = p = 0;
                                    k = [];
                                    continue;
                                }
                            } else if (58 === t) {
                                if (!p && !r && 1 === k.length) {
                                    r = k.pop();
                                    continue;
                                }
                            } else 47 === t && A && 1 < y.length ? (t = d[A - 1].match(f)) && !g[t[0]] && (b = b.substr(b.indexOf(y) + 1), 
                            d = b.match(e), d.push(","), A = -1, y = "/") : 40 === t || 123 === t || 91 === t ? ++p : 41 === t || 125 === t || 93 === t ? --p : r || k.length || 34 !== t && 39 !== t || (y = y.slice(1, -1));
                            k.push(y);
                        }
                    }
                    return c;
                }
                var c = [ "true", "false", "null", "undefined" ], d = /^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i, e = RegExp("\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\\\.)*'|/(?:[^/\\\\]|\\\\.)*/w*|[^\\s:,/][^,\"'{}()/:[\\]]*[^\\s,\"'{}()/:[\\]]|[^\\s]", "g"), f = /[\])"'A-Za-z0-9_$]+$/, g = {
                    "in": 1,
                    "return": 1,
                    "typeof": 1
                }, k = {};
                return {
                    ta: [],
                    ea: k,
                    yb: b,
                    Ua: function(e, m) {
                        function h(b, e) {
                            var m;
                            if (!A) {
                                var l = a.getBindingHandler(b);
                                if (l && l.preprocess && !(e = l.preprocess(e, b, h))) return;
                                if (l = k[b]) m = e, 0 <= a.a.o(c, m) ? m = !1 : (l = m.match(d), m = null === l ? !1 : l[1] ? "Object(" + l[1] + ")" + l[2] : m), 
                                l = m;
                                l && g.push("'" + b + "':function(_z){" + m + "=_z}");
                            }
                            p && (e = "function(){return " + e + " }");
                            f.push("'" + b + "':" + e);
                        }
                        m = m || {};
                        var f = [], g = [], p = m.valueAccessors, A = m.bindingParams, y = "string" === typeof e ? b(e) : e;
                        a.a.q(y, function(a) {
                            h(a.key || a.unknown, a.value);
                        });
                        g.length && h("_ko_property_writers", "{" + g.join(",") + " }");
                        return f.join(",");
                    },
                    ad: function(a, b) {
                        for (var c = 0; c < a.length; c++) if (a[c].key == b) return !0;
                        return !1;
                    },
                    Ea: function(b, c, d, e, f) {
                        if (b && a.H(b)) !a.Ba(b) || f && b.t() === e || b(e); else if ((b = c.get("_ko_property_writers")) && b[d]) b[d](e);
                    }
                };
            }();
            a.b("expressionRewriting", a.h);
            a.b("expressionRewriting.bindingRewriteValidators", a.h.ta);
            a.b("expressionRewriting.parseObjectLiteral", a.h.yb);
            a.b("expressionRewriting.preProcessBindings", a.h.Ua);
            a.b("expressionRewriting._twoWayBindings", a.h.ea);
            a.b("jsonExpressionRewriting", a.h);
            a.b("jsonExpressionRewriting.insertPropertyAccessorsIntoJson", a.h.Ua);
            (function() {
                function b(a) {
                    return 8 == a.nodeType && g.test(f ? a.text : a.nodeValue);
                }
                function c(a) {
                    return 8 == a.nodeType && k.test(f ? a.text : a.nodeValue);
                }
                function d(a, d) {
                    for (var e = a, f = 1, l = []; e = e.nextSibling; ) {
                        if (c(e) && (f--, 0 === f)) return l;
                        l.push(e);
                        b(e) && f++;
                    }
                    if (!d) throw Error("Cannot find closing comment tag to match: " + a.nodeValue);
                    return null;
                }
                function e(a, b) {
                    var c = d(a, b);
                    return c ? 0 < c.length ? c[c.length - 1].nextSibling : a.nextSibling : null;
                }
                var f = u && "<!--test-->" === u.createComment("test").text, g = f ? /^\x3c!--\s*ko(?:\s+([\s\S]+))?\s*--\x3e$/ : /^\s*ko(?:\s+([\s\S]+))?\s*$/, k = f ? /^\x3c!--\s*\/ko\s*--\x3e$/ : /^\s*\/ko\s*$/, l = {
                    ul: !0,
                    ol: !0
                };
                a.f = {
                    Z: {},
                    childNodes: function(a) {
                        return b(a) ? d(a) : a.childNodes;
                    },
                    xa: function(c) {
                        if (b(c)) {
                            c = a.f.childNodes(c);
                            for (var d = 0, e = c.length; d < e; d++) a.removeNode(c[d]);
                        } else a.a.ob(c);
                    },
                    da: function(c, d) {
                        if (b(c)) {
                            a.f.xa(c);
                            for (var e = c.nextSibling, f = 0, l = d.length; f < l; f++) e.parentNode.insertBefore(d[f], e);
                        } else a.a.da(c, d);
                    },
                    mc: function(a, c) {
                        b(a) ? a.parentNode.insertBefore(c, a.nextSibling) : a.firstChild ? a.insertBefore(c, a.firstChild) : a.appendChild(c);
                    },
                    gc: function(c, d, e) {
                        e ? b(c) ? c.parentNode.insertBefore(d, e.nextSibling) : e.nextSibling ? c.insertBefore(d, e.nextSibling) : c.appendChild(d) : a.f.mc(c, d);
                    },
                    firstChild: function(a) {
                        return b(a) ? !a.nextSibling || c(a.nextSibling) ? null : a.nextSibling : a.firstChild;
                    },
                    nextSibling: function(a) {
                        b(a) && (a = e(a));
                        return a.nextSibling && c(a.nextSibling) ? null : a.nextSibling;
                    },
                    Tc: b,
                    pd: function(a) {
                        return (a = (f ? a.text : a.nodeValue).match(g)) ? a[1] : null;
                    },
                    kc: function(d) {
                        if (l[a.a.A(d)]) {
                            var h = d.firstChild;
                            if (h) {
                                do if (1 === h.nodeType) {
                                    var f;
                                    f = h.firstChild;
                                    var g = null;
                                    if (f) {
                                        do if (g) g.push(f); else if (b(f)) {
                                            var k = e(f, !0);
                                            k ? f = k : g = [ f ];
                                        } else c(f) && (g = [ f ]); while (f = f.nextSibling);
                                    }
                                    if (f = g) for (g = h.nextSibling, k = 0; k < f.length; k++) g ? d.insertBefore(f[k], g) : d.appendChild(f[k]);
                                } while (h = h.nextSibling);
                            }
                        }
                    }
                };
            })();
            a.b("virtualElements", a.f);
            a.b("virtualElements.allowedBindings", a.f.Z);
            a.b("virtualElements.emptyNode", a.f.xa);
            a.b("virtualElements.insertAfter", a.f.gc);
            a.b("virtualElements.prepend", a.f.mc);
            a.b("virtualElements.setDomNodeChildren", a.f.da);
            (function() {
                a.Q = function() {
                    this.Fc = {};
                };
                a.a.extend(a.Q.prototype, {
                    nodeHasBindings: function(b) {
                        switch (b.nodeType) {
                          case 1:
                            return null != b.getAttribute("data-bind") || a.g.getComponentNameForNode(b);

                          case 8:
                            return a.f.Tc(b);

                          default:
                            return !1;
                        }
                    },
                    getBindings: function(b, c) {
                        var d = this.getBindingsString(b, c), d = d ? this.parseBindingsString(d, c, b) : null;
                        return a.g.Ob(d, b, c, !1);
                    },
                    getBindingAccessors: function(b, c) {
                        var d = this.getBindingsString(b, c), d = d ? this.parseBindingsString(d, c, b, {
                            valueAccessors: !0
                        }) : null;
                        return a.g.Ob(d, b, c, !0);
                    },
                    getBindingsString: function(b) {
                        switch (b.nodeType) {
                          case 1:
                            return b.getAttribute("data-bind");

                          case 8:
                            return a.f.pd(b);

                          default:
                            return null;
                        }
                    },
                    parseBindingsString: function(b, c, d, e) {
                        try {
                            var f = this.Fc, g = b + (e && e.valueAccessors || ""), k;
                            if (!(k = f[g])) {
                                var l, m = "with($context){with($data||{}){return{" + a.h.Ua(b, e) + "}}}";
                                l = new Function("$context", "$element", m);
                                k = f[g] = l;
                            }
                            return k(c, d);
                        } catch (h) {
                            throw h.message = "Unable to parse bindings.\nBindings value: " + b + "\nMessage: " + h.message, 
                            h;
                        }
                    }
                });
                a.Q.instance = new a.Q();
            })();
            a.b("bindingProvider", a.Q);
            (function() {
                function b(a) {
                    return function() {
                        return a;
                    };
                }
                function c(a) {
                    return a();
                }
                function d(b) {
                    return a.a.Ca(a.l.w(b), function(a, c) {
                        return function() {
                            return b()[c];
                        };
                    });
                }
                function e(c, e, h) {
                    return "function" === typeof c ? d(c.bind(null, e, h)) : a.a.Ca(c, b);
                }
                function f(a, b) {
                    return d(this.getBindings.bind(this, a, b));
                }
                function g(b, c, d) {
                    var e, h = a.f.firstChild(c), f = a.Q.instance, m = f.preprocessNode;
                    if (m) {
                        for (;e = h; ) h = a.f.nextSibling(e), m.call(f, e);
                        h = a.f.firstChild(c);
                    }
                    for (;e = h; ) h = a.f.nextSibling(e), k(b, e, d);
                }
                function k(b, c, d) {
                    var e = !0, h = 1 === c.nodeType;
                    h && a.f.kc(c);
                    if (h && d || a.Q.instance.nodeHasBindings(c)) e = m(c, null, b, d).shouldBindDescendants;
                    e && !r[a.a.A(c)] && g(b, c, !h);
                }
                function l(b) {
                    var c = [], d = {}, e = [];
                    a.a.D(b, function Z(h) {
                        if (!d[h]) {
                            var f = a.getBindingHandler(h);
                            f && (f.after && (e.push(h), a.a.q(f.after, function(c) {
                                if (b[c]) {
                                    if (-1 !== a.a.o(e, c)) throw Error("Cannot combine the following bindings, because they have a cyclic dependency: " + e.join(", "));
                                    Z(c);
                                }
                            }), e.length--), c.push({
                                key: h,
                                fc: f
                            }));
                            d[h] = !0;
                        }
                    });
                    return c;
                }
                function m(b, d, e, h) {
                    var m = a.a.e.get(b, q);
                    if (!d) {
                        if (m) throw Error("You cannot apply bindings multiple times to the same element.");
                        a.a.e.set(b, q, !0);
                    }
                    !m && h && a.tc(b, e);
                    var g;
                    if (d && "function" !== typeof d) g = d; else {
                        var k = a.Q.instance, r = k.getBindingAccessors || f, p = a.B(function() {
                            (g = d ? d(e, b) : r.call(k, b, e)) && e.P && e.P();
                            return g;
                        }, null, {
                            i: b
                        });
                        g && p.ba() || (p = null);
                    }
                    var u;
                    if (g) {
                        var v = p ? function(a) {
                            return function() {
                                return c(p()[a]);
                            };
                        } : function(a) {
                            return g[a];
                        }, s = function() {
                            return a.a.Ca(p ? p() : g, c);
                        };
                        s.get = function(a) {
                            return g[a] && c(v(a));
                        };
                        s.has = function(a) {
                            return a in g;
                        };
                        h = l(g);
                        a.a.q(h, function(c) {
                            var d = c.fc.init, h = c.fc.update, f = c.key;
                            if (8 === b.nodeType && !a.f.Z[f]) throw Error("The binding '" + f + "' cannot be used with virtual elements");
                            try {
                                "function" == typeof d && a.l.w(function() {
                                    var a = d(b, v(f), s, e.$data, e);
                                    if (a && a.controlsDescendantBindings) {
                                        if (u !== n) throw Error("Multiple bindings (" + u + " and " + f + ") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");
                                        u = f;
                                    }
                                }), "function" == typeof h && a.B(function() {
                                    h(b, v(f), s, e.$data, e);
                                }, null, {
                                    i: b
                                });
                            } catch (m) {
                                throw m.message = 'Unable to process binding "' + f + ": " + g[f] + '"\nMessage: ' + m.message, 
                                m;
                            }
                        });
                    }
                    return {
                        shouldBindDescendants: u === n
                    };
                }
                function h(b) {
                    return b && b instanceof a.U ? b : new a.U(b);
                }
                a.d = {};
                var r = {
                    script: !0,
                    textarea: !0,
                    template: !0
                };
                a.getBindingHandler = function(b) {
                    return a.d[b];
                };
                a.U = function(b, c, d, e) {
                    var h = this, f = "function" == typeof b && !a.H(b), m, g = a.B(function() {
                        var m = f ? b() : b, l = a.a.c(m);
                        c ? (c.P && c.P(), a.a.extend(h, c), g && (h.P = g)) : (h.$parents = [], h.$root = l, 
                        h.ko = a);
                        h.$rawData = m;
                        h.$data = l;
                        d && (h[d] = l);
                        e && e(h, c, l);
                        return h.$data;
                    }, null, {
                        wa: function() {
                            return m && !a.a.Qb(m);
                        },
                        i: !0
                    });
                    g.ba() && (h.P = g, g.equalityComparer = null, m = [], g.Ac = function(b) {
                        m.push(b);
                        a.a.F.oa(b, function(b) {
                            a.a.La(m, b);
                            m.length || (g.k(), h.P = g = n);
                        });
                    });
                };
                a.U.prototype.createChildContext = function(b, c, d) {
                    return new a.U(b, this, c, function(a, b) {
                        a.$parentContext = b;
                        a.$parent = b.$data;
                        a.$parents = (b.$parents || []).slice(0);
                        a.$parents.unshift(a.$parent);
                        d && d(a);
                    });
                };
                a.U.prototype.extend = function(b) {
                    return new a.U(this.P || this.$data, this, null, function(c, d) {
                        c.$rawData = d.$rawData;
                        a.a.extend(c, "function" == typeof b ? b() : b);
                    });
                };
                var q = a.a.e.I(), p = a.a.e.I();
                a.tc = function(b, c) {
                    if (2 == arguments.length) a.a.e.set(b, p, c), c.P && c.P.Ac(b); else return a.a.e.get(b, p);
                };
                a.Ja = function(b, c, d) {
                    1 === b.nodeType && a.f.kc(b);
                    return m(b, c, h(d), !0);
                };
                a.Dc = function(b, c, d) {
                    d = h(d);
                    return a.Ja(b, e(c, d, b), d);
                };
                a.eb = function(a, b) {
                    1 !== b.nodeType && 8 !== b.nodeType || g(h(a), b, !0);
                };
                a.Rb = function(a, b) {
                    !v && x.jQuery && (v = x.jQuery);
                    if (b && 1 !== b.nodeType && 8 !== b.nodeType) throw Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");
                    b = b || x.document.body;
                    k(h(a), b, !0);
                };
                a.kb = function(b) {
                    switch (b.nodeType) {
                      case 1:
                      case 8:
                        var c = a.tc(b);
                        if (c) return c;
                        if (b.parentNode) return a.kb(b.parentNode);
                    }
                    return n;
                };
                a.Jc = function(b) {
                    return (b = a.kb(b)) ? b.$data : n;
                };
                a.b("bindingHandlers", a.d);
                a.b("applyBindings", a.Rb);
                a.b("applyBindingsToDescendants", a.eb);
                a.b("applyBindingAccessorsToNode", a.Ja);
                a.b("applyBindingsToNode", a.Dc);
                a.b("contextFor", a.kb);
                a.b("dataFor", a.Jc);
            })();
            (function(b) {
                function c(c, e) {
                    var m = f.hasOwnProperty(c) ? f[c] : b, h;
                    m ? m.X(e) : (m = f[c] = new a.J(), m.X(e), d(c, function(b, d) {
                        var e = !(!d || !d.synchronous);
                        g[c] = {
                            definition: b,
                            Zc: e
                        };
                        delete f[c];
                        h || e ? m.notifySubscribers(b) : a.Y.Wa(function() {
                            m.notifySubscribers(b);
                        });
                    }), h = !0);
                }
                function d(a, b) {
                    e("getConfig", [ a ], function(c) {
                        c ? e("loadComponent", [ a, c ], function(a) {
                            b(a, c);
                        }) : b(null, null);
                    });
                }
                function e(c, d, f, h) {
                    h || (h = a.g.loaders.slice(0));
                    var g = h.shift();
                    if (g) {
                        var q = g[c];
                        if (q) {
                            var p = !1;
                            if (q.apply(g, d.concat(function(a) {
                                p ? f(null) : null !== a ? f(a) : e(c, d, f, h);
                            })) !== b && (p = !0, !g.suppressLoaderExceptions)) throw Error("Component loaders must supply values by invoking the callback, not by returning values synchronously.");
                        } else e(c, d, f, h);
                    } else f(null);
                }
                var f = {}, g = {};
                a.g = {
                    get: function(d, e) {
                        var f = g.hasOwnProperty(d) ? g[d] : b;
                        f ? f.Zc ? a.l.w(function() {
                            e(f.definition);
                        }) : a.Y.Wa(function() {
                            e(f.definition);
                        }) : c(d, e);
                    },
                    Xb: function(a) {
                        delete g[a];
                    },
                    Jb: e
                };
                a.g.loaders = [];
                a.b("components", a.g);
                a.b("components.get", a.g.get);
                a.b("components.clearCachedDefinition", a.g.Xb);
            })();
            (function() {
                function b(b, c, d, e) {
                    function g() {
                        0 === --y && e(k);
                    }
                    var k = {}, y = 2, t = d.template;
                    d = d.viewModel;
                    t ? f(c, t, function(c) {
                        a.g.Jb("loadTemplate", [ b, c ], function(a) {
                            k.template = a;
                            g();
                        });
                    }) : g();
                    d ? f(c, d, function(c) {
                        a.g.Jb("loadViewModel", [ b, c ], function(a) {
                            k[l] = a;
                            g();
                        });
                    }) : g();
                }
                function c(a, b, d) {
                    if ("function" === typeof b) d(function(a) {
                        return new b(a);
                    }); else if ("function" === typeof b[l]) d(b[l]); else if ("instance" in b) {
                        var e = b.instance;
                        d(function() {
                            return e;
                        });
                    } else "viewModel" in b ? c(a, b.viewModel, d) : a("Unknown viewModel value: " + b);
                }
                function d(b) {
                    switch (a.a.A(b)) {
                      case "script":
                        return a.a.ma(b.text);

                      case "textarea":
                        return a.a.ma(b.value);

                      case "template":
                        if (e(b.content)) return a.a.ua(b.content.childNodes);
                    }
                    return a.a.ua(b.childNodes);
                }
                function e(a) {
                    return x.DocumentFragment ? a instanceof DocumentFragment : a && 11 === a.nodeType;
                }
                function f(a, b, c) {
                    "string" === typeof b.require ? O || x.require ? (O || x.require)([ b.require ], c) : a("Uses require, but no AMD loader is present") : c(b);
                }
                function g(a) {
                    return function(b) {
                        throw Error("Component '" + a + "': " + b);
                    };
                }
                var k = {};
                a.g.register = function(b, c) {
                    if (!c) throw Error("Invalid configuration for " + b);
                    if (a.g.ub(b)) throw Error("Component " + b + " is already registered");
                    k[b] = c;
                };
                a.g.ub = function(a) {
                    return k.hasOwnProperty(a);
                };
                a.g.od = function(b) {
                    delete k[b];
                    a.g.Xb(b);
                };
                a.g.Zb = {
                    getConfig: function(a, b) {
                        b(k.hasOwnProperty(a) ? k[a] : null);
                    },
                    loadComponent: function(a, c, d) {
                        var e = g(a);
                        f(e, c, function(c) {
                            b(a, e, c, d);
                        });
                    },
                    loadTemplate: function(b, c, f) {
                        b = g(b);
                        if ("string" === typeof c) f(a.a.ma(c)); else if (c instanceof Array) f(c); else if (e(c)) f(a.a.V(c.childNodes)); else if (c.element) if (c = c.element, 
                        x.HTMLElement ? c instanceof HTMLElement : c && c.tagName && 1 === c.nodeType) f(d(c)); else if ("string" === typeof c) {
                            var l = u.getElementById(c);
                            l ? f(d(l)) : b("Cannot find element with ID " + c);
                        } else b("Unknown element type: " + c); else b("Unknown template value: " + c);
                    },
                    loadViewModel: function(a, b, d) {
                        c(g(a), b, d);
                    }
                };
                var l = "createViewModel";
                a.b("components.register", a.g.register);
                a.b("components.isRegistered", a.g.ub);
                a.b("components.unregister", a.g.od);
                a.b("components.defaultLoader", a.g.Zb);
                a.g.loaders.push(a.g.Zb);
                a.g.Bc = k;
            })();
            (function() {
                function b(b, e) {
                    var f = b.getAttribute("params");
                    if (f) {
                        var f = c.parseBindingsString(f, e, b, {
                            valueAccessors: !0,
                            bindingParams: !0
                        }), f = a.a.Ca(f, function(c) {
                            return a.m(c, null, {
                                i: b
                            });
                        }), g = a.a.Ca(f, function(c) {
                            var e = c.t();
                            return c.ba() ? a.m({
                                read: function() {
                                    return a.a.c(c());
                                },
                                write: a.Ba(e) && function(a) {
                                    c()(a);
                                },
                                i: b
                            }) : e;
                        });
                        g.hasOwnProperty("$raw") || (g.$raw = f);
                        return g;
                    }
                    return {
                        $raw: {}
                    };
                }
                a.g.getComponentNameForNode = function(b) {
                    var c = a.a.A(b);
                    if (a.g.ub(c) && (-1 != c.indexOf("-") || "[object HTMLUnknownElement]" == "" + b || 8 >= a.a.C && b.tagName === c)) return c;
                };
                a.g.Ob = function(c, e, f, g) {
                    if (1 === e.nodeType) {
                        var k = a.g.getComponentNameForNode(e);
                        if (k) {
                            c = c || {};
                            if (c.component) throw Error('Cannot use the "component" binding on a custom element matching a component');
                            var l = {
                                name: k,
                                params: b(e, f)
                            };
                            c.component = g ? function() {
                                return l;
                            } : l;
                        }
                    }
                    return c;
                };
                var c = new a.Q();
                9 > a.a.C && (a.g.register = function(a) {
                    return function(b) {
                        u.createElement(b);
                        return a.apply(this, arguments);
                    };
                }(a.g.register), u.createDocumentFragment = function(b) {
                    return function() {
                        var c = b(), f = a.g.Bc, g;
                        for (g in f) f.hasOwnProperty(g) && c.createElement(g);
                        return c;
                    };
                }(u.createDocumentFragment));
            })();
            (function(b) {
                function c(b, c, d) {
                    c = c.template;
                    if (!c) throw Error("Component '" + b + "' has no template");
                    b = a.a.ua(c);
                    a.f.da(d, b);
                }
                function d(a, b, c, d) {
                    var e = a.createViewModel;
                    return e ? e.call(a, d, {
                        element: b,
                        templateNodes: c
                    }) : d;
                }
                var e = 0;
                a.d.component = {
                    init: function(f, g, k, l, m) {
                        function h() {
                            var a = r && r.dispose;
                            "function" === typeof a && a.call(r);
                            q = r = null;
                        }
                        var r, q, p = a.a.V(a.f.childNodes(f));
                        a.a.F.oa(f, h);
                        a.m(function() {
                            var l = a.a.c(g()), k, t;
                            "string" === typeof l ? k = l : (k = a.a.c(l.name), t = a.a.c(l.params));
                            if (!k) throw Error("No component name specified");
                            var n = q = ++e;
                            a.g.get(k, function(e) {
                                if (q === n) {
                                    h();
                                    if (!e) throw Error("Unknown component '" + k + "'");
                                    c(k, e, f);
                                    var g = d(e, f, p, t);
                                    e = m.createChildContext(g, b, function(a) {
                                        a.$component = g;
                                        a.$componentTemplateNodes = p;
                                    });
                                    r = g;
                                    a.eb(e, f);
                                }
                            });
                        }, null, {
                            i: f
                        });
                        return {
                            controlsDescendantBindings: !0
                        };
                    }
                };
                a.f.Z.component = !0;
            })();
            var S = {
                "class": "className",
                "for": "htmlFor"
            };
            a.d.attr = {
                update: function(b, c) {
                    var d = a.a.c(c()) || {};
                    a.a.D(d, function(c, d) {
                        d = a.a.c(d);
                        var g = !1 === d || null === d || d === n;
                        g && b.removeAttribute(c);
                        8 >= a.a.C && c in S ? (c = S[c], g ? b.removeAttribute(c) : b[c] = d) : g || b.setAttribute(c, d.toString());
                        "name" === c && a.a.rc(b, g ? "" : d.toString());
                    });
                }
            };
            (function() {
                a.d.checked = {
                    after: [ "value", "attr" ],
                    init: function(b, c, d) {
                        function e() {
                            var e = b.checked, f = p ? g() : e;
                            if (!a.va.Sa() && (!l || e)) {
                                var m = a.l.w(c);
                                if (h) {
                                    var k = r ? m.t() : m;
                                    q !== f ? (e && (a.a.pa(k, f, !0), a.a.pa(k, q, !1)), q = f) : a.a.pa(k, f, e);
                                    r && a.Ba(m) && m(k);
                                } else a.h.Ea(m, d, "checked", f, !0);
                            }
                        }
                        function f() {
                            var d = a.a.c(c());
                            b.checked = h ? 0 <= a.a.o(d, g()) : k ? d : g() === d;
                        }
                        var g = a.nc(function() {
                            return d.has("checkedValue") ? a.a.c(d.get("checkedValue")) : d.has("value") ? a.a.c(d.get("value")) : b.value;
                        }), k = "checkbox" == b.type, l = "radio" == b.type;
                        if (k || l) {
                            var m = c(), h = k && a.a.c(m) instanceof Array, r = !(h && m.push && m.splice), q = h ? g() : n, p = l || h;
                            l && !b.name && a.d.uniqueName.init(b, function() {
                                return !0;
                            });
                            a.m(e, null, {
                                i: b
                            });
                            a.a.p(b, "click", e);
                            a.m(f, null, {
                                i: b
                            });
                            m = n;
                        }
                    }
                };
                a.h.ea.checked = !0;
                a.d.checkedValue = {
                    update: function(b, c) {
                        b.value = a.a.c(c());
                    }
                };
            })();
            a.d.css = {
                update: function(b, c) {
                    var d = a.a.c(c());
                    null !== d && "object" == typeof d ? a.a.D(d, function(c, d) {
                        d = a.a.c(d);
                        a.a.bb(b, c, d);
                    }) : (d = a.a.$a(String(d || "")), a.a.bb(b, b.__ko__cssValue, !1), b.__ko__cssValue = d, 
                    a.a.bb(b, d, !0));
                }
            };
            a.d.enable = {
                update: function(b, c) {
                    var d = a.a.c(c());
                    d && b.disabled ? b.removeAttribute("disabled") : d || b.disabled || (b.disabled = !0);
                }
            };
            a.d.disable = {
                update: function(b, c) {
                    a.d.enable.update(b, function() {
                        return !a.a.c(c());
                    });
                }
            };
            a.d.event = {
                init: function(b, c, d, e, f) {
                    var g = c() || {};
                    a.a.D(g, function(g) {
                        "string" == typeof g && a.a.p(b, g, function(b) {
                            var m, h = c()[g];
                            if (h) {
                                try {
                                    var r = a.a.V(arguments);
                                    e = f.$data;
                                    r.unshift(e);
                                    m = h.apply(e, r);
                                } finally {
                                    !0 !== m && (b.preventDefault ? b.preventDefault() : b.returnValue = !1);
                                }
                                !1 === d.get(g + "Bubble") && (b.cancelBubble = !0, b.stopPropagation && b.stopPropagation());
                            }
                        });
                    });
                }
            };
            a.d.foreach = {
                ic: function(b) {
                    return function() {
                        var c = b(), d = a.a.zb(c);
                        if (!d || "number" == typeof d.length) return {
                            foreach: c,
                            templateEngine: a.W.sb
                        };
                        a.a.c(c);
                        return {
                            foreach: d.data,
                            as: d.as,
                            includeDestroyed: d.includeDestroyed,
                            afterAdd: d.afterAdd,
                            beforeRemove: d.beforeRemove,
                            afterRender: d.afterRender,
                            beforeMove: d.beforeMove,
                            afterMove: d.afterMove,
                            templateEngine: a.W.sb
                        };
                    };
                },
                init: function(b, c) {
                    return a.d.template.init(b, a.d.foreach.ic(c));
                },
                update: function(b, c, d, e, f) {
                    return a.d.template.update(b, a.d.foreach.ic(c), d, e, f);
                }
            };
            a.h.ta.foreach = !1;
            a.f.Z.foreach = !0;
            a.d.hasfocus = {
                init: function(b, c, d) {
                    function e(e) {
                        b.__ko_hasfocusUpdating = !0;
                        var f = b.ownerDocument;
                        if ("activeElement" in f) {
                            var g;
                            try {
                                g = f.activeElement;
                            } catch (h) {
                                g = f.body;
                            }
                            e = g === b;
                        }
                        f = c();
                        a.h.Ea(f, d, "hasfocus", e, !0);
                        b.__ko_hasfocusLastValue = e;
                        b.__ko_hasfocusUpdating = !1;
                    }
                    var f = e.bind(null, !0), g = e.bind(null, !1);
                    a.a.p(b, "focus", f);
                    a.a.p(b, "focusin", f);
                    a.a.p(b, "blur", g);
                    a.a.p(b, "focusout", g);
                },
                update: function(b, c) {
                    var d = !!a.a.c(c());
                    b.__ko_hasfocusUpdating || b.__ko_hasfocusLastValue === d || (d ? b.focus() : b.blur(), 
                    !d && b.__ko_hasfocusLastValue && b.ownerDocument.body.focus(), a.l.w(a.a.Da, null, [ b, d ? "focusin" : "focusout" ]));
                }
            };
            a.h.ea.hasfocus = !0;
            a.d.hasFocus = a.d.hasfocus;
            a.h.ea.hasFocus = !0;
            a.d.html = {
                init: function() {
                    return {
                        controlsDescendantBindings: !0
                    };
                },
                update: function(b, c) {
                    a.a.Cb(b, c());
                }
            };
            K("if");
            K("ifnot", !1, !0);
            K("with", !0, !1, function(a, c) {
                return a.createChildContext(c);
            });
            var L = {};
            a.d.options = {
                init: function(b) {
                    if ("select" !== a.a.A(b)) throw Error("options binding applies only to SELECT elements");
                    for (;0 < b.length; ) b.remove(0);
                    return {
                        controlsDescendantBindings: !0
                    };
                },
                update: function(b, c, d) {
                    function e() {
                        return a.a.Ka(b.options, function(a) {
                            return a.selected;
                        });
                    }
                    function f(a, b, c) {
                        var d = typeof b;
                        return "function" == d ? b(a) : "string" == d ? a[b] : c;
                    }
                    function g(c, e) {
                        if (A && h) a.j.ha(b, a.a.c(d.get("value")), !0); else if (p.length) {
                            var f = 0 <= a.a.o(p, a.j.u(e[0]));
                            a.a.sc(e[0], f);
                            A && !f && a.l.w(a.a.Da, null, [ b, "change" ]);
                        }
                    }
                    var k = b.multiple, l = 0 != b.length && k ? b.scrollTop : null, m = a.a.c(c()), h = d.get("valueAllowUnset") && d.has("value"), r = d.get("optionsIncludeDestroyed");
                    c = {};
                    var q, p = [];
                    h || (k ? p = a.a.fb(e(), a.j.u) : 0 <= b.selectedIndex && p.push(a.j.u(b.options[b.selectedIndex])));
                    m && ("undefined" == typeof m.length && (m = [ m ]), q = a.a.Ka(m, function(b) {
                        return r || b === n || null === b || !a.a.c(b._destroy);
                    }), d.has("optionsCaption") && (m = a.a.c(d.get("optionsCaption")), null !== m && m !== n && q.unshift(L)));
                    var A = !1;
                    c.beforeRemove = function(a) {
                        b.removeChild(a);
                    };
                    m = g;
                    d.has("optionsAfterRender") && "function" == typeof d.get("optionsAfterRender") && (m = function(b, c) {
                        g(0, c);
                        a.l.w(d.get("optionsAfterRender"), null, [ c[0], b !== L ? b : n ]);
                    });
                    a.a.Bb(b, q, function(c, e, g) {
                        g.length && (p = !h && g[0].selected ? [ a.j.u(g[0]) ] : [], A = !0);
                        e = b.ownerDocument.createElement("option");
                        c === L ? (a.a.Za(e, d.get("optionsCaption")), a.j.ha(e, n)) : (g = f(c, d.get("optionsValue"), c), 
                        a.j.ha(e, a.a.c(g)), c = f(c, d.get("optionsText"), g), a.a.Za(e, c));
                        return [ e ];
                    }, c, m);
                    a.l.w(function() {
                        h ? a.j.ha(b, a.a.c(d.get("value")), !0) : (k ? p.length && e().length < p.length : p.length && 0 <= b.selectedIndex ? a.j.u(b.options[b.selectedIndex]) !== p[0] : p.length || 0 <= b.selectedIndex) && a.a.Da(b, "change");
                    });
                    a.a.Nc(b);
                    l && 20 < Math.abs(l - b.scrollTop) && (b.scrollTop = l);
                }
            };
            a.d.options.xb = a.a.e.I();
            a.d.selectedOptions = {
                after: [ "options", "foreach" ],
                init: function(b, c, d) {
                    a.a.p(b, "change", function() {
                        var e = c(), f = [];
                        a.a.q(b.getElementsByTagName("option"), function(b) {
                            b.selected && f.push(a.j.u(b));
                        });
                        a.h.Ea(e, d, "selectedOptions", f);
                    });
                },
                update: function(b, c) {
                    if ("select" != a.a.A(b)) throw Error("values binding applies only to SELECT elements");
                    var d = a.a.c(c()), e = b.scrollTop;
                    d && "number" == typeof d.length && a.a.q(b.getElementsByTagName("option"), function(b) {
                        var c = 0 <= a.a.o(d, a.j.u(b));
                        b.selected != c && a.a.sc(b, c);
                    });
                    b.scrollTop = e;
                }
            };
            a.h.ea.selectedOptions = !0;
            a.d.style = {
                update: function(b, c) {
                    var d = a.a.c(c() || {});
                    a.a.D(d, function(c, d) {
                        d = a.a.c(d);
                        if (null === d || d === n || !1 === d) d = "";
                        b.style[c] = d;
                    });
                }
            };
            a.d.submit = {
                init: function(b, c, d, e, f) {
                    if ("function" != typeof c()) throw Error("The value for a submit binding must be a function");
                    a.a.p(b, "submit", function(a) {
                        var d, e = c();
                        try {
                            d = e.call(f.$data, b);
                        } finally {
                            !0 !== d && (a.preventDefault ? a.preventDefault() : a.returnValue = !1);
                        }
                    });
                }
            };
            a.d.text = {
                init: function() {
                    return {
                        controlsDescendantBindings: !0
                    };
                },
                update: function(b, c) {
                    a.a.Za(b, c());
                }
            };
            a.f.Z.text = !0;
            (function() {
                if (x && x.navigator) var b = function(a) {
                    if (a) return parseFloat(a[1]);
                }, c = x.opera && x.opera.version && parseInt(x.opera.version()), d = x.navigator.userAgent, e = b(d.match(/^(?:(?!chrome).)*version\/([^ ]*) safari/i)), f = b(d.match(/Firefox\/([^ ]*)/));
                if (10 > a.a.C) var g = a.a.e.I(), k = a.a.e.I(), l = function(b) {
                    var c = this.activeElement;
                    (c = c && a.a.e.get(c, k)) && c(b);
                }, m = function(b, c) {
                    var d = b.ownerDocument;
                    a.a.e.get(d, g) || (a.a.e.set(d, g, !0), a.a.p(d, "selectionchange", l));
                    a.a.e.set(b, k, c);
                };
                a.d.textInput = {
                    init: function(b, d, g) {
                        function l(c, d) {
                            a.a.p(b, c, d);
                        }
                        function k() {
                            var c = a.a.c(d());
                            if (null === c || c === n) c = "";
                            v !== n && c === v ? a.a.setTimeout(k, 4) : b.value !== c && (u = c, b.value = c);
                        }
                        function y() {
                            s || (v = b.value, s = a.a.setTimeout(t, 4));
                        }
                        function t() {
                            clearTimeout(s);
                            v = s = n;
                            var c = b.value;
                            u !== c && (u = c, a.h.Ea(d(), g, "textInput", c));
                        }
                        var u = b.value, s, v, x = 9 == a.a.C ? y : t;
                        10 > a.a.C ? (l("propertychange", function(a) {
                            "value" === a.propertyName && x(a);
                        }), 8 == a.a.C && (l("keyup", t), l("keydown", t)), 8 <= a.a.C && (m(b, x), l("dragend", y))) : (l("input", t), 
                        5 > e && "textarea" === a.a.A(b) ? (l("keydown", y), l("paste", y), l("cut", y)) : 11 > c ? l("keydown", y) : 4 > f && (l("DOMAutoComplete", t), 
                        l("dragdrop", t), l("drop", t)));
                        l("change", t);
                        a.m(k, null, {
                            i: b
                        });
                    }
                };
                a.h.ea.textInput = !0;
                a.d.textinput = {
                    preprocess: function(a, b, c) {
                        c("textInput", a);
                    }
                };
            })();
            a.d.uniqueName = {
                init: function(b, c) {
                    if (c()) {
                        var d = "ko_unique_" + ++a.d.uniqueName.Ic;
                        a.a.rc(b, d);
                    }
                }
            };
            a.d.uniqueName.Ic = 0;
            a.d.value = {
                after: [ "options", "foreach" ],
                init: function(b, c, d) {
                    if ("input" != b.tagName.toLowerCase() || "checkbox" != b.type && "radio" != b.type) {
                        var e = [ "change" ], f = d.get("valueUpdate"), g = !1, k = null;
                        f && ("string" == typeof f && (f = [ f ]), a.a.ra(e, f), e = a.a.Tb(e));
                        var l = function() {
                            k = null;
                            g = !1;
                            var e = c(), f = a.j.u(b);
                            a.h.Ea(e, d, "value", f);
                        };
                        !a.a.C || "input" != b.tagName.toLowerCase() || "text" != b.type || "off" == b.autocomplete || b.form && "off" == b.form.autocomplete || -1 != a.a.o(e, "propertychange") || (a.a.p(b, "propertychange", function() {
                            g = !0;
                        }), a.a.p(b, "focus", function() {
                            g = !1;
                        }), a.a.p(b, "blur", function() {
                            g && l();
                        }));
                        a.a.q(e, function(c) {
                            var d = l;
                            a.a.nd(c, "after") && (d = function() {
                                k = a.j.u(b);
                                a.a.setTimeout(l, 0);
                            }, c = c.substring(5));
                            a.a.p(b, c, d);
                        });
                        var m = function() {
                            var e = a.a.c(c()), f = a.j.u(b);
                            if (null !== k && e === k) a.a.setTimeout(m, 0); else if (e !== f) if ("select" === a.a.A(b)) {
                                var g = d.get("valueAllowUnset"), f = function() {
                                    a.j.ha(b, e, g);
                                };
                                f();
                                g || e === a.j.u(b) ? a.a.setTimeout(f, 0) : a.l.w(a.a.Da, null, [ b, "change" ]);
                            } else a.j.ha(b, e);
                        };
                        a.m(m, null, {
                            i: b
                        });
                    } else a.Ja(b, {
                        checkedValue: c
                    });
                },
                update: function() {}
            };
            a.h.ea.value = !0;
            a.d.visible = {
                update: function(b, c) {
                    var d = a.a.c(c()), e = "none" != b.style.display;
                    d && !e ? b.style.display = "" : !d && e && (b.style.display = "none");
                }
            };
            (function(b) {
                a.d[b] = {
                    init: function(c, d, e, f, g) {
                        return a.d.event.init.call(this, c, function() {
                            var a = {};
                            a[b] = d();
                            return a;
                        }, e, f, g);
                    }
                };
            })("click");
            a.O = function() {};
            a.O.prototype.renderTemplateSource = function() {
                throw Error("Override renderTemplateSource");
            };
            a.O.prototype.createJavaScriptEvaluatorBlock = function() {
                throw Error("Override createJavaScriptEvaluatorBlock");
            };
            a.O.prototype.makeTemplateSource = function(b, c) {
                if ("string" == typeof b) {
                    c = c || u;
                    var d = c.getElementById(b);
                    if (!d) throw Error("Cannot find template with ID " + b);
                    return new a.v.n(d);
                }
                if (1 == b.nodeType || 8 == b.nodeType) return new a.v.qa(b);
                throw Error("Unknown template type: " + b);
            };
            a.O.prototype.renderTemplate = function(a, c, d, e) {
                a = this.makeTemplateSource(a, e);
                return this.renderTemplateSource(a, c, d, e);
            };
            a.O.prototype.isTemplateRewritten = function(a, c) {
                return !1 === this.allowTemplateRewriting ? !0 : this.makeTemplateSource(a, c).data("isRewritten");
            };
            a.O.prototype.rewriteTemplate = function(a, c, d) {
                a = this.makeTemplateSource(a, d);
                c = c(a.text());
                a.text(c);
                a.data("isRewritten", !0);
            };
            a.b("templateEngine", a.O);
            a.Gb = function() {
                function b(b, c, d, k) {
                    b = a.h.yb(b);
                    for (var l = a.h.ta, m = 0; m < b.length; m++) {
                        var h = b[m].key;
                        if (l.hasOwnProperty(h)) {
                            var r = l[h];
                            if ("function" === typeof r) {
                                if (h = r(b[m].value)) throw Error(h);
                            } else if (!r) throw Error("This template engine does not support the '" + h + "' binding within its templates");
                        }
                    }
                    d = "ko.__tr_ambtns(function($context,$element){return(function(){return{ " + a.h.Ua(b, {
                        valueAccessors: !0
                    }) + " } })()},'" + d.toLowerCase() + "')";
                    return k.createJavaScriptEvaluatorBlock(d) + c;
                }
                var c = /(<([a-z]+\d*)(?:\s+(?!data-bind\s*=\s*)[a-z0-9\-]+(?:=(?:\"[^\"]*\"|\'[^\']*\'|[^>]*))?)*\s+)data-bind\s*=\s*(["'])([\s\S]*?)\3/gi, d = /\x3c!--\s*ko\b\s*([\s\S]*?)\s*--\x3e/g;
                return {
                    Oc: function(b, c, d) {
                        c.isTemplateRewritten(b, d) || c.rewriteTemplate(b, function(b) {
                            return a.Gb.dd(b, c);
                        }, d);
                    },
                    dd: function(a, f) {
                        return a.replace(c, function(a, c, d, e, h) {
                            return b(h, c, d, f);
                        }).replace(d, function(a, c) {
                            return b(c, "<!-- ko -->", "#comment", f);
                        });
                    },
                    Ec: function(b, c) {
                        return a.M.wb(function(d, k) {
                            var l = d.nextSibling;
                            l && l.nodeName.toLowerCase() === c && a.Ja(l, b, k);
                        });
                    }
                };
            }();
            a.b("__tr_ambtns", a.Gb.Ec);
            (function() {
                a.v = {};
                a.v.n = function(b) {
                    if (this.n = b) {
                        var c = a.a.A(b);
                        this.ab = "script" === c ? 1 : "textarea" === c ? 2 : "template" == c && b.content && 11 === b.content.nodeType ? 3 : 4;
                    }
                };
                a.v.n.prototype.text = function() {
                    var b = 1 === this.ab ? "text" : 2 === this.ab ? "value" : "innerHTML";
                    if (0 == arguments.length) return this.n[b];
                    var c = arguments[0];
                    "innerHTML" === b ? a.a.Cb(this.n, c) : this.n[b] = c;
                };
                var b = a.a.e.I() + "_";
                a.v.n.prototype.data = function(c) {
                    if (1 === arguments.length) return a.a.e.get(this.n, b + c);
                    a.a.e.set(this.n, b + c, arguments[1]);
                };
                var c = a.a.e.I();
                a.v.n.prototype.nodes = function() {
                    var b = this.n;
                    if (0 == arguments.length) return (a.a.e.get(b, c) || {}).jb || (3 === this.ab ? b.content : 4 === this.ab ? b : n);
                    a.a.e.set(b, c, {
                        jb: arguments[0]
                    });
                };
                a.v.qa = function(a) {
                    this.n = a;
                };
                a.v.qa.prototype = new a.v.n();
                a.v.qa.prototype.text = function() {
                    if (0 == arguments.length) {
                        var b = a.a.e.get(this.n, c) || {};
                        b.Hb === n && b.jb && (b.Hb = b.jb.innerHTML);
                        return b.Hb;
                    }
                    a.a.e.set(this.n, c, {
                        Hb: arguments[0]
                    });
                };
                a.b("templateSources", a.v);
                a.b("templateSources.domElement", a.v.n);
                a.b("templateSources.anonymousTemplate", a.v.qa);
            })();
            (function() {
                function b(b, c, d) {
                    var e;
                    for (c = a.f.nextSibling(c); b && (e = b) !== c; ) b = a.f.nextSibling(e), d(e, b);
                }
                function c(c, d) {
                    if (c.length) {
                        var e = c[0], f = c[c.length - 1], g = e.parentNode, k = a.Q.instance, n = k.preprocessNode;
                        if (n) {
                            b(e, f, function(a, b) {
                                var c = a.previousSibling, d = n.call(k, a);
                                d && (a === e && (e = d[0] || b), a === f && (f = d[d.length - 1] || c));
                            });
                            c.length = 0;
                            if (!e) return;
                            e === f ? c.push(e) : (c.push(e, f), a.a.za(c, g));
                        }
                        b(e, f, function(b) {
                            1 !== b.nodeType && 8 !== b.nodeType || a.Rb(d, b);
                        });
                        b(e, f, function(b) {
                            1 !== b.nodeType && 8 !== b.nodeType || a.M.yc(b, [ d ]);
                        });
                        a.a.za(c, g);
                    }
                }
                function d(a) {
                    return a.nodeType ? a : 0 < a.length ? a[0] : null;
                }
                function e(b, e, f, k, q) {
                    q = q || {};
                    var p = (b && d(b) || f || {}).ownerDocument, n = q.templateEngine || g;
                    a.Gb.Oc(f, n, p);
                    f = n.renderTemplate(f, k, q, p);
                    if ("number" != typeof f.length || 0 < f.length && "number" != typeof f[0].nodeType) throw Error("Template engine must return an array of DOM nodes");
                    p = !1;
                    switch (e) {
                      case "replaceChildren":
                        a.f.da(b, f);
                        p = !0;
                        break;

                      case "replaceNode":
                        a.a.qc(b, f);
                        p = !0;
                        break;

                      case "ignoreTargetNode":
                        break;

                      default:
                        throw Error("Unknown renderMode: " + e);
                    }
                    p && (c(f, k), q.afterRender && a.l.w(q.afterRender, null, [ f, k.$data ]));
                    return f;
                }
                function f(b, c, d) {
                    return a.H(b) ? b() : "function" === typeof b ? b(c, d) : b;
                }
                var g;
                a.Db = function(b) {
                    if (b != n && !(b instanceof a.O)) throw Error("templateEngine must inherit from ko.templateEngine");
                    g = b;
                };
                a.Ab = function(b, c, h, k, q) {
                    h = h || {};
                    if ((h.templateEngine || g) == n) throw Error("Set a template engine before calling renderTemplate");
                    q = q || "replaceChildren";
                    if (k) {
                        var p = d(k);
                        return a.B(function() {
                            var g = c && c instanceof a.U ? c : new a.U(a.a.c(c)), n = f(b, g.$data, g), g = e(k, q, n, g, h);
                            "replaceNode" == q && (k = g, p = d(k));
                        }, null, {
                            wa: function() {
                                return !p || !a.a.nb(p);
                            },
                            i: p && "replaceNode" == q ? p.parentNode : p
                        });
                    }
                    return a.M.wb(function(d) {
                        a.Ab(b, c, h, d, "replaceNode");
                    });
                };
                a.kd = function(b, d, g, k, q) {
                    function p(a, b) {
                        c(b, s);
                        g.afterRender && g.afterRender(b, a);
                        s = null;
                    }
                    function u(a, c) {
                        s = q.createChildContext(a, g.as, function(a) {
                            a.$index = c;
                        });
                        var d = f(b, a, s);
                        return e(null, "ignoreTargetNode", d, s, g);
                    }
                    var s;
                    return a.B(function() {
                        var b = a.a.c(d) || [];
                        "undefined" == typeof b.length && (b = [ b ]);
                        b = a.a.Ka(b, function(b) {
                            return g.includeDestroyed || b === n || null === b || !a.a.c(b._destroy);
                        });
                        a.l.w(a.a.Bb, null, [ k, b, u, g, p ]);
                    }, null, {
                        i: k
                    });
                };
                var k = a.a.e.I();
                a.d.template = {
                    init: function(b, c) {
                        var d = a.a.c(c());
                        if ("string" == typeof d || d.name) a.f.xa(b); else {
                            if ("nodes" in d) {
                                if (d = d.nodes || [], a.H(d)) throw Error('The "nodes" option must be a plain, non-observable array.');
                            } else d = a.f.childNodes(b);
                            d = a.a.jc(d);
                            new a.v.qa(b).nodes(d);
                        }
                        return {
                            controlsDescendantBindings: !0
                        };
                    },
                    update: function(b, c, d, e, f) {
                        var g = c(), s;
                        c = a.a.c(g);
                        d = !0;
                        e = null;
                        "string" == typeof c ? c = {} : (g = c.name, "if" in c && (d = a.a.c(c["if"])), 
                        d && "ifnot" in c && (d = !a.a.c(c.ifnot)), s = a.a.c(c.data));
                        "foreach" in c ? e = a.kd(g || b, d && c.foreach || [], c, b, f) : d ? (f = "data" in c ? f.createChildContext(s, c.as) : f, 
                        e = a.Ab(g || b, f, c, b)) : a.f.xa(b);
                        f = e;
                        (s = a.a.e.get(b, k)) && "function" == typeof s.k && s.k();
                        a.a.e.set(b, k, f && f.ba() ? f : n);
                    }
                };
                a.h.ta.template = function(b) {
                    b = a.h.yb(b);
                    return 1 == b.length && b[0].unknown || a.h.ad(b, "name") ? null : "This template engine does not support anonymous templates nested within its templates";
                };
                a.f.Z.template = !0;
            })();
            a.b("setTemplateEngine", a.Db);
            a.b("renderTemplate", a.Ab);
            a.a.dc = function(a, c, d) {
                if (a.length && c.length) {
                    var e, f, g, k, l;
                    for (e = f = 0; (!d || e < d) && (k = a[f]); ++f) {
                        for (g = 0; l = c[g]; ++g) if (k.value === l.value) {
                            k.moved = l.index;
                            l.moved = k.index;
                            c.splice(g, 1);
                            e = g = 0;
                            break;
                        }
                        e += g;
                    }
                }
            };
            a.a.ib = function() {
                function b(b, d, e, f, g) {
                    var k = Math.min, l = Math.max, m = [], h, n = b.length, q, p = d.length, s = p - n || 1, u = n + p + 1, t, v, x;
                    for (h = 0; h <= n; h++) for (v = t, m.push(t = []), x = k(p, h + s), q = l(0, h - 1); q <= x; q++) t[q] = q ? h ? b[h - 1] === d[q - 1] ? v[q - 1] : k(v[q] || u, t[q - 1] || u) + 1 : q + 1 : h + 1;
                    k = [];
                    l = [];
                    s = [];
                    h = n;
                    for (q = p; h || q; ) p = m[h][q] - 1, q && p === m[h][q - 1] ? l.push(k[k.length] = {
                        status: e,
                        value: d[--q],
                        index: q
                    }) : h && p === m[h - 1][q] ? s.push(k[k.length] = {
                        status: f,
                        value: b[--h],
                        index: h
                    }) : (--q, --h, g.sparse || k.push({
                        status: "retained",
                        value: d[q]
                    }));
                    a.a.dc(s, l, !g.dontLimitMoves && 10 * n);
                    return k.reverse();
                }
                return function(a, d, e) {
                    e = "boolean" === typeof e ? {
                        dontLimitMoves: e
                    } : e || {};
                    a = a || [];
                    d = d || [];
                    return a.length < d.length ? b(a, d, "added", "deleted", e) : b(d, a, "deleted", "added", e);
                };
            }();
            a.b("utils.compareArrays", a.a.ib);
            (function() {
                function b(b, c, d, k, l) {
                    var m = [], h = a.B(function() {
                        var h = c(d, l, a.a.za(m, b)) || [];
                        0 < m.length && (a.a.qc(m, h), k && a.l.w(k, null, [ d, h, l ]));
                        m.length = 0;
                        a.a.ra(m, h);
                    }, null, {
                        i: b,
                        wa: function() {
                            return !a.a.Qb(m);
                        }
                    });
                    return {
                        ca: m,
                        B: h.ba() ? h : n
                    };
                }
                var c = a.a.e.I(), d = a.a.e.I();
                a.a.Bb = function(e, f, g, k, l) {
                    function m(b, c) {
                        w = q[c];
                        v !== c && (D[b] = w);
                        w.qb(v++);
                        a.a.za(w.ca, e);
                        u.push(w);
                        z.push(w);
                    }
                    function h(b, c) {
                        if (b) for (var d = 0, e = c.length; d < e; d++) c[d] && a.a.q(c[d].ca, function(a) {
                            b(a, d, c[d].ja);
                        });
                    }
                    f = f || [];
                    k = k || {};
                    var r = a.a.e.get(e, c) === n, q = a.a.e.get(e, c) || [], p = a.a.fb(q, function(a) {
                        return a.ja;
                    }), s = a.a.ib(p, f, k.dontLimitMoves), u = [], t = 0, v = 0, x = [], z = [];
                    f = [];
                    for (var D = [], p = [], w, C = 0, B, E; B = s[C]; C++) switch (E = B.moved, B.status) {
                      case "deleted":
                        E === n && (w = q[t], w.B && (w.B.k(), w.B = n), a.a.za(w.ca, e).length && (k.beforeRemove && (u.push(w), 
                        z.push(w), w.ja === d ? w = null : f[C] = w), w && x.push.apply(x, w.ca)));
                        t++;
                        break;

                      case "retained":
                        m(C, t++);
                        break;

                      case "added":
                        E !== n ? m(C, E) : (w = {
                            ja: B.value,
                            qb: a.N(v++)
                        }, u.push(w), z.push(w), r || (p[C] = w));
                    }
                    a.a.e.set(e, c, u);
                    h(k.beforeMove, D);
                    a.a.q(x, k.beforeRemove ? a.$ : a.removeNode);
                    for (var C = 0, r = a.f.firstChild(e), F; w = z[C]; C++) {
                        w.ca || a.a.extend(w, b(e, g, w.ja, l, w.qb));
                        for (t = 0; s = w.ca[t]; r = s.nextSibling, F = s, t++) s !== r && a.f.gc(e, s, F);
                        !w.Wc && l && (l(w.ja, w.ca, w.qb), w.Wc = !0);
                    }
                    h(k.beforeRemove, f);
                    for (C = 0; C < f.length; ++C) f[C] && (f[C].ja = d);
                    h(k.afterMove, D);
                    h(k.afterAdd, p);
                };
            })();
            a.b("utils.setDomNodeChildrenFromArrayMapping", a.a.Bb);
            a.W = function() {
                this.allowTemplateRewriting = !1;
            };
            a.W.prototype = new a.O();
            a.W.prototype.renderTemplateSource = function(b, c, d, e) {
                if (c = (9 > a.a.C ? 0 : b.nodes) ? b.nodes() : null) return a.a.V(c.cloneNode(!0).childNodes);
                b = b.text();
                return a.a.ma(b, e);
            };
            a.W.sb = new a.W();
            a.Db(a.W.sb);
            a.b("nativeTemplateEngine", a.W);
            (function() {
                a.vb = function() {
                    var a = this.$c = function() {
                        if (!v || !v.tmpl) return 0;
                        try {
                            if (0 <= v.tmpl.tag.tmpl.open.toString().indexOf("__")) return 2;
                        } catch (a) {}
                        return 1;
                    }();
                    this.renderTemplateSource = function(b, e, f, g) {
                        g = g || u;
                        f = f || {};
                        if (2 > a) throw Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");
                        var k = b.data("precompiled");
                        k || (k = b.text() || "", k = v.template(null, "{{ko_with $item.koBindingContext}}" + k + "{{/ko_with}}"), 
                        b.data("precompiled", k));
                        b = [ e.$data ];
                        e = v.extend({
                            koBindingContext: e
                        }, f.templateOptions);
                        e = v.tmpl(k, b, e);
                        e.appendTo(g.createElement("div"));
                        v.fragments = {};
                        return e;
                    };
                    this.createJavaScriptEvaluatorBlock = function(a) {
                        return "{{ko_code ((function() { return " + a + " })()) }}";
                    };
                    this.addTemplate = function(a, b) {
                        u.write("<script type='text/html' id='" + a + "'>" + b + "</script>");
                    };
                    0 < a && (v.tmpl.tag.ko_code = {
                        open: "__.push($1 || '');"
                    }, v.tmpl.tag.ko_with = {
                        open: "with($1) {",
                        close: "} "
                    });
                };
                a.vb.prototype = new a.O();
                var b = new a.vb();
                0 < b.$c && a.Db(b);
                a.b("jqueryTmplTemplateEngine", a.vb);
            })();
        });
    })();
})();

(function(factory) {
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else if (typeof exports === "object") {
        module.exports = factory;
    } else {
        factory(jQuery);
    }
})(function($) {
    var toFix = [ "wheel", "mousewheel", "DOMMouseScroll", "MozMousePixelScroll" ], toBind = "onwheel" in document || document.documentMode >= 9 ? [ "wheel" ] : [ "mousewheel", "DomMouseScroll", "MozMousePixelScroll" ], slice = Array.prototype.slice, nullLowestDeltaTimeout, lowestDelta;
    if ($.event.fixHooks) {
        for (var i = toFix.length; i; ) {
            $.event.fixHooks[toFix[--i]] = $.event.mouseHooks;
        }
    }
    var special = $.event.special.mousewheel = {
        version: "3.1.12",
        setup: function() {
            if (this.addEventListener) {
                for (var i = toBind.length; i; ) {
                    this.addEventListener(toBind[--i], handler, false);
                }
            } else {
                this.onmousewheel = handler;
            }
            $.data(this, "mousewheel-line-height", special.getLineHeight(this));
            $.data(this, "mousewheel-page-height", special.getPageHeight(this));
        },
        teardown: function() {
            if (this.removeEventListener) {
                for (var i = toBind.length; i; ) {
                    this.removeEventListener(toBind[--i], handler, false);
                }
            } else {
                this.onmousewheel = null;
            }
            $.removeData(this, "mousewheel-line-height");
            $.removeData(this, "mousewheel-page-height");
        },
        getLineHeight: function(elem) {
            var $elem = $(elem), $parent = $elem["offsetParent" in $.fn ? "offsetParent" : "parent"]();
            if (!$parent.length) {
                $parent = $("body");
            }
            return parseInt($parent.css("fontSize"), 10) || parseInt($elem.css("fontSize"), 10) || 16;
        },
        getPageHeight: function(elem) {
            return $(elem).height();
        },
        settings: {
            adjustOldDeltas: true,
            normalizeOffset: true
        }
    };
    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind("mousewheel", fn) : this.trigger("mousewheel");
        },
        unmousewheel: function(fn) {
            return this.unbind("mousewheel", fn);
        }
    });
    function handler(event) {
        var orgEvent = event || window.event, args = slice.call(arguments, 1), delta = 0, deltaX = 0, deltaY = 0, absDelta = 0, offsetX = 0, offsetY = 0;
        event = $.event.fix(orgEvent);
        event.type = "mousewheel";
        if ("detail" in orgEvent) {
            deltaY = orgEvent.detail * -1;
        }
        if ("wheelDelta" in orgEvent) {
            deltaY = orgEvent.wheelDelta;
        }
        if ("wheelDeltaY" in orgEvent) {
            deltaY = orgEvent.wheelDeltaY;
        }
        if ("wheelDeltaX" in orgEvent) {
            deltaX = orgEvent.wheelDeltaX * -1;
        }
        if ("axis" in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }
        delta = deltaY === 0 ? deltaX : deltaY;
        if ("deltaY" in orgEvent) {
            deltaY = orgEvent.deltaY * -1;
            delta = deltaY;
        }
        if ("deltaX" in orgEvent) {
            deltaX = orgEvent.deltaX;
            if (deltaY === 0) {
                delta = deltaX * -1;
            }
        }
        if (deltaY === 0 && deltaX === 0) {
            return;
        }
        if (orgEvent.deltaMode === 1) {
            var lineHeight = $.data(this, "mousewheel-line-height");
            delta *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if (orgEvent.deltaMode === 2) {
            var pageHeight = $.data(this, "mousewheel-page-height");
            delta *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }
        absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));
        if (!lowestDelta || absDelta < lowestDelta) {
            lowestDelta = absDelta;
            if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
                lowestDelta /= 40;
            }
        }
        if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
            delta /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }
        delta = Math[delta >= 1 ? "floor" : "ceil"](delta / lowestDelta);
        deltaX = Math[deltaX >= 1 ? "floor" : "ceil"](deltaX / lowestDelta);
        deltaY = Math[deltaY >= 1 ? "floor" : "ceil"](deltaY / lowestDelta);
        if (special.settings.normalizeOffset && this.getBoundingClientRect) {
            var boundingRect = this.getBoundingClientRect();
            offsetX = event.clientX - boundingRect.left;
            offsetY = event.clientY - boundingRect.top;
        }
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        event.offsetX = offsetX;
        event.offsetY = offsetY;
        event.deltaMode = 0;
        args.unshift(event, delta, deltaX, deltaY);
        if (nullLowestDeltaTimeout) {
            clearTimeout(nullLowestDeltaTimeout);
        }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);
        return ($.event.dispatch || $.event.handle).apply(this, args);
    }
    function nullLowestDelta() {
        lowestDelta = null;
    }
    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        return special.settings.adjustOldDeltas && orgEvent.type === "mousewheel" && absDelta % 120 === 0;
    }
});

(function($) {
    var browserDetect = function() {
        var N = navigator.appName, ua = navigator.userAgent, tem, M = ua.match(/(opera|chrome|safari|firefox|msie)\/?\s*(\.?\d+(\.\d+)*)/i);
        if (M && (tem = ua.match(/version\/([\.\d]+)/i)) != null) {
            M[2] = tem[1];
        }
        M = M ? [ M[1], M[2] ] : [ N, navigator.appVersion, "-?" ];
        return M;
    }();
    function resize_auto_fired() {
        return browserDetect[0] === "msie" && parseInt(browserDetect[1]) < 9;
    }
    var splitterCounter = 0;
    $.fn.splitter = function(args) {
        args = args || {};
        return this.each(function() {
            if ($(this).attr("data-splitter-initialized")) {
                return;
            }
            var zombie;
            function setBarState(state) {
                bar.removeClass(opts.barStateClasses).addClass(state);
            }
            function startSplitMouse(evt) {
                if (evt.which !== 1) {
                    return;
                }
                bar.removeClass(opts.barHoverClass);
                if (opts.outline) {
                    zombie = zombie || bar.clone(false).insertAfter(A);
                    bar.removeClass(opts.barDockedClass);
                }
                setBarState(opts.barActiveClass);
                panes.css({
                    "user-select": "none",
                    "-webkit-user-select": "none",
                    "-khtml-user-select": "none",
                    "-moz-user-select": "none",
                    "pointer-events": "none"
                }).find("iframe").addClass(opts.iframeClass);
                A._posSplit = A[0][opts.pxSplit] - evt[opts.eventPos];
                $(document).bind("mousemove" + opts.eventNamespace, doSplitMouse).bind("mouseup" + opts.eventNamespace, endSplitMouse);
            }
            function doSplitMouse(evt) {
                var pos = A._posSplit + evt[opts.eventPos], range = Math.max(0, Math.min(pos, splitter._DA - bar._DA)), limit = Math.max(A._min, splitter._DA - B._max, Math.min(pos, A._max, splitter._DA - bar._DA - B._min));
                if (opts.outline) {
                    if (opts.dockPane === A && pos < Math.max(A._min, bar._DA) || opts.dockPane === B && pos > Math.min(pos, A._max, splitter._DA - bar._DA - B._min)) {
                        bar.addClass(opts.barDockedClass).css(opts.origin, range);
                    } else {
                        bar.removeClass(opts.barDockedClass).css(opts.origin, limit);
                    }
                    bar._DA = bar[0][opts.pxSplit];
                } else {
                    resplit(pos);
                }
                setBarState(pos === limit ? opts.barActiveClass : opts.barLimitClass);
            }
            function endSplitMouse(evt) {
                setBarState(opts.barNormalClass);
                bar.addClass(opts.barHoverClass);
                var pos = A._posSplit + evt[opts.eventPos];
                if (opts.outline) {
                    if (zombie) {
                        zombie.remove();
                    }
                    zombie = null;
                    resplit(pos);
                }
                panes.css({
                    "user-select": "text",
                    "-webkit-user-select": "text",
                    "-khtml-user-select": "text",
                    "-moz-user-select": "text",
                    "pointer-events": "auto"
                }).find("iframe").removeClass(opts.iframeClass);
                $(document).unbind("mousemove" + opts.eventNamespace + " mouseup" + opts.eventNamespace);
            }
            function resplit(pos) {
                bar._DA = bar[0][opts.pxSplit];
                if (opts.dockPane === A && pos < Math.max(A._min, bar._DA) || opts.dockPane === B && pos > Math.min(pos, A._max, splitter._DA - bar._DA - B._min)) {
                    bar.addClass(opts.barDockedClass);
                    bar._DA = bar[0][opts.pxSplit];
                    pos = opts.dockPane === A ? 0 : splitter._DA - bar._DA;
                    if (bar._pos === null) {
                        bar._pos = A[0][opts.pxSplit];
                    }
                } else {
                    bar.removeClass(opts.barDockedClass);
                    bar._DA = bar[0][opts.pxSplit];
                    bar._pos = null;
                    pos = Math.max(A._min, splitter._DA - B._max, Math.min(pos, A._max, splitter._DA - bar._DA - B._min));
                }
                bar.css(opts.origin, pos).css(opts.fixed, splitter._DF);
                A.css(opts.origin, 0).css(opts.split, pos).css(opts.fixed, splitter._DF);
                B.css(opts.origin, pos + bar._DA).css(opts.split, splitter._DA - bar._DA - pos).css(opts.fixed, splitter._DF);
                if (!resize_auto_fired()) {
                    panes.triggerHandler("resize");
                }
            }
            function dimSum(jq) {
                var sum = 0;
                for (var i = 1; i < arguments.length; i++) {
                    sum += Math.max(parseInt(jq.css(arguments[i]), 10) || 0, 0);
                }
                return sum;
            }
            function resize(size) {
                splitter._DF = splitter[0][opts.pxFixed] - splitter._PBF;
                splitter._DA = splitter[0][opts.pxSplit] - splitter._PBA;
                if (splitter._DF <= 0 || splitter._DA <= 0) {
                    return;
                }
                if (splitter._oldW === splitter.width() && splitter._oldH === splitter.height()) {
                    return;
                }
                splitter._oldW = splitter.width();
                splitter._oldH = splitter.height();
                resplit(!isNaN(size) ? size : !(opts.sizeRight || opts.sizeBottom) ? A[0][opts.pxSplit] : splitter._DA - B[0][opts.pxSplit] - bar._DA);
                setBarState(opts.barNormalClass);
            }
            var vh = (args.splitHorizontal ? "h" : args.splitVertical ? "v" : args.type) || "v";
            var opts = $.extend({
                splitterClass: "splitter ui-widget ui-widget-content",
                paneClass: "splitter-pane",
                barClass: "splitter-bar",
                barNormalClass: "ui-state-default",
                barHoverClass: "ui-state-hover",
                barActiveClass: "ui-state-highlight",
                barLimitClass: "ui-state-error",
                iframeClass: "splitter-iframe-hide",
                eventNamespace: ".splitter" + ++splitterCounter,
                pxPerKey: 8,
                tabIndex: 0,
                accessKey: "",
                dockSpeed: 1,
                undockSpeed: 1,
                dockEase: null,
                undockEase: null
            }, {
                v: {
                    keyLeft: 39,
                    keyRight: 37,
                    cursor: "e-resize",
                    barStateClass: "splitter-bar-vertical",
                    barDockedClass: "splitter-bar-vertical-docked"
                },
                h: {
                    keyTop: 40,
                    keyBottom: 38,
                    cursor: "n-resize",
                    barStateClass: "splitter-bar-horizontal",
                    barDockedClass: "splitter-bar-horizontal-docked"
                }
            }[vh], args, {
                v: {
                    type: "v",
                    eventPos: "pageX",
                    origin: "left",
                    split: "width",
                    pxSplit: "offsetWidth",
                    side1: "Left",
                    side2: "Right",
                    fixed: "height",
                    pxFixed: "offsetHeight",
                    side3: "Top",
                    side4: "Bottom"
                },
                h: {
                    type: "h",
                    eventPos: "pageY",
                    origin: "top",
                    split: "height",
                    pxSplit: "offsetHeight",
                    side1: "Top",
                    side2: "Bottom",
                    fixed: "width",
                    pxFixed: "offsetWidth",
                    side3: "Left",
                    side4: "Right"
                }
            }[vh]);
            opts.barStateClasses = [ opts.barNormalClass, opts.barHoverClass, opts.barActiveClass, opts.barLimitClass ].join(" ");
            var splitter = $(this).css({
                position: "relative"
            }).addClass(opts.splitterClass).attr("data-splitter-initialized", true);
            var panes = $(">*", splitter[0]).addClass(opts.paneClass).css({
                position: "absolute",
                "z-index": "1",
                "-moz-outline-style": "none"
            });
            var A = $(panes[0]), B = $(panes[1]);
            opts.dockPane = opts.dock && (/right|bottom/.test(opts.dock) ? B : A);
            var focuser = $("<a />").attr({
                accessKey: opts.accessKey,
                tabIndex: opts.tabIndex,
                title: opts.splitbarClass
            }).bind((browserDetect === "opera" ? "click" : "focus") + opts.eventNamespace, function() {
                this.focus();
                bar.addClass(opts.barActiveClass);
            }).bind("blur" + opts.eventNamespace, function() {
                bar.removeClass(opts.barActiveClass);
            });
            if (opts.accessKey !== "") {
                focuser.bind("keydown" + opts.eventNamespace, function(e) {
                    var key = e.which || e.keyCode;
                    var dir = key === opts["key" + opts.side1] ? 1 : key === opts["key" + opts.side2] ? -1 : 0;
                    if (dir) {
                        resplit(A[0][opts.pxSplit] + dir * opts.pxPerKey);
                    }
                });
            }
            var bar = $("<div />").insertAfter(A).addClass(opts.barClass).addClass(opts.barStateClass).append(focuser).attr({
                unselectable: "on"
            }).css({
                position: "absolute",
                "user-select": "none",
                "-webkit-user-select": "none",
                "-khtml-user-select": "none",
                "-moz-user-select": "none",
                "z-index": "100"
            }).bind("mousedown" + opts.eventNamespace, startSplitMouse).bind("mouseover" + opts.eventNamespace, function() {
                $(this).addClass(opts.barHoverClass);
            }).bind("mouseout" + opts.eventNamespace, function() {
                $(this).removeClass(opts.barHoverClass);
            });
            if (/^(auto|default|)$/.test(bar.css("cursor"))) {
                bar.css("cursor", opts.cursor);
            }
            bar._DA = bar[0][opts.pxSplit];
            splitter._PBF = dimSum(splitter, "border" + opts.side3 + "Width", "border" + opts.side4 + "Width");
            splitter._PBA = dimSum(splitter, "border" + opts.side1 + "Width", "border" + opts.side2 + "Width");
            A._pane = opts.side1;
            B._pane = opts.side2;
            $.each([ A, B ], function() {
                this._splitter_style = this.style;
                this._min = opts["min" + this._pane] || dimSum(this, "min-" + opts.split);
                this._max = opts["max" + this._pane] || dimSum(this, "max-" + opts.split) || 9999;
                this._init = opts["size" + this._pane] === true ? parseInt($.css(this[0], opts.split), 10) : opts["size" + this._pane];
            });
            var initPos = A._init;
            if (!isNaN(B._init)) {
                initPos = splitter[0][opts.pxSplit] - splitter._PBA - B._init - bar._DA;
            }
            if (isNaN(initPos)) {
                initPos = Math.round((splitter[0][opts.pxSplit] - splitter._PBA - bar._DA) / 2);
            }
            if (opts.anchorToWindow) {
                opts.resizeTo = window;
            }
            if (opts.resizeTo) {
                splitter._hadjust = dimSum(splitter, "borderTopWidth", "borderBottomWidth", "marginBottom");
                splitter._hmin = Math.max(dimSum(splitter, "minHeight"), 20);
                $(window).bind("resize" + opts.eventNamespace, function() {
                    var top = splitter.offset().top;
                    var eh = $(opts.resizeTo).height();
                    splitter.css("height", Math.max(eh - top - splitter._hadjust, splitter._hmin) + "px");
                    if (!resize_auto_fired()) {
                        splitter.triggerHandler("resize");
                    }
                }).triggerHandler("resize");
            } else if (opts.resizeToWidth && !resize_auto_fired()) {
                $(window).bind("resize" + opts.eventNamespace, function() {
                    resize();
                });
            }
            if (opts.dock) {
                splitter.bind("toggleDock" + opts.eventNamespace, function() {
                    var pw = opts.dockPane[0][opts.pxSplit];
                    splitter.triggerHandler(pw ? "dock" : "undock");
                }).bind("dock" + opts.eventNamespace, function() {
                    var pw = A[0][opts.pxSplit];
                    if (!pw) {
                        return;
                    }
                    bar._pos = pw;
                    var x = {};
                    x[opts.origin] = opts.dockPane === A ? 0 : splitter[0][opts.pxSplit] - splitter._PBA - bar[0][opts.pxSplit];
                    bar.animate(x, opts.dockSpeed || 1, opts.dockEasing, function() {
                        bar.addClass(opts.barDockedClass);
                        resplit(x[opts.origin]);
                    });
                }).bind("undock" + opts.eventNamespace, function() {
                    var pw = opts.dockPane[0][opts.pxSplit];
                    if (pw) {
                        return;
                    }
                    var x = {};
                    x[opts.origin] = bar._pos + "px";
                    bar.removeClass(opts.barDockedClass).animate(x, opts.undockSpeed || opts.dockSpeed || 1, opts.undockEasing || opts.dockEasing, function() {
                        resplit(bar._pos);
                        bar._pos = null;
                    });
                });
                if (opts.dockKey) {
                    $('<a title="' + opts.splitbarClass + ' toggle dock"></a>').attr({
                        accessKey: opts.dockKey,
                        tabIndex: -1
                    }).appendTo(bar).bind(browserDetect === "opera" ? "click" : "focus", function() {
                        splitter.triggerHandler("toggleDock");
                        this.blur();
                    });
                }
                bar.bind("dblclick", function() {
                    splitter.triggerHandler("toggleDock");
                });
            }
            splitter.bind("destroy" + opts.eventNamespace, function() {
                $([ window, document ]).unbind(opts.eventNamespace);
                bar.unbind().remove();
                panes.removeClass(opts.paneClass);
                splitter.removeClass(opts.splitterClass).add(panes).unbind(opts.eventNamespace).attr("style", function() {
                    return this._splitter_style || "";
                });
                splitter = bar = focuser = panes = A = B = opts = args = null;
            }).bind("resize" + opts.eventNamespace, function(e, size) {
                resize(size);
            }).triggerHandler("resize", [ initPos ]);
        });
    };
})(jQuery);

(function(factory) {
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else if (typeof exports === "object") {
        factory(require("jquery"));
    } else {
        factory(jQuery);
    }
})(function($) {
    "use strict";
    $.support.htmlMenuitem = "HTMLMenuItemElement" in window;
    $.support.htmlCommand = "HTMLCommandElement" in window;
    $.support.eventSelectstart = "onselectstart" in document.documentElement;
    if (!$.ui || !$.widget) {
        $.cleanData = function(orig) {
            return function(elems) {
                var events, elem, i;
                for (i = 0; (elem = elems[i]) != null; i++) {
                    try {
                        events = $._data(elem, "events");
                        if (events && events.remove) {
                            $(elem).triggerHandler("remove");
                        }
                    } catch (e) {}
                }
                orig(elems);
            };
        }($.cleanData);
    }
    var $currentTrigger = null, initialized = false, $win = $(window), counter = 0, namespaces = {}, menus = {}, types = {}, defaults = {
        selector: null,
        appendTo: null,
        trigger: "right",
        autoHide: false,
        delay: 200,
        reposition: true,
        classNames: {
            hover: "context-menu-hover",
            disabled: "context-menu-disabled",
            visible: "context-menu-visible",
            notSelectable: "context-menu-not-selectable",
            icon: "context-menu-icon",
            iconEdit: "context-menu-icon-edit",
            iconCut: "context-menu-icon-cut",
            iconCopy: "context-menu-icon-copy",
            iconPaste: "context-menu-icon-paste",
            iconDelete: "context-menu-icon-delete",
            iconAdd: "context-menu-icon-add",
            iconQuit: "context-menu-icon-quit"
        },
        determinePosition: function($menu) {
            if ($.ui && $.ui.position) {
                $menu.css("display", "block").position({
                    my: "center top",
                    at: "center bottom",
                    of: this,
                    offset: "0 5",
                    collision: "fit"
                }).css("display", "none");
            } else {
                var offset = this.offset();
                offset.top += this.outerHeight();
                offset.left += this.outerWidth() / 2 - $menu.outerWidth() / 2;
                $menu.css(offset);
            }
        },
        position: function(opt, x, y) {
            var offset;
            if (!x && !y) {
                opt.determinePosition.call(this, opt.$menu);
                return;
            } else if (x === "maintain" && y === "maintain") {
                offset = opt.$menu.position();
            } else {
                offset = {
                    top: y,
                    left: x
                };
            }
            var bottom = $win.scrollTop() + $win.height(), right = $win.scrollLeft() + $win.width(), height = opt.$menu.outerHeight(), width = opt.$menu.outerWidth();
            if (offset.top + height > bottom) {
                offset.top -= height;
            }
            if (offset.top < 0) {
                offset.top = 0;
            }
            if (offset.left + width > right) {
                offset.left -= width;
            }
            if (offset.left < 0) {
                offset.left = 0;
            }
            opt.$menu.css(offset);
        },
        positionSubmenu: function($menu) {
            if ($.ui && $.ui.position) {
                $menu.css("display", "block").position({
                    my: "left top",
                    at: "right top",
                    of: this,
                    collision: "flipfit fit"
                }).css("display", "");
            } else {
                var offset = {
                    top: 0,
                    left: this.outerWidth()
                };
                $menu.css(offset);
            }
        },
        zIndex: 1,
        animation: {
            duration: 50,
            show: "slideDown",
            hide: "slideUp"
        },
        events: {
            show: $.noop,
            hide: $.noop
        },
        callback: null,
        items: {}
    }, hoveract = {
        timer: null,
        pageX: null,
        pageY: null
    }, zindex = function($t) {
        var zin = 0, $tt = $t;
        while (true) {
            zin = Math.max(zin, parseInt($tt.css("z-index"), 10) || 0);
            $tt = $tt.parent();
            if (!$tt || !$tt.length || "html body".indexOf($tt.prop("nodeName").toLowerCase()) > -1) {
                break;
            }
        }
        return zin;
    }, handle = {
        abortevent: function(e) {
            e.preventDefault();
            e.stopImmediatePropagation();
        },
        contextmenu: function(e) {
            var $this = $(this);
            if (e.data.trigger === "right") {
                e.preventDefault();
                e.stopImmediatePropagation();
            }
            if (e.data.trigger !== "right" && e.data.trigger !== "demand" && e.originalEvent) {
                return;
            }
            if (e.mouseButton !== undefined && e.data) {
                if (!(e.data.trigger == "left" && e.mouseButton === 0) && !(e.data.trigger == "right" && e.mouseButton === 2)) {
                    return;
                }
            }
            if ($this.hasClass("context-menu-active")) {
                return;
            }
            if (!$this.hasClass("context-menu-disabled")) {
                $currentTrigger = $this;
                if (e.data.build) {
                    var built = e.data.build($currentTrigger, e);
                    if (built === false) {
                        return;
                    }
                    e.data = $.extend(true, {}, defaults, e.data, built || {});
                    if (!e.data.items || $.isEmptyObject(e.data.items)) {
                        if (window.console) {
                            (console.error || console.log).call(console, "No items specified to show in contextMenu");
                        }
                        throw new Error("No Items specified");
                    }
                    e.data.$trigger = $currentTrigger;
                    op.create(e.data);
                }
                var showMenu = false;
                for (var item in e.data.items) {
                    if (e.data.items.hasOwnProperty(item)) {
                        var visible;
                        if ($.isFunction(e.data.items[item].visible)) {
                            visible = e.data.items[item].visible.call($(e.currentTarget), item, e.data);
                        } else if (typeof item.visible !== "undefined") {
                            visible = e.data.items[item].visible === true;
                        } else {
                            visible = true;
                        }
                        if (visible) {
                            showMenu = true;
                        }
                    }
                }
                if (showMenu) {
                    op.show.call($this, e.data, e.pageX, e.pageY);
                }
            }
        },
        click: function(e) {
            e.preventDefault();
            e.stopImmediatePropagation();
            $(this).trigger($.Event("contextmenu", {
                data: e.data,
                pageX: e.pageX,
                pageY: e.pageY
            }));
        },
        mousedown: function(e) {
            var $this = $(this);
            if ($currentTrigger && $currentTrigger.length && !$currentTrigger.is($this)) {
                $currentTrigger.data("contextMenu").$menu.trigger("contextmenu:hide");
            }
            if (e.button === 2) {
                $currentTrigger = $this.data("contextMenuActive", true);
            }
        },
        mouseup: function(e) {
            var $this = $(this);
            if ($this.data("contextMenuActive") && $currentTrigger && $currentTrigger.length && $currentTrigger.is($this) && !$this.hasClass("context-menu-disabled")) {
                e.preventDefault();
                e.stopImmediatePropagation();
                $currentTrigger = $this;
                $this.trigger($.Event("contextmenu", {
                    data: e.data,
                    pageX: e.pageX,
                    pageY: e.pageY
                }));
            }
            $this.removeData("contextMenuActive");
        },
        mouseenter: function(e) {
            var $this = $(this), $related = $(e.relatedTarget), $document = $(document);
            if ($related.is(".context-menu-list") || $related.closest(".context-menu-list").length) {
                return;
            }
            if ($currentTrigger && $currentTrigger.length) {
                return;
            }
            hoveract.pageX = e.pageX;
            hoveract.pageY = e.pageY;
            hoveract.data = e.data;
            $document.on("mousemove.contextMenuShow", handle.mousemove);
            hoveract.timer = setTimeout(function() {
                hoveract.timer = null;
                $document.off("mousemove.contextMenuShow");
                $currentTrigger = $this;
                $this.trigger($.Event("contextmenu", {
                    data: hoveract.data,
                    pageX: hoveract.pageX,
                    pageY: hoveract.pageY
                }));
            }, e.data.delay);
        },
        mousemove: function(e) {
            hoveract.pageX = e.pageX;
            hoveract.pageY = e.pageY;
        },
        mouseleave: function(e) {
            var $related = $(e.relatedTarget);
            if ($related.is(".context-menu-list") || $related.closest(".context-menu-list").length) {
                return;
            }
            try {
                clearTimeout(hoveract.timer);
            } catch (e) {}
            hoveract.timer = null;
        },
        layerClick: function(e) {
            var $this = $(this), root = $this.data("contextMenuRoot"), button = e.button, x = e.pageX, y = e.pageY, target, offset;
            e.preventDefault();
            e.stopImmediatePropagation();
            setTimeout(function() {
                var $window;
                var triggerAction = root.trigger === "left" && button === 0 || root.trigger === "right" && button === 2;
                if (document.elementFromPoint && root.$layer) {
                    root.$layer.hide();
                    target = document.elementFromPoint(x - $win.scrollLeft(), y - $win.scrollTop());
                    root.$layer.show();
                }
                if (root.reposition && triggerAction) {
                    if (document.elementFromPoint) {
                        if (root.$trigger.is(target) || root.$trigger.has(target).length) {
                            root.position.call(root.$trigger, root, x, y);
                            return;
                        }
                    } else {
                        offset = root.$trigger.offset();
                        $window = $(window);
                        offset.top += $window.scrollTop();
                        if (offset.top <= e.pageY) {
                            offset.left += $window.scrollLeft();
                            if (offset.left <= e.pageX) {
                                offset.bottom = offset.top + root.$trigger.outerHeight();
                                if (offset.bottom >= e.pageY) {
                                    offset.right = offset.left + root.$trigger.outerWidth();
                                    if (offset.right >= e.pageX) {
                                        root.position.call(root.$trigger, root, x, y);
                                        return;
                                    }
                                }
                            }
                        }
                    }
                }
                if (target && triggerAction) {
                    root.$trigger.one("contextmenu:hidden", function() {
                        $(target).contextMenu({
                            x: x,
                            y: y,
                            button: button
                        });
                    });
                }
                root.$menu.trigger("contextmenu:hide");
            }, 50);
        },
        keyStop: function(e, opt) {
            if (!opt.isInput) {
                e.preventDefault();
            }
            e.stopPropagation();
        },
        key: function(e) {
            var opt = {};
            if ($currentTrigger) {
                opt = $currentTrigger.data("contextMenu") || {};
            }
            switch (e.keyCode) {
              case 9:
              case 38:
                handle.keyStop(e, opt);
                if (opt.isInput) {
                    if (e.keyCode === 9 && e.shiftKey) {
                        e.preventDefault();
                        opt.$selected && opt.$selected.find("input, textarea, select").blur();
                        opt.$menu.trigger("prevcommand");
                        return;
                    } else if (e.keyCode === 38 && opt.$selected.find("input, textarea, select").prop("type") === "checkbox") {
                        e.preventDefault();
                        return;
                    }
                } else if (e.keyCode !== 9 || e.shiftKey) {
                    opt.$menu.trigger("prevcommand");
                    return;
                }

              case 40:
                handle.keyStop(e, opt);
                if (opt.isInput) {
                    if (e.keyCode === 9) {
                        e.preventDefault();
                        opt.$selected && opt.$selected.find("input, textarea, select").blur();
                        opt.$menu.trigger("nextcommand");
                        return;
                    } else if (e.keyCode === 40 && opt.$selected.find("input, textarea, select").prop("type") === "checkbox") {
                        e.preventDefault();
                        return;
                    }
                } else {
                    opt.$menu.trigger("nextcommand");
                    return;
                }
                break;

              case 37:
                handle.keyStop(e, opt);
                if (opt.isInput || !opt.$selected || !opt.$selected.length) {
                    break;
                }
                if (!opt.$selected.parent().hasClass("context-menu-root")) {
                    var $parent = opt.$selected.parent().parent();
                    opt.$selected.trigger("contextmenu:blur");
                    opt.$selected = $parent;
                    return;
                }
                break;

              case 39:
                handle.keyStop(e, opt);
                if (opt.isInput || !opt.$selected || !opt.$selected.length) {
                    break;
                }
                var itemdata = opt.$selected.data("contextMenu") || {};
                if (itemdata.$menu && opt.$selected.hasClass("context-menu-submenu")) {
                    opt.$selected = null;
                    itemdata.$selected = null;
                    itemdata.$menu.trigger("nextcommand");
                    return;
                }
                break;

              case 35:
              case 36:
                if (opt.$selected && opt.$selected.find("input, textarea, select").length) {
                    return;
                } else {
                    (opt.$selected && opt.$selected.parent() || opt.$menu).children(":not(." + opt.classNames.disabled + ", ." + opt.classNames.notSelectable + ")")[e.keyCode === 36 ? "first" : "last"]().trigger("contextmenu:focus");
                    e.preventDefault();
                    return;
                }
                break;

              case 13:
                handle.keyStop(e, opt);
                if (opt.isInput) {
                    if (opt.$selected && !opt.$selected.is("textarea, select")) {
                        e.preventDefault();
                        return;
                    }
                    break;
                }
                if (typeof opt.$selected !== "undefined" && opt.$selected !== null) {
                    opt.$selected.trigger("mouseup");
                }
                return;

              case 32:
              case 33:
              case 34:
                handle.keyStop(e, opt);
                return;

              case 27:
                handle.keyStop(e, opt);
                opt.$menu.trigger("contextmenu:hide");
                return;

              default:
                var k = String.fromCharCode(e.keyCode).toUpperCase();
                if (opt.accesskeys && opt.accesskeys[k]) {
                    opt.accesskeys[k].$node.trigger(opt.accesskeys[k].$menu ? "contextmenu:focus" : "mouseup");
                    return;
                }
                break;
            }
            e.stopPropagation();
            if (typeof opt.$selected !== "undefined" && opt.$selected !== null) {
                opt.$selected.trigger(e);
            }
        },
        prevItem: function(e) {
            e.stopPropagation();
            var opt = $(this).data("contextMenu") || {};
            var root = $(this).data("contextMenuRoot") || {};
            if (opt.$selected) {
                var $s = opt.$selected;
                opt = opt.$selected.parent().data("contextMenu") || {};
                opt.$selected = $s;
            }
            var $children = opt.$menu.children(), $prev = !opt.$selected || !opt.$selected.prev().length ? $children.last() : opt.$selected.prev(), $round = $prev;
            while ($prev.hasClass(root.classNames.disabled) || $prev.hasClass(root.classNames.notSelectable)) {
                if ($prev.prev().length) {
                    $prev = $prev.prev();
                } else {
                    $prev = $children.last();
                }
                if ($prev.is($round)) {
                    return;
                }
            }
            if (opt.$selected) {
                handle.itemMouseleave.call(opt.$selected.get(0), e);
            }
            handle.itemMouseenter.call($prev.get(0), e);
            var $input = $prev.find("input, textarea, select");
            if ($input.length) {
                $input.focus();
            }
        },
        nextItem: function(e) {
            e.stopPropagation();
            var opt = $(this).data("contextMenu") || {};
            var root = $(this).data("contextMenuRoot") || {};
            if (opt.$selected) {
                var $s = opt.$selected;
                opt = opt.$selected.parent().data("contextMenu") || {};
                opt.$selected = $s;
            }
            var $children = opt.$menu.children(), $next = !opt.$selected || !opt.$selected.next().length ? $children.first() : opt.$selected.next(), $round = $next;
            while ($next.hasClass(root.classNames.disabled) || $next.hasClass(root.classNames.notSelectable)) {
                if ($next.next().length) {
                    $next = $next.next();
                } else {
                    $next = $children.first();
                }
                if ($next.is($round)) {
                    return;
                }
            }
            if (opt.$selected) {
                handle.itemMouseleave.call(opt.$selected.get(0), e);
            }
            handle.itemMouseenter.call($next.get(0), e);
            var $input = $next.find("input, textarea, select");
            if ($input.length) {
                $input.focus();
            }
        },
        focusInput: function() {
            var $this = $(this).closest(".context-menu-item"), data = $this.data(), opt = data.contextMenu, root = data.contextMenuRoot;
            root.$selected = opt.$selected = $this;
            root.isInput = opt.isInput = true;
        },
        blurInput: function() {
            var $this = $(this).closest(".context-menu-item"), data = $this.data(), opt = data.contextMenu, root = data.contextMenuRoot;
            root.isInput = opt.isInput = false;
        },
        menuMouseenter: function() {
            var root = $(this).data().contextMenuRoot;
            root.hovering = true;
        },
        menuMouseleave: function(e) {
            var root = $(this).data().contextMenuRoot;
            if (root.$layer && root.$layer.is(e.relatedTarget)) {
                root.hovering = false;
            }
        },
        itemMouseenter: function(e) {
            var $this = $(this), data = $this.data(), opt = data.contextMenu, root = data.contextMenuRoot;
            root.hovering = true;
            if (e && root.$layer && root.$layer.is(e.relatedTarget)) {
                e.preventDefault();
                e.stopImmediatePropagation();
            }
            (opt.$menu ? opt : root).$menu.children(".hover").trigger("contextmenu:blur");
            if ($this.hasClass(root.classNames.disabled) || $this.hasClass(root.classNames.notSelectable)) {
                opt.$selected = null;
                return;
            }
            $this.trigger("contextmenu:focus");
        },
        itemMouseleave: function(e) {
            var $this = $(this), data = $this.data(), opt = data.contextMenu, root = data.contextMenuRoot;
            if (root !== opt && root.$layer && root.$layer.is(e.relatedTarget)) {
                if (typeof root.$selected !== "undefined" && root.$selected !== null) {
                    root.$selected.trigger("contextmenu:blur");
                }
                e.preventDefault();
                e.stopImmediatePropagation();
                root.$selected = opt.$selected = opt.$node;
                return;
            }
            $this.trigger("contextmenu:blur");
        },
        itemClick: function(e) {
            var $this = $(this), data = $this.data(), opt = data.contextMenu, root = data.contextMenuRoot, key = data.contextMenuKey, callback;
            if (!opt.items[key] || $this.is("." + root.classNames.disabled + ", .context-menu-submenu, .context-menu-separator, ." + root.classNames.notSelectable)) {
                return;
            }
            e.preventDefault();
            e.stopImmediatePropagation();
            if ($.isFunction(root.callbacks[key]) && Object.prototype.hasOwnProperty.call(root.callbacks, key)) {
                callback = root.callbacks[key];
            } else if ($.isFunction(root.callback)) {
                callback = root.callback;
            } else {
                return;
            }
            if (callback.call(root.$trigger, key, root) !== false) {
                root.$menu.trigger("contextmenu:hide");
            } else if (root.$menu.parent().length) {
                op.update.call(root.$trigger, root);
            }
        },
        inputClick: function(e) {
            e.stopImmediatePropagation();
        },
        hideMenu: function(e, data) {
            var root = $(this).data("contextMenuRoot");
            op.hide.call(root.$trigger, root, data && data.force);
        },
        focusItem: function(e) {
            e.stopPropagation();
            var $this = $(this), data = $this.data(), opt = data.contextMenu, root = data.contextMenuRoot;
            $this.addClass([ root.classNames.hover, root.classNames.visible ].join(" ")).siblings().removeClass(root.classNames.visible).filter(root.classNames.hover).trigger("contextmenu:blur");
            opt.$selected = root.$selected = $this;
            if (opt.$node) {
                root.positionSubmenu.call(opt.$node, opt.$menu);
            }
        },
        blurItem: function(e) {
            e.stopPropagation();
            var $this = $(this), data = $this.data(), opt = data.contextMenu, root = data.contextMenuRoot;
            if (opt.autoHide) {
                $this.removeClass(root.classNames.visible);
            }
            $this.removeClass(root.classNames.hover);
            opt.$selected = null;
        }
    }, op = {
        show: function(opt, x, y) {
            var $trigger = $(this), css = {};
            $("#context-menu-layer").trigger("mousedown");
            opt.$trigger = $trigger;
            if (opt.events.show.call($trigger, opt) === false) {
                $currentTrigger = null;
                return;
            }
            op.update.call($trigger, opt);
            opt.position.call($trigger, opt, x, y);
            if (opt.zIndex) {
                css.zIndex = zindex($trigger) + opt.zIndex;
            }
            op.layer.call(opt.$menu, opt, css.zIndex);
            opt.$menu.find("ul").css("zIndex", css.zIndex + 1);
            opt.$menu.css(css)[opt.animation.show](opt.animation.duration, function() {
                $trigger.trigger("contextmenu:visible");
            });
            $trigger.data("contextMenu", opt).addClass("context-menu-active");
            $(document).off("keydown.contextMenu").on("keydown.contextMenu", handle.key);
            if (opt.autoHide) {
                $(document).on("mousemove.contextMenuAutoHide", function(e) {
                    var pos = $trigger.offset();
                    pos.right = pos.left + $trigger.outerWidth();
                    pos.bottom = pos.top + $trigger.outerHeight();
                    if (opt.$layer && !opt.hovering && (!(e.pageX >= pos.left && e.pageX <= pos.right) || !(e.pageY >= pos.top && e.pageY <= pos.bottom))) {
                        opt.$menu.trigger("contextmenu:hide");
                    }
                });
            }
        },
        hide: function(opt, force) {
            var $trigger = $(this);
            if (!opt) {
                opt = $trigger.data("contextMenu") || {};
            }
            if (!force && opt.events && opt.events.hide.call($trigger, opt) === false) {
                return;
            }
            $trigger.removeData("contextMenu").removeClass("context-menu-active");
            if (opt.$layer) {
                setTimeout(function($layer) {
                    return function() {
                        $layer.remove();
                    };
                }(opt.$layer), 10);
                try {
                    delete opt.$layer;
                } catch (e) {
                    opt.$layer = null;
                }
            }
            $currentTrigger = null;
            opt.$menu.find("." + opt.classNames.hover).trigger("contextmenu:blur");
            opt.$selected = null;
            $(document).off(".contextMenuAutoHide").off("keydown.contextMenu");
            opt.$menu && opt.$menu[opt.animation.hide](opt.animation.duration, function() {
                if (opt.build) {
                    opt.$menu.remove();
                    $.each(opt, function(key) {
                        switch (key) {
                          case "ns":
                          case "selector":
                          case "build":
                          case "trigger":
                            return true;

                          default:
                            opt[key] = undefined;
                            try {
                                delete opt[key];
                            } catch (e) {}
                            return true;
                        }
                    });
                }
                setTimeout(function() {
                    $trigger.trigger("contextmenu:hidden");
                }, 10);
            });
        },
        create: function(opt, root) {
            if (root === undefined) {
                root = opt;
            }
            opt.$menu = $('<ul class="context-menu-list"></ul>').addClass(opt.className || "").data({
                contextMenu: opt,
                contextMenuRoot: root
            });
            $.each([ "callbacks", "commands", "inputs" ], function(i, k) {
                opt[k] = {};
                if (!root[k]) {
                    root[k] = {};
                }
            });
            root.accesskeys || (root.accesskeys = {});
            function createNameNode(item) {
                var $name = $("<span></span>");
                if (item._accesskey) {
                    if (item._beforeAccesskey) {
                        $name.append(document.createTextNode(item._beforeAccesskey));
                    }
                    $("<span></span>").addClass("context-menu-accesskey").text(item._accesskey).appendTo($name);
                    if (item._afterAccesskey) {
                        $name.append(document.createTextNode(item._afterAccesskey));
                    }
                } else {
                    $name.text(item.name);
                }
                return $name;
            }
            $.each(opt.items, function(key, item) {
                var $t = $('<li class="context-menu-item"></li>').addClass(item.className || ""), $label = null, $input = null;
                $t.on("click", $.noop);
                if (typeof item === "string") {
                    item = {
                        type: "cm_seperator"
                    };
                }
                item.$node = $t.data({
                    contextMenu: opt,
                    contextMenuRoot: root,
                    contextMenuKey: key
                });
                if (typeof item.accesskey !== "undefined") {
                    var aks = splitAccesskey(item.accesskey);
                    for (var i = 0, ak; ak = aks[i]; i++) {
                        if (!root.accesskeys[ak]) {
                            root.accesskeys[ak] = item;
                            var matched = item.name.match(new RegExp("^(.*?)(" + ak + ")(.*)$", "i"));
                            if (matched) {
                                item._beforeAccesskey = matched[1];
                                item._accesskey = matched[2];
                                item._afterAccesskey = matched[3];
                            }
                            break;
                        }
                    }
                }
                if (item.type && types[item.type]) {
                    types[item.type].call($t, item, opt, root);
                    $.each([ opt, root ], function(i, k) {
                        k.commands[key] = item;
                        if ($.isFunction(item.callback)) {
                            k.callbacks[key] = item.callback;
                        }
                    });
                } else {
                    if (item.type === "cm_seperator") {
                        $t.addClass("context-menu-separator " + root.classNames.notSelectable);
                    } else if (item.type === "html") {
                        $t.addClass("context-menu-html " + root.classNames.notSelectable);
                    } else if (item.type) {
                        $label = $("<label></label>").appendTo($t);
                        createNameNode(item).appendTo($label);
                        $t.addClass("context-menu-input");
                        opt.hasTypes = true;
                        $.each([ opt, root ], function(i, k) {
                            k.commands[key] = item;
                            k.inputs[key] = item;
                        });
                    } else if (item.items) {
                        item.type = "sub";
                    }
                    switch (item.type) {
                      case "seperator":
                        break;

                      case "text":
                        $input = $('<input type="text" value="1" name="" value="">').attr("name", "context-menu-input-" + key).val(item.value || "").appendTo($label);
                        break;

                      case "textarea":
                        $input = $('<textarea name=""></textarea>').attr("name", "context-menu-input-" + key).val(item.value || "").appendTo($label);
                        if (item.height) {
                            $input.height(item.height);
                        }
                        break;

                      case "checkbox":
                        $input = $('<input type="checkbox" value="1" name="" value="">').attr("name", "context-menu-input-" + key).val(item.value || "").prop("checked", !!item.selected).prependTo($label);
                        break;

                      case "radio":
                        $input = $('<input type="radio" value="1" name="" value="">').attr("name", "context-menu-input-" + item.radio).val(item.value || "").prop("checked", !!item.selected).prependTo($label);
                        break;

                      case "select":
                        $input = $('<select name="">').attr("name", "context-menu-input-" + key).appendTo($label);
                        if (item.options) {
                            $.each(item.options, function(value, text) {
                                $("<option></option>").val(value).text(text).appendTo($input);
                            });
                            $input.val(item.selected);
                        }
                        break;

                      case "sub":
                        createNameNode(item).appendTo($t);
                        item.appendTo = item.$node;
                        op.create(item, root);
                        $t.data("contextMenu", item).addClass("context-menu-submenu");
                        item.callback = null;
                        break;

                      case "html":
                        $(item.html).appendTo($t);
                        break;

                      default:
                        $.each([ opt, root ], function(i, k) {
                            k.commands[key] = item;
                            if ($.isFunction(item.callback)) {
                                k.callbacks[key] = item.callback;
                            }
                        });
                        createNameNode(item).appendTo($t);
                        break;
                    }
                    if (item.type && item.type !== "sub" && item.type !== "html" && item.type !== "cm_seperator") {
                        $input.on("focus", handle.focusInput).on("blur", handle.blurInput);
                        if (item.events) {
                            $input.on(item.events, opt);
                        }
                    }
                    if (item.icon) {
                        if ($.isFunction(item.icon)) {
                            item._icon = item.icon.call(this, this, $t, key, item);
                        } else {
                            item._icon = root.classNames.icon + "-" + item.icon;
                        }
                        $t.addClass(item._icon);
                    }
                }
                item.$input = $input;
                item.$label = $label;
                $t.appendTo(opt.$menu);
                if (!opt.hasTypes && $.support.eventSelectstart) {
                    $t.on("selectstart.disableTextSelect", handle.abortevent);
                }
            });
            if (!opt.$node) {
                opt.$menu.css("display", "none").addClass("context-menu-root");
            }
            opt.$menu.appendTo(opt.appendTo || document.body);
        },
        resize: function($menu, nested) {
            $menu.css({
                position: "absolute",
                display: "block"
            });
            $menu.data("width", Math.ceil($menu.width()));
            $menu.css({
                position: "static",
                minWidth: "0px",
                maxWidth: "100000px"
            });
            $menu.find("> li > ul").each(function() {
                op.resize($(this), true);
            });
            if (!nested) {
                $menu.find("ul").addBack().css({
                    position: "",
                    display: "",
                    minWidth: "",
                    maxWidth: ""
                }).width(function() {
                    return $(this).data("width");
                });
            }
        },
        update: function(opt, root) {
            var $trigger = this;
            if (root === undefined) {
                root = opt;
                op.resize(opt.$menu);
            }
            opt.$menu.children().each(function() {
                var $item = $(this), key = $item.data("contextMenuKey"), item = opt.items[key], disabled = $.isFunction(item.disabled) && item.disabled.call($trigger, key, root) || item.disabled === true, visible;
                if ($.isFunction(item.visible)) {
                    visible = item.visible.call($trigger, key, root);
                } else if (typeof item.visible !== "undefined") {
                    visible = item.visible === true;
                } else {
                    visible = true;
                }
                $item[visible ? "show" : "hide"]();
                $item[disabled ? "addClass" : "removeClass"](root.classNames.disabled);
                if ($.isFunction(item.icon)) {
                    $item.removeClass(item._icon);
                    item._icon = item.icon.call(this, $trigger, $item, key, item);
                    $item.addClass(item._icon);
                }
                if (item.type) {
                    $item.find("input, select, textarea").prop("disabled", disabled);
                    switch (item.type) {
                      case "text":
                      case "textarea":
                        item.$input.val(item.value || "");
                        break;

                      case "checkbox":
                      case "radio":
                        item.$input.val(item.value || "").prop("checked", !!item.selected);
                        break;

                      case "select":
                        item.$input.val(item.selected || "");
                        break;
                    }
                }
                if (item.$menu) {
                    op.update.call($trigger, item, root);
                }
            });
        },
        layer: function(opt, zIndex) {
            var $layer = opt.$layer = $('<div id="context-menu-layer" style="position:fixed; z-index:' + zIndex + '; top:0; left:0; opacity: 0; filter: alpha(opacity=0); background-color: #000;"></div>').css({
                height: $win.height(),
                width: $win.width(),
                display: "block"
            }).data("contextMenuRoot", opt).insertBefore(this).on("contextmenu", handle.abortevent).on("mousedown", handle.layerClick);
            if (document.body.style.maxWidth === undefined) {
                $layer.css({
                    position: "absolute",
                    height: $(document).height()
                });
            }
            return $layer;
        }
    };
    function splitAccesskey(val) {
        var t = val.split(/\s+/), keys = [];
        for (var i = 0, k; k = t[i]; i++) {
            k = k.charAt(0).toUpperCase();
            keys.push(k);
        }
        return keys;
    }
    $.fn.contextMenu = function(operation) {
        var $t = this, $o = operation;
        if (this.length > 0) {
            if (operation === undefined) {
                this.first().trigger("contextmenu");
            } else if (operation.x !== undefined && operation.y !== undefined) {
                this.first().trigger($.Event("contextmenu", {
                    pageX: operation.x,
                    pageY: operation.y,
                    mouseButton: operation.button
                }));
            } else if (operation === "hide") {
                var $menu = this.first().data("contextMenu") ? this.first().data("contextMenu").$menu : null;
                $menu && $menu.trigger("contextmenu:hide");
            } else if (operation === "destroy") {
                $.contextMenu("destroy", {
                    context: this
                });
            } else if ($.isPlainObject(operation)) {
                operation.context = this;
                $.contextMenu("create", operation);
            } else if (operation) {
                this.removeClass("context-menu-disabled");
            } else if (!operation) {
                this.addClass("context-menu-disabled");
            }
        } else {
            $.each(menus, function() {
                if (this.selector === $t.selector) {
                    $o.data = this;
                    $.extend($o.data, {
                        trigger: "demand"
                    });
                }
            });
            handle.contextmenu.call($o.target, $o);
        }
        return this;
    };
    $.contextMenu = function(operation, options) {
        if (typeof operation !== "string") {
            options = operation;
            operation = "create";
        }
        if (typeof options === "string") {
            options = {
                selector: options
            };
        } else if (options === undefined) {
            options = {};
        }
        var o = $.extend(true, {}, defaults, options || {});
        var $document = $(document);
        var $context = $document;
        var _hasContext = false;
        if (!o.context || !o.context.length) {
            o.context = document;
        } else {
            $context = $(o.context).first();
            o.context = $context.get(0);
            _hasContext = o.context !== document;
        }
        switch (operation) {
          case "create":
            if (!o.selector) {
                throw new Error("No selector specified");
            }
            if (o.selector.match(/.context-menu-(list|item|input)($|\s)/)) {
                throw new Error('Cannot bind to selector "' + o.selector + '" as it contains a reserved className');
            }
            if (!o.build && (!o.items || $.isEmptyObject(o.items))) {
                throw new Error("No Items specified");
            }
            counter++;
            o.ns = ".contextMenu" + counter;
            if (!_hasContext) {
                namespaces[o.selector] = o.ns;
            }
            menus[o.ns] = o;
            if (!o.trigger) {
                o.trigger = "right";
            }
            if (!initialized) {
                $document.on({
                    "contextmenu:hide.contextMenu": handle.hideMenu,
                    "prevcommand.contextMenu": handle.prevItem,
                    "nextcommand.contextMenu": handle.nextItem,
                    "contextmenu.contextMenu": handle.abortevent,
                    "mouseenter.contextMenu": handle.menuMouseenter,
                    "mouseleave.contextMenu": handle.menuMouseleave
                }, ".context-menu-list").on("mouseup.contextMenu", ".context-menu-input", handle.inputClick).on({
                    "mouseup.contextMenu": handle.itemClick,
                    "contextmenu:focus.contextMenu": handle.focusItem,
                    "contextmenu:blur.contextMenu": handle.blurItem,
                    "contextmenu.contextMenu": handle.abortevent,
                    "mouseenter.contextMenu": handle.itemMouseenter,
                    "mouseleave.contextMenu": handle.itemMouseleave
                }, ".context-menu-item");
                initialized = true;
            }
            $context.on("contextmenu" + o.ns, o.selector, o, handle.contextmenu);
            if (_hasContext) {
                $context.on("remove" + o.ns, function() {
                    $(this).contextMenu("destroy");
                });
            }
            switch (o.trigger) {
              case "hover":
                $context.on("mouseenter" + o.ns, o.selector, o, handle.mouseenter).on("mouseleave" + o.ns, o.selector, o, handle.mouseleave);
                break;

              case "left":
                $context.on("click" + o.ns, o.selector, o, handle.click);
                break;
            }
            if (!o.build) {
                op.create(o);
            }
            break;

          case "destroy":
            var $visibleMenu;
            if (_hasContext) {
                var context = o.context;
                $.each(menus, function(ns, o) {
                    if (o.context !== context) {
                        return true;
                    }
                    $visibleMenu = $(".context-menu-list").filter(":visible");
                    if ($visibleMenu.length && $visibleMenu.data().contextMenuRoot.$trigger.is($(o.context).find(o.selector))) {
                        $visibleMenu.trigger("contextmenu:hide", {
                            force: true
                        });
                    }
                    try {
                        if (menus[o.ns].$menu) {
                            menus[o.ns].$menu.remove();
                        }
                        delete menus[o.ns];
                    } catch (e) {
                        menus[o.ns] = null;
                    }
                    $(o.context).off(o.ns);
                    return true;
                });
            } else if (!o.selector) {
                $document.off(".contextMenu .contextMenuAutoHide");
                $.each(menus, function(ns, o) {
                    $(o.context).off(o.ns);
                });
                namespaces = {};
                menus = {};
                counter = 0;
                initialized = false;
                $("#context-menu-layer, .context-menu-list").remove();
            } else if (namespaces[o.selector]) {
                $visibleMenu = $(".context-menu-list").filter(":visible");
                if ($visibleMenu.length && $visibleMenu.data().contextMenuRoot.$trigger.is(o.selector)) {
                    $visibleMenu.trigger("contextmenu:hide", {
                        force: true
                    });
                }
                try {
                    if (menus[namespaces[o.selector]].$menu) {
                        menus[namespaces[o.selector]].$menu.remove();
                    }
                    delete menus[namespaces[o.selector]];
                } catch (e) {
                    menus[namespaces[o.selector]] = null;
                }
                $document.off(namespaces[o.selector]);
            }
            break;

          case "html5":
            if (!$.support.htmlCommand && !$.support.htmlMenuitem || typeof options === "boolean" && options) {
                $('menu[type="context"]').each(function() {
                    if (this.id) {
                        $.contextMenu({
                            selector: "[contextmenu=" + this.id + "]",
                            items: $.contextMenu.fromMenu(this)
                        });
                    }
                }).css("display", "none");
            }
            break;

          default:
            throw new Error('Unknown operation "' + operation + '"');
        }
        return this;
    };
    $.contextMenu.setInputValues = function(opt, data) {
        if (data === undefined) {
            data = {};
        }
        $.each(opt.inputs, function(key, item) {
            switch (item.type) {
              case "text":
              case "textarea":
                item.value = data[key] || "";
                break;

              case "checkbox":
                item.selected = data[key] ? true : false;
                break;

              case "radio":
                item.selected = (data[item.radio] || "") === item.value;
                break;

              case "select":
                item.selected = data[key] || "";
                break;
            }
        });
    };
    $.contextMenu.getInputValues = function(opt, data) {
        if (data === undefined) {
            data = {};
        }
        $.each(opt.inputs, function(key, item) {
            switch (item.type) {
              case "text":
              case "textarea":
              case "select":
                data[key] = item.$input.val();
                break;

              case "checkbox":
                data[key] = item.$input.prop("checked");
                break;

              case "radio":
                if (item.$input.prop("checked")) {
                    data[item.radio] = item.value;
                }
                break;
            }
        });
        return data;
    };
    function inputLabel(node) {
        return node.id && $('label[for="' + node.id + '"]').val() || node.name;
    }
    function menuChildren(items, $children, counter) {
        if (!counter) {
            counter = 0;
        }
        $children.each(function() {
            var $node = $(this), node = this, nodeName = this.nodeName.toLowerCase(), label, item;
            if (nodeName === "label" && $node.find("input, textarea, select").length) {
                label = $node.text();
                $node = $node.children().first();
                node = $node.get(0);
                nodeName = node.nodeName.toLowerCase();
            }
            switch (nodeName) {
              case "menu":
                item = {
                    name: $node.attr("label"),
                    items: {}
                };
                counter = menuChildren(item.items, $node.children(), counter);
                break;

              case "a":
              case "button":
                item = {
                    name: $node.text(),
                    disabled: !!$node.attr("disabled"),
                    callback: function() {
                        return function() {
                            $node.click();
                        };
                    }()
                };
                break;

              case "menuitem":
              case "command":
                switch ($node.attr("type")) {
                  case undefined:
                  case "command":
                  case "menuitem":
                    item = {
                        name: $node.attr("label"),
                        disabled: !!$node.attr("disabled"),
                        icon: $node.attr("icon"),
                        callback: function() {
                            return function() {
                                $node.click();
                            };
                        }()
                    };
                    break;

                  case "checkbox":
                    item = {
                        type: "checkbox",
                        disabled: !!$node.attr("disabled"),
                        name: $node.attr("label"),
                        selected: !!$node.attr("checked")
                    };
                    break;

                  case "radio":
                    item = {
                        type: "radio",
                        disabled: !!$node.attr("disabled"),
                        name: $node.attr("label"),
                        radio: $node.attr("radiogroup"),
                        value: $node.attr("id"),
                        selected: !!$node.attr("checked")
                    };
                    break;

                  default:
                    item = undefined;
                }
                break;

              case "hr":
                item = "-------";
                break;

              case "input":
                switch ($node.attr("type")) {
                  case "text":
                    item = {
                        type: "text",
                        name: label || inputLabel(node),
                        disabled: !!$node.attr("disabled"),
                        value: $node.val()
                    };
                    break;

                  case "checkbox":
                    item = {
                        type: "checkbox",
                        name: label || inputLabel(node),
                        disabled: !!$node.attr("disabled"),
                        selected: !!$node.attr("checked")
                    };
                    break;

                  case "radio":
                    item = {
                        type: "radio",
                        name: label || inputLabel(node),
                        disabled: !!$node.attr("disabled"),
                        radio: !!$node.attr("name"),
                        value: $node.val(),
                        selected: !!$node.attr("checked")
                    };
                    break;

                  default:
                    item = undefined;
                    break;
                }
                break;

              case "select":
                item = {
                    type: "select",
                    name: label || inputLabel(node),
                    disabled: !!$node.attr("disabled"),
                    selected: $node.val(),
                    options: {}
                };
                $node.children().each(function() {
                    item.options[this.value] = $(this).text();
                });
                break;

              case "textarea":
                item = {
                    type: "textarea",
                    name: label || inputLabel(node),
                    disabled: !!$node.attr("disabled"),
                    value: $node.val()
                };
                break;

              case "label":
                break;

              default:
                item = {
                    type: "html",
                    html: $node.clone(true)
                };
                break;
            }
            if (item) {
                counter++;
                items["key" + counter] = item;
            }
        });
        return counter;
    }
    $.contextMenu.fromMenu = function(element) {
        var $this = $(element), items = {};
        menuChildren(items, $this.children());
        return items;
    };
    $.contextMenu.defaults = defaults;
    $.contextMenu.types = types;
    $.contextMenu.handle = handle;
    $.contextMenu.op = op;
    $.contextMenu.menus = menus;
});

!function() {
    "use strict";
    function t(t) {
        if (t) {
            var e = function() {
                t && t.parentNode && t.parentNode.removeChild(t);
            };
            i(t, "show"), a(t, "hide"), t.addEventListener("transitionend", e), setTimeout(e, u);
        }
    }
    function e(t) {
        var e = t.offsetHeight, n = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height, o = n / 2 - e / 2;
        t.style.top = o + "px";
    }
    function n(t) {
        var e = document.createElement("div");
        return e.innerHTML = t, e.firstChild;
    }
    function o(t, e) {
        var n = "data-" + e, o = document.createElement("div");
        o.appendChild(t);
        var i = o.querySelector("[" + n + "]");
        if (!i) throw new Error('Unable to find: "' + n + '" attribute.');
        return i;
    }
    function i(t, e) {
        var n = t.getAttribute("class"), o = n ? n.split(" ") : [], i = o.indexOf(e);
        i !== -1 && o.splice(i, 1), t.className = o.join(" ");
    }
    function a(t, e) {
        var n = t.getAttribute("class"), o = n ? n.split(" ") : [];
        o.push(e), t.className = o.join(" ");
    }
    function s(t) {
        return JSON.parse(JSON.stringify(t));
    }
    function l() {
        var l = {
            parent: document.body,
            dialogWidth: "400px",
            dialogPersistent: !0,
            dialogContainerClass: "alertify",
            dialogButtons: {
                ok: {
                    label: "Ok",
                    autoClose: !0,
                    template: '<button data-alertify-btn="ok" tabindex="1"></button>'
                },
                cancel: {
                    label: "Cancel",
                    autoClose: !0,
                    template: '<button data-alertify-btn="cancel" tabindex="2"></button>'
                },
                custom: {
                    label: "Custom",
                    autoClose: !1,
                    template: '<button data-alertify-btn tabindex="3"></button>'
                }
            },
            logDelay: 5e3,
            logMaxItems: 2,
            logPosition: {
                v: "bottom",
                h: "left"
            },
            logContainerClass: "alertify-logs",
            logTemplateMethod: null,
            templates: {
                dialogButtonsHolder: "<nav data-alertify-btn-holder></nav>",
                dialogMessage: "<div data-alertify-msg></div>",
                dialogInput: '<input data-alertify-input type="text">',
                logMessage: "<div data-alertify-log-msg></div>"
            }
        }, u = function(e) {
            var i = this;
            this.type = e, this.fixed = !1, this.template = d.logTemplateMethod, this.dom = {}, 
            this.createDomElements = function(t) {
                this.dom.wrapper = n(t), this.dom.message = o(this.dom.wrapper, "alertify-log-msg"), 
                setTimeout(function() {
                    i.dom.wrapper.className += " show";
                }, 10);
            }, this.getDomElements = function() {
                return this.dom;
            }, this.setMessage = function(t) {
                var e = t;
                this.template && (e = this.template(t)), e instanceof HTMLElement ? (this.dom.message.innerHTML = "", 
                this.dom.message.appendChild(e)) : this.dom.message.innerHTML = e;
            }, this.setType = function(t) {
                a(this.dom.message, t);
            }, this.setClickEvent = function(t) {
                this.dom.wrapper.addEventListener("click", function(e) {
                    t(e, i);
                });
            }, this.injectHtml = function() {
                var t = r.elements;
                0 === t.length || "top" === d.logPosition.v ? r.container.appendChild(this.dom.wrapper) : r.container.insertBefore(this.dom.wrapper, t[t.length - 1].dom.wrapper), 
                r.elements.push(this);
            }, this.stick = function(t) {
                this.fixed = t;
            }, this.isFixed = function() {
                return this.fixed;
            }, this.remove = function() {
                t(this.dom.wrapper);
                var e = r.elements.indexOf(this);
                e > -1 && r.elements.splice(e, 1);
            };
        }, d = {
            version: "1.0.11",
            parent: l.parent,
            dialogWidth: l.dialogWidth,
            dialogPersistent: l.dialogPersistent,
            dialogContainerClass: l.dialogContainerClass,
            dialogButtons: s(l.dialogButtons),
            promptValue: "",
            logDelay: l.logDelay,
            logMaxItems: l.logMaxItems,
            logPosition: l.logPosition,
            logContainerClass: l.logContainerClass,
            logTemplateMethod: l.logTemplateMethod,
            templates: s(l.templates),
            build: function(t, e) {
                var i = {};
                if (i.container = document.createElement("div"), i.container.className = this.dialogContainerClass + " hide", 
                i.wrapper = document.createElement("div"), i.wrapper.className = "dialog", i.dialog = document.createElement("div"), 
                i.dialog.style.width = this.dialogWidth, i.content = document.createElement("div"), 
                i.content.className = "content", "dialog" === t.type ? i.content.innerHTML = t.message : (i.messageWrapper = n(this.templates.dialogMessage), 
                i.message = o(i.messageWrapper, "alertify-msg"), i.message.innerHTML = t.message, 
                i.content.appendChild(i.messageWrapper)), i.buttonsWrapper = n(this.templates.dialogButtonsHolder), 
                i.buttonsHolder = o(i.buttonsWrapper, "alertify-btn-holder"), "prompt" === t.type) {
                    var a = n(this.templates.dialogInput);
                    i.input = o(a, "alertify-input"), i.content.appendChild(a);
                }
                i.container.appendChild(i.wrapper), i.wrapper.appendChild(i.dialog), i.dialog.appendChild(i.content), 
                i.dialog.appendChild(i.buttonsWrapper), i.buttonsHolder.innerHTML = "", i.buttons = [];
                for (var s = 0; s < e.length; s++) {
                    var l = o(e[s].element, "alertify-btn");
                    l.innerHTML = e[s].label, i.buttonsHolder.appendChild(e[s].element);
                }
                return i;
            },
            prepareDialogButton: function(t, e) {
                var n = {};
                return !e || "object" != typeof e || e instanceof Array || (n = e), "function" == typeof e && (n.click = e), 
                n.type = t, n;
            },
            createButtonsDefinition: function(t) {
                for (var e = [], o = 0; o < t.buttons.length; o++) {
                    var i = this.buildButtonObject(t.buttons[o]);
                    ("dialog" === t.type || "alert" === t.type && "ok" === i.type || [ "confirm", "prompt" ].indexOf(t.type) !== -1 && [ "ok", "cancel" ].indexOf(i.type) !== -1) && (i.element = n(i.template), 
                    e.push(i));
                }
                return e;
            },
            buildButtonObject: function(t) {
                var e = {}, n = t.type || "custom", o = this.dialogButtons, i = [ "ok", "cancel", "custom" ];
                if ("undefined" != typeof t.type && i.indexOf(t.type) === -1) throw new Error('Wrong button type: "' + t.type + '". Valid values: "' + i.join('", "') + '"');
                return e.type = n, e.label = "undefined" != typeof t.label ? t.label : o[n].label, 
                e.autoClose = "undefined" != typeof t.autoClose ? t.autoClose : o[n].autoClose, 
                e.template = "undefined" != typeof t.template ? t.template : o[n].template, e.click = "undefined" != typeof t.click ? t.click : o[n].click, 
                e;
            },
            close: function(t, e) {
                e = e && !isNaN(+e) ? +e : this.logDelay, e < 0 ? t.remove() : e > 0 && setTimeout(function() {
                    t.remove();
                }, e);
            },
            dialog: function(t, e, n) {
                return this.setup({
                    type: e,
                    message: t,
                    buttons: n
                });
            },
            log: function(t, e, n) {
                for (var o = r.elements, i = [], a = 0, s = o.length; a < s; a++) o[a].isFixed() || i.push(o[a]);
                var l = i.length - this.logMaxItems;
                if (l >= 0) for (var u = 0, d = l + 1; u < d; u++) this.close(i[u], -1);
                this.notify(t, e, n);
            },
            setLogContainerClass: function(t) {
                this.logContainerClass = l.logContainerClass + " " + t;
            },
            setLogPosition: function(t) {
                var e = t.split(" ");
                if ([ "top", "bottom" ].indexOf(e[0]) === -1 || [ "left", "right" ].indexOf(e[1]) === -1) throw new Error('Wrong value for "logPosition" parameter.');
                this.logPosition = {
                    v: e[0],
                    h: e[1]
                };
            },
            setLogFixed: function(t) {
                if ("boolean" != typeof t) throw new Error('Wrong value for "logFixed" parameter. Should be boolean.');
                this.logFixed = t;
            },
            setupLogContainer: function() {
                var e = this.logPosition.v + " " + this.logPosition.h, n = this.logContainerClass + " " + e, o = r.container && r.container.parentNode !== this.parent;
                r.container && !o || (o && t(r.container), r.elements = [], r.container = document.createElement("div"), 
                r.container.className = n, this.parent.appendChild(r.container)), r.container.className !== n && (r.container.className = n);
            },
            notify: function(t, e, n) {
                this.setupLogContainer();
                var o = new u();
                o.createDomElements(this.templates.logMessage), o.setMessage(t), o.setType(e), "function" == typeof n && o.setClickEvent(n), 
                o.injectHtml(), this.close(o, this.logDelay);
            },
            setup: function(n) {
                function o(t) {
                    "function" != typeof t && (t = function() {});
                    for (var e = 0; e < l.length; e++) {
                        var n = l[e], o = function(e) {
                            return function(n) {
                                s = e, e.click && "function" == typeof e.click && e.click(n, u), t({
                                    ui: u,
                                    event: n
                                }), e.autoClose === !0 && u.closeDialog();
                            };
                        }(n);
                        n.element.addEventListener("click", o);
                    }
                    d && d.addEventListener("keyup", function(t) {
                        13 === t.which && a.click();
                    });
                }
                for (var a, s, l = this.createButtonsDefinition(n), r = this.build(n, l), u = {}, d = r.input, c = 0; c < l.length; c++) "ok" === l[c].type && (a = l[c].element);
                d && "string" == typeof this.promptValue && (d.value = this.promptValue), u.dom = r, 
                u.closeDialog = function() {
                    t(r.container);
                }, u.centerDialog = function() {
                    e(r.wrapper);
                }, u.setMessage = function(t) {
                    r.message.innerHTML = t;
                }, u.setContent = function(t) {
                    r.content.innerHTML = t;
                }, u.getInputValue = function() {
                    if (r.input) return r.input.value;
                }, u.getButtonObject = function() {
                    if (s) return {
                        type: s.type,
                        label: s.label,
                        autoClose: s.autoClose,
                        element: s.element
                    };
                };
                var p;
                return "function" == typeof Promise ? p = new Promise(o) : o(), this.dialogPersistent === !1 && r.container.addEventListener("click", function(e) {
                    e.target !== this && e.target !== r.wrapper || t(r.container);
                }), window.onresize = function() {
                    u.centerDialog();
                }, this.parent.appendChild(r.container), setTimeout(function() {
                    i(r.container, "hide"), u.centerDialog(), d && n.type && "prompt" === n.type ? (d.select(), 
                    d.focus()) : a && a.focus();
                }, 100), p;
            },
            setLogDelay: function(t) {
                return t = t || 0, this.logDelay = isNaN(t) ? l.logDelay : parseInt(t, 10), this;
            },
            setLogMaxItems: function(t) {
                this.logMaxItems = parseInt(t || l.logMaxItems);
            },
            setDialogWidth: function(t) {
                "number" == typeof t && (t += "px"), this.dialogWidth = "string" == typeof t ? t : l.dialogWidth;
            },
            setDialogPersistent: function(t) {
                this.dialogPersistent = t;
            },
            setDialogContainerClass: function(t) {
                this.dialogContainerClass = l.dialogContainerClass + " " + t;
            },
            setTheme: function(t) {
                if (t) {
                    if ("string" == typeof t) switch (t.toLowerCase()) {
                      case "bootstrap":
                        this.dialogButtons.ok.template = '<button data-alertify-btn="ok" class="btn btn-primary" tabindex="1"></button>', 
                        this.dialogButtons.cancel.template = '<button data-alertify-btn="cancel" class="btn btn-danger" tabindex="2"></button>', 
                        this.dialogButtons.custom.template = '<button data-alertify-btn="custom" class="btn btn-default" tabindex="3"></button>', 
                        this.templates.dialogInput = "<input data-alertify-input class='form-control' type='text'>";
                        break;

                      case "purecss":
                        this.dialogButtons.ok.template = '<button data-alertify-btn="ok" class="pure-button" tabindex="1"></button>', 
                        this.dialogButtons.cancel.template = '<button data-alertify-btn="cancel" class="pure-button" tabindex="2"></button>', 
                        this.dialogButtons.custom.template = '<button data-alertify-btn="custom" class="pure-button" tabindex="3"></button>';
                        break;

                      case "mdl":
                      case "material-design-light":
                        this.dialogButtons.ok.template = '<button data-alertify-btn="ok" class=" mdl-button mdl-js-button mdl-js-ripple-effect"  tabindex="1"></button>', 
                        this.dialogButtons.cancel.template = '<button data-alertify-btn="cancel" class=" mdl-button mdl-js-button mdl-js-ripple-effect" tabindex="2"></button>', 
                        this.dialogButtons.custom.template = '<button data-alertify-btn="custom" class=" mdl-button mdl-js-button mdl-js-ripple-effect" tabindex="3"></button>', 
                        this.templates.dialogInput = '<div class="mdl-textfield mdl-js-textfield"><input data-alertify-input class="mdl-textfield__input"></div>';
                        break;

                      case "angular-material":
                        this.dialogButtons.ok.template = '<button data-alertify-btn="ok" class="md-primary md-button" tabindex="1"></button>', 
                        this.dialogButtons.cancel.template = '<button data-alertify-btn="cancel" class="md-button" tabindex="2"></button>', 
                        this.dialogButtons.custom.template = '<button data-alertify-btn="custom" class="md-button" tabindex="3"></button>', 
                        this.templates.dialogInput = '<div layout="column"><md-input-container md-no-float><input data-alertify-input type="text"></md-input-container></div>';
                        break;

                      case "default":
                      default:
                        this.dialogButtons = s(l.dialogButtons), this.templates = s(l.templates);
                    }
                    if ("object" == typeof t) {
                        var e = Object.keys(this.templates);
                        for (var n in t) {
                            if (e.indexOf(n) === -1) throw new Error('Wrong template name: "' + n + '". Valid values: "' + e.join('", "') + '"');
                            this.templates[n] = t[n];
                        }
                    }
                }
            },
            reset: function() {
                this.setTheme("default"), this.parent = l.parent, this.dialogWidth = l.dialogWidth, 
                this.dialogPersistent = l.dialogPersistent, this.dialogContainerClass = l.dialogContainerClass, 
                this.promptValue = "", this.logDelay = l.logDelay, this.logMaxItems = l.logMaxItems, 
                this.logPosition = l.logPosition, this.logContainerClass = l.logContainerClass, 
                this.logTemplateMethod = l.logTemplateMethod;
            },
            injectCSS: function() {
                if (!document.querySelector("#alertifyCSS")) {
                    var t = document.getElementsByTagName("head")[0], e = document.createElement("style");
                    e.type = "text/css", e.id = "alertifyCSS", t.insertBefore(e, t.firstChild);
                }
            },
            removeCSS: function() {
                var t = document.querySelector("#alertifyCSS");
                t && t.parentNode && t.parentNode.removeChild(t);
            }
        };
        return d.injectCSS(), {
            _$$alertify: d,
            _$$defaults: l,
            reset: function() {
                return d.reset(), this;
            },
            parent: function(t) {
                d.parent = t;
            },
            theme: function(t) {
                return d.setTheme(t), this;
            },
            dialog: function(t, e) {
                return d.dialog(t, "dialog", e) || this;
            },
            alert: function(t, e) {
                var n = [ d.prepareDialogButton("ok", e) ];
                return d.dialog(t, "alert", n) || this;
            },
            confirm: function(t, e, n) {
                var o = [ d.prepareDialogButton("ok", e), d.prepareDialogButton("cancel", n) ];
                return d.dialog(t, "confirm", o) || this;
            },
            prompt: function(t, e, n, o) {
                var i = [ d.prepareDialogButton("ok", n), d.prepareDialogButton("cancel", o) ];
                return d.promptValue = e || "", d.dialog(t, "prompt", i) || this;
            },
            dialogWidth: function(t) {
                return d.setDialogWidth(t), this;
            },
            dialogPersistent: function(t) {
                return d.setDialogPersistent(t), this;
            },
            dialogContainerClass: function(t) {
                return d.setDialogContainerClass(t || ""), this;
            },
            clearDialogs: function() {
                for (var t; t = d.parent.querySelector(":scope > ." + l.dialogContainerClass); ) d.parent.removeChild(t);
                return this;
            },
            log: function(t, e) {
                return d.log(t, "default", e), this;
            },
            success: function(t, e) {
                return d.log(t, "success", e), this;
            },
            warning: function(t, e) {
                return d.log(t, "warning", e), this;
            },
            error: function(t, e) {
                return d.log(t, "error", e), this;
            },
            logDelay: function(t) {
                return d.setLogDelay(t), this;
            },
            logMaxItems: function(t) {
                return d.setLogMaxItems(t), this;
            },
            logPosition: function(t) {
                return d.setLogPosition(t || ""), this;
            },
            logContainerClass: function(t) {
                return d.setLogContainerClass(t || ""), this;
            },
            logMessageTemplate: function(t) {
                return d.logTemplateMethod = t, this;
            },
            getLogs: function() {
                return r.elements;
            },
            clearLogs: function() {
                return r.container.innerHTML = "", r.elements = [], this;
            },
            version: d.version
        };
    }
    var r = {
        container: null,
        elements: []
    }, u = 500;
    if ("undefined" != typeof module && module && module.exports) {
        module.exports = function() {
            return new l();
        };
        var d = new l();
        for (var c in d) module.exports[c] = d[c];
    } else "function" == typeof define && define.amd ? define(function() {
        return new l();
    }) : window.alertify = new l();
}();

(function(f) {
    if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f();
    } else if (typeof define === "function" && define.amd) {
        define([], f);
    } else {
        var g;
        if (typeof window !== "undefined") {
            g = window;
        } else if (typeof global !== "undefined") {
            g = global;
        } else if (typeof self !== "undefined") {
            g = self;
        } else {
            g = this;
        }
        g.Clipboard = f();
    }
})(function() {
    var define, module, exports;
    return function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof require == "function" && require;
                    if (!u && a) return a(o, !0);
                    if (i) return i(o, !0);
                    var f = new Error("Cannot find module '" + o + "'");
                    throw f.code = "MODULE_NOT_FOUND", f;
                }
                var l = n[o] = {
                    exports: {}
                };
                t[o][0].call(l.exports, function(e) {
                    var n = t[o][1][e];
                    return s(n ? n : e);
                }, l, l.exports, e, t, n, r);
            }
            return n[o].exports;
        }
        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++) s(r[o]);
        return s;
    }({
        1: [ function(require, module, exports) {
            var DOCUMENT_NODE_TYPE = 9;
            if (typeof Element !== "undefined" && !Element.prototype.matches) {
                var proto = Element.prototype;
                proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
            }
            function closest(element, selector) {
                while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
                    if (typeof element.matches === "function" && element.matches(selector)) {
                        return element;
                    }
                    element = element.parentNode;
                }
            }
            module.exports = closest;
        }, {} ],
        2: [ function(require, module, exports) {
            var closest = require("./closest");
            function delegate(element, selector, type, callback, useCapture) {
                var listenerFn = listener.apply(this, arguments);
                element.addEventListener(type, listenerFn, useCapture);
                return {
                    destroy: function() {
                        element.removeEventListener(type, listenerFn, useCapture);
                    }
                };
            }
            function listener(element, selector, type, callback) {
                return function(e) {
                    e.delegateTarget = closest(e.target, selector);
                    if (e.delegateTarget) {
                        callback.call(element, e);
                    }
                };
            }
            module.exports = delegate;
        }, {
            "./closest": 1
        } ],
        3: [ function(require, module, exports) {
            exports.node = function(value) {
                return value !== undefined && value instanceof HTMLElement && value.nodeType === 1;
            };
            exports.nodeList = function(value) {
                var type = Object.prototype.toString.call(value);
                return value !== undefined && (type === "[object NodeList]" || type === "[object HTMLCollection]") && "length" in value && (value.length === 0 || exports.node(value[0]));
            };
            exports.string = function(value) {
                return typeof value === "string" || value instanceof String;
            };
            exports.fn = function(value) {
                var type = Object.prototype.toString.call(value);
                return type === "[object Function]";
            };
        }, {} ],
        4: [ function(require, module, exports) {
            var is = require("./is");
            var delegate = require("delegate");
            function listen(target, type, callback) {
                if (!target && !type && !callback) {
                    throw new Error("Missing required arguments");
                }
                if (!is.string(type)) {
                    throw new TypeError("Second argument must be a String");
                }
                if (!is.fn(callback)) {
                    throw new TypeError("Third argument must be a Function");
                }
                if (is.node(target)) {
                    return listenNode(target, type, callback);
                } else if (is.nodeList(target)) {
                    return listenNodeList(target, type, callback);
                } else if (is.string(target)) {
                    return listenSelector(target, type, callback);
                } else {
                    throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList");
                }
            }
            function listenNode(node, type, callback) {
                node.addEventListener(type, callback);
                return {
                    destroy: function() {
                        node.removeEventListener(type, callback);
                    }
                };
            }
            function listenNodeList(nodeList, type, callback) {
                Array.prototype.forEach.call(nodeList, function(node) {
                    node.addEventListener(type, callback);
                });
                return {
                    destroy: function() {
                        Array.prototype.forEach.call(nodeList, function(node) {
                            node.removeEventListener(type, callback);
                        });
                    }
                };
            }
            function listenSelector(selector, type, callback) {
                return delegate(document.body, selector, type, callback);
            }
            module.exports = listen;
        }, {
            "./is": 3,
            delegate: 2
        } ],
        5: [ function(require, module, exports) {
            function select(element) {
                var selectedText;
                if (element.nodeName === "SELECT") {
                    element.focus();
                    selectedText = element.value;
                } else if (element.nodeName === "INPUT" || element.nodeName === "TEXTAREA") {
                    var isReadOnly = element.hasAttribute("readonly");
                    if (!isReadOnly) {
                        element.setAttribute("readonly", "");
                    }
                    element.select();
                    element.setSelectionRange(0, element.value.length);
                    if (!isReadOnly) {
                        element.removeAttribute("readonly");
                    }
                    selectedText = element.value;
                } else {
                    if (element.hasAttribute("contenteditable")) {
                        element.focus();
                    }
                    var selection = window.getSelection();
                    var range = document.createRange();
                    range.selectNodeContents(element);
                    selection.removeAllRanges();
                    selection.addRange(range);
                    selectedText = selection.toString();
                }
                return selectedText;
            }
            module.exports = select;
        }, {} ],
        6: [ function(require, module, exports) {
            function E() {}
            E.prototype = {
                on: function(name, callback, ctx) {
                    var e = this.e || (this.e = {});
                    (e[name] || (e[name] = [])).push({
                        fn: callback,
                        ctx: ctx
                    });
                    return this;
                },
                once: function(name, callback, ctx) {
                    var self = this;
                    function listener() {
                        self.off(name, listener);
                        callback.apply(ctx, arguments);
                    }
                    listener._ = callback;
                    return this.on(name, listener, ctx);
                },
                emit: function(name) {
                    var data = [].slice.call(arguments, 1);
                    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
                    var i = 0;
                    var len = evtArr.length;
                    for (i; i < len; i++) {
                        evtArr[i].fn.apply(evtArr[i].ctx, data);
                    }
                    return this;
                },
                off: function(name, callback) {
                    var e = this.e || (this.e = {});
                    var evts = e[name];
                    var liveEvents = [];
                    if (evts && callback) {
                        for (var i = 0, len = evts.length; i < len; i++) {
                            if (evts[i].fn !== callback && evts[i].fn._ !== callback) liveEvents.push(evts[i]);
                        }
                    }
                    liveEvents.length ? e[name] = liveEvents : delete e[name];
                    return this;
                }
            };
            module.exports = E;
        }, {} ],
        7: [ function(require, module, exports) {
            (function(global, factory) {
                if (typeof define === "function" && define.amd) {
                    define([ "module", "select" ], factory);
                } else if (typeof exports !== "undefined") {
                    factory(module, require("select"));
                } else {
                    var mod = {
                        exports: {}
                    };
                    factory(mod, global.select);
                    global.clipboardAction = mod.exports;
                }
            })(this, function(module, _select) {
                "use strict";
                var _select2 = _interopRequireDefault(_select);
                function _interopRequireDefault(obj) {
                    return obj && obj.__esModule ? obj : {
                        "default": obj
                    };
                }
                var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
                    return typeof obj;
                } : function(obj) {
                    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                var _createClass = function() {
                    function defineProperties(target, props) {
                        for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable = descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ("value" in descriptor) descriptor.writable = true;
                            Object.defineProperty(target, descriptor.key, descriptor);
                        }
                    }
                    return function(Constructor, protoProps, staticProps) {
                        if (protoProps) defineProperties(Constructor.prototype, protoProps);
                        if (staticProps) defineProperties(Constructor, staticProps);
                        return Constructor;
                    };
                }();
                var ClipboardAction = function() {
                    function ClipboardAction(options) {
                        _classCallCheck(this, ClipboardAction);
                        this.resolveOptions(options);
                        this.initSelection();
                    }
                    _createClass(ClipboardAction, [ {
                        key: "resolveOptions",
                        value: function resolveOptions() {
                            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                            this.action = options.action;
                            this.container = options.container;
                            this.emitter = options.emitter;
                            this.target = options.target;
                            this.text = options.text;
                            this.trigger = options.trigger;
                            this.selectedText = "";
                        }
                    }, {
                        key: "initSelection",
                        value: function initSelection() {
                            if (this.text) {
                                this.selectFake();
                            } else if (this.target) {
                                this.selectTarget();
                            }
                        }
                    }, {
                        key: "selectFake",
                        value: function selectFake() {
                            var _this = this;
                            var isRTL = document.documentElement.getAttribute("dir") == "rtl";
                            this.removeFake();
                            this.fakeHandlerCallback = function() {
                                return _this.removeFake();
                            };
                            this.fakeHandler = this.container.addEventListener("click", this.fakeHandlerCallback) || true;
                            this.fakeElem = document.createElement("textarea");
                            this.fakeElem.style.fontSize = "12pt";
                            this.fakeElem.style.border = "0";
                            this.fakeElem.style.padding = "0";
                            this.fakeElem.style.margin = "0";
                            this.fakeElem.style.position = "absolute";
                            this.fakeElem.style[isRTL ? "right" : "left"] = "-9999px";
                            var yPosition = window.pageYOffset || document.documentElement.scrollTop;
                            this.fakeElem.style.top = yPosition + "px";
                            this.fakeElem.setAttribute("readonly", "");
                            this.fakeElem.value = this.text;
                            this.container.appendChild(this.fakeElem);
                            this.selectedText = (0, _select2.default)(this.fakeElem);
                            this.copyText();
                        }
                    }, {
                        key: "removeFake",
                        value: function removeFake() {
                            if (this.fakeHandler) {
                                this.container.removeEventListener("click", this.fakeHandlerCallback);
                                this.fakeHandler = null;
                                this.fakeHandlerCallback = null;
                            }
                            if (this.fakeElem) {
                                this.container.removeChild(this.fakeElem);
                                this.fakeElem = null;
                            }
                        }
                    }, {
                        key: "selectTarget",
                        value: function selectTarget() {
                            this.selectedText = (0, _select2.default)(this.target);
                            this.copyText();
                        }
                    }, {
                        key: "copyText",
                        value: function copyText() {
                            var succeeded = void 0;
                            try {
                                succeeded = document.execCommand(this.action);
                            } catch (err) {
                                succeeded = false;
                            }
                            this.handleResult(succeeded);
                        }
                    }, {
                        key: "handleResult",
                        value: function handleResult(succeeded) {
                            this.emitter.emit(succeeded ? "success" : "error", {
                                action: this.action,
                                text: this.selectedText,
                                trigger: this.trigger,
                                clearSelection: this.clearSelection.bind(this)
                            });
                        }
                    }, {
                        key: "clearSelection",
                        value: function clearSelection() {
                            if (this.trigger) {
                                this.trigger.focus();
                            }
                            window.getSelection().removeAllRanges();
                        }
                    }, {
                        key: "destroy",
                        value: function destroy() {
                            this.removeFake();
                        }
                    }, {
                        key: "action",
                        set: function set() {
                            var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "copy";
                            this._action = action;
                            if (this._action !== "copy" && this._action !== "cut") {
                                throw new Error('Invalid "action" value, use either "copy" or "cut"');
                            }
                        },
                        get: function get() {
                            return this._action;
                        }
                    }, {
                        key: "target",
                        set: function set(target) {
                            if (target !== undefined) {
                                if (target && (typeof target === "undefined" ? "undefined" : _typeof(target)) === "object" && target.nodeType === 1) {
                                    if (this.action === "copy" && target.hasAttribute("disabled")) {
                                        throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
                                    }
                                    if (this.action === "cut" && (target.hasAttribute("readonly") || target.hasAttribute("disabled"))) {
                                        throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes');
                                    }
                                    this._target = target;
                                } else {
                                    throw new Error('Invalid "target" value, use a valid Element');
                                }
                            }
                        },
                        get: function get() {
                            return this._target;
                        }
                    } ]);
                    return ClipboardAction;
                }();
                module.exports = ClipboardAction;
            });
        }, {
            select: 5
        } ],
        8: [ function(require, module, exports) {
            (function(global, factory) {
                if (typeof define === "function" && define.amd) {
                    define([ "module", "./clipboard-action", "tiny-emitter", "good-listener" ], factory);
                } else if (typeof exports !== "undefined") {
                    factory(module, require("./clipboard-action"), require("tiny-emitter"), require("good-listener"));
                } else {
                    var mod = {
                        exports: {}
                    };
                    factory(mod, global.clipboardAction, global.tinyEmitter, global.goodListener);
                    global.clipboard = mod.exports;
                }
            })(this, function(module, _clipboardAction, _tinyEmitter, _goodListener) {
                "use strict";
                var _clipboardAction2 = _interopRequireDefault(_clipboardAction);
                var _tinyEmitter2 = _interopRequireDefault(_tinyEmitter);
                var _goodListener2 = _interopRequireDefault(_goodListener);
                function _interopRequireDefault(obj) {
                    return obj && obj.__esModule ? obj : {
                        "default": obj
                    };
                }
                var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
                    return typeof obj;
                } : function(obj) {
                    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                var _createClass = function() {
                    function defineProperties(target, props) {
                        for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable = descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ("value" in descriptor) descriptor.writable = true;
                            Object.defineProperty(target, descriptor.key, descriptor);
                        }
                    }
                    return function(Constructor, protoProps, staticProps) {
                        if (protoProps) defineProperties(Constructor.prototype, protoProps);
                        if (staticProps) defineProperties(Constructor, staticProps);
                        return Constructor;
                    };
                }();
                function _possibleConstructorReturn(self, call) {
                    if (!self) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return call && (typeof call === "object" || typeof call === "function") ? call : self;
                }
                function _inherits(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            enumerable: false,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                var Clipboard = function(_Emitter) {
                    _inherits(Clipboard, _Emitter);
                    function Clipboard(trigger, options) {
                        _classCallCheck(this, Clipboard);
                        var _this = _possibleConstructorReturn(this, (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this));
                        _this.resolveOptions(options);
                        _this.listenClick(trigger);
                        return _this;
                    }
                    _createClass(Clipboard, [ {
                        key: "resolveOptions",
                        value: function resolveOptions() {
                            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                            this.action = typeof options.action === "function" ? options.action : this.defaultAction;
                            this.target = typeof options.target === "function" ? options.target : this.defaultTarget;
                            this.text = typeof options.text === "function" ? options.text : this.defaultText;
                            this.container = _typeof(options.container) === "object" ? options.container : document.body;
                        }
                    }, {
                        key: "listenClick",
                        value: function listenClick(trigger) {
                            var _this2 = this;
                            this.listener = (0, _goodListener2.default)(trigger, "click", function(e) {
                                return _this2.onClick(e);
                            });
                        }
                    }, {
                        key: "onClick",
                        value: function onClick(e) {
                            var trigger = e.delegateTarget || e.currentTarget;
                            if (this.clipboardAction) {
                                this.clipboardAction = null;
                            }
                            this.clipboardAction = new _clipboardAction2.default({
                                action: this.action(trigger),
                                target: this.target(trigger),
                                text: this.text(trigger),
                                container: this.container,
                                trigger: trigger,
                                emitter: this
                            });
                        }
                    }, {
                        key: "defaultAction",
                        value: function defaultAction(trigger) {
                            return getAttributeValue("action", trigger);
                        }
                    }, {
                        key: "defaultTarget",
                        value: function defaultTarget(trigger) {
                            var selector = getAttributeValue("target", trigger);
                            if (selector) {
                                return document.querySelector(selector);
                            }
                        }
                    }, {
                        key: "defaultText",
                        value: function defaultText(trigger) {
                            return getAttributeValue("text", trigger);
                        }
                    }, {
                        key: "destroy",
                        value: function destroy() {
                            this.listener.destroy();
                            if (this.clipboardAction) {
                                this.clipboardAction.destroy();
                                this.clipboardAction = null;
                            }
                        }
                    } ], [ {
                        key: "isSupported",
                        value: function isSupported() {
                            var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [ "copy", "cut" ];
                            var actions = typeof action === "string" ? [ action ] : action;
                            var support = !!document.queryCommandSupported;
                            actions.forEach(function(action) {
                                support = support && !!document.queryCommandSupported(action);
                            });
                            return support;
                        }
                    } ]);
                    return Clipboard;
                }(_tinyEmitter2.default);
                function getAttributeValue(suffix, element) {
                    var attribute = "data-clipboard-" + suffix;
                    if (!element.hasAttribute(attribute)) {
                        return;
                    }
                    return element.getAttribute(attribute);
                }
                module.exports = Clipboard;
            });
        }, {
            "./clipboard-action": 7,
            "good-listener": 4,
            "tiny-emitter": 6
        } ]
    }, {}, [ 8 ])(8);
});

(function($, window) {
    var htmlSpecialCharsRegEx = /[<>&\r\n"']/gm;
    var htmlSpecialCharsPlaceHolders = {
        "<": "lt;",
        ">": "gt;",
        "&": "amp;",
        "\r": "#13;",
        "\n": "#10;",
        '"': "quot;",
        "'": "#39;"
    };
    $.extend({
        fileDownload: function(fileUrl, options) {
            var settings = $.extend({
                preparingMessageHtml: null,
                failMessageHtml: null,
                androidPostUnsupportedMessageHtml: "Unfortunately your Android browser doesn't support this type of file download. Please try again with a different browser.",
                dialogOptions: {
                    modal: true
                },
                prepareCallback: function(url) {},
                successCallback: function(url) {},
                abortCallback: function(url) {},
                failCallback: function(responseHtml, url, error) {},
                httpMethod: "GET",
                data: null,
                checkInterval: 100,
                cookieName: "fileDownload",
                cookieValue: "true",
                cookiePath: "/",
                cookieDomain: null,
                popupWindowTitle: "Initiating file download...",
                encodeHTMLEntities: true
            }, options);
            var deferred = new $.Deferred();
            var userAgent = (navigator.userAgent || navigator.vendor || window.opera).toLowerCase();
            var isIos;
            var isAndroid;
            var isOtherMobileBrowser;
            if (/ip(ad|hone|od)/.test(userAgent)) {
                isIos = true;
            } else if (userAgent.indexOf("android") !== -1) {
                isAndroid = true;
            } else {
                isOtherMobileBrowser = /avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|playbook|silk|iemobile|iris|kindle|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(userAgent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|e\-|e\/|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(di|rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|xda(\-|2|g)|yas\-|your|zeto|zte\-/i.test(userAgent.substr(0, 4));
            }
            var httpMethodUpper = settings.httpMethod.toUpperCase();
            if (isAndroid && httpMethodUpper !== "GET" && settings.androidPostUnsupportedMessageHtml) {
                if ($().dialog) {
                    $("<div>").html(settings.androidPostUnsupportedMessageHtml).dialog(settings.dialogOptions);
                } else {
                    alert(settings.androidPostUnsupportedMessageHtml);
                }
                return deferred.reject();
            }
            var $preparingDialog = null;
            var internalCallbacks = {
                onPrepare: function(url) {
                    if (settings.preparingMessageHtml) {
                        $preparingDialog = $("<div>").html(settings.preparingMessageHtml).dialog(settings.dialogOptions);
                    } else if (settings.prepareCallback) {
                        settings.prepareCallback(url);
                    }
                },
                onSuccess: function(url) {
                    if ($preparingDialog) {
                        $preparingDialog.dialog("close");
                    }
                    settings.successCallback(url);
                    deferred.resolve(url);
                },
                onAbort: function(url) {
                    if ($preparingDialog) {
                        $preparingDialog.dialog("close");
                    }
                    settings.abortCallback(url);
                    deferred.reject(url);
                },
                onFail: function(responseHtml, url, error) {
                    if ($preparingDialog) {
                        $preparingDialog.dialog("close");
                    }
                    if (settings.failMessageHtml) {
                        $("<div>").html(settings.failMessageHtml).dialog(settings.dialogOptions);
                    }
                    settings.failCallback(responseHtml, url, error);
                    deferred.reject(responseHtml, url);
                }
            };
            internalCallbacks.onPrepare(fileUrl);
            if (settings.data !== null && typeof settings.data !== "string") {
                settings.data = $.param(settings.data);
            }
            var $iframe, downloadWindow, formDoc, $form;
            if (httpMethodUpper === "GET") {
                if (settings.data !== null) {
                    var qsStart = fileUrl.indexOf("?");
                    if (qsStart !== -1) {
                        if (fileUrl.substring(fileUrl.length - 1) !== "&") {
                            fileUrl = fileUrl + "&";
                        }
                    } else {
                        fileUrl = fileUrl + "?";
                    }
                    fileUrl = fileUrl + settings.data;
                }
                if (isIos || isAndroid) {
                    downloadWindow = window.open(fileUrl);
                    downloadWindow.document.title = settings.popupWindowTitle;
                    window.focus();
                } else if (isOtherMobileBrowser) {
                    window.location(fileUrl);
                } else {
                    $iframe = $("<iframe>").hide().prop("src", fileUrl).appendTo("body");
                }
            } else {
                var formInnerHtml = "";
                if (settings.data !== null) {
                    $.each(settings.data.replace(/\+/g, " ").split("&"), function() {
                        var kvp = this.split("=");
                        var k = kvp[0];
                        kvp.shift();
                        var v = kvp.join("=");
                        kvp = [ k, v ];
                        var key = settings.encodeHTMLEntities ? htmlSpecialCharsEntityEncode(decodeURIComponent(kvp[0])) : decodeURIComponent(kvp[0]);
                        if (key) {
                            var value = settings.encodeHTMLEntities ? htmlSpecialCharsEntityEncode(decodeURIComponent(kvp[1])) : decodeURIComponent(kvp[1]);
                            formInnerHtml += '<input type="hidden" name="' + key + '" value="' + value + '" />';
                        }
                    });
                }
                if (isOtherMobileBrowser) {
                    $form = $("<form>").appendTo("body");
                    $form.hide().prop("method", settings.httpMethod).prop("action", fileUrl).html(formInnerHtml);
                } else {
                    if (isIos) {
                        downloadWindow = window.open("about:blank");
                        downloadWindow.document.title = settings.popupWindowTitle;
                        formDoc = downloadWindow.document;
                        window.focus();
                    } else {
                        $iframe = $("<iframe style='display: none' src='about:blank'></iframe>").appendTo("body");
                        formDoc = getiframeDocument($iframe);
                    }
                    formDoc.write("<html><head></head><body><form method='" + settings.httpMethod + "' action='" + fileUrl + "'>" + formInnerHtml + "</form>" + settings.popupWindowTitle + "</body></html>");
                    $form = $(formDoc).find("form");
                }
                $form.submit();
            }
            setTimeout(checkFileDownloadComplete, settings.checkInterval);
            function checkFileDownloadComplete() {
                var cookieValue = settings.cookieValue;
                if (typeof cookieValue == "string") {
                    cookieValue = cookieValue.toLowerCase();
                }
                var lowerCaseCookie = settings.cookieName.toLowerCase() + "=" + cookieValue;
                if (document.cookie.toLowerCase().indexOf(lowerCaseCookie) > -1) {
                    internalCallbacks.onSuccess(fileUrl);
                    var cookieData = settings.cookieName + "=; path=" + settings.cookiePath + "; expires=" + new Date(0).toUTCString() + ";";
                    if (settings.cookieDomain) cookieData += " domain=" + settings.cookieDomain + ";";
                    document.cookie = cookieData;
                    cleanUp(false);
                    return;
                }
                if (downloadWindow || $iframe) {
                    try {
                        var formDoc = downloadWindow ? downloadWindow.document : getiframeDocument($iframe);
                        if (formDoc && formDoc.body !== null && formDoc.body.innerHTML.length) {
                            var isFailure = true;
                            if ($form && $form.length) {
                                var $contents = $(formDoc.body).contents().first();
                                try {
                                    if ($contents.length && $contents[0] === $form[0]) {
                                        isFailure = false;
                                    }
                                } catch (e) {
                                    if (e && e.number == -2146828218) {
                                        isFailure = true;
                                    } else {
                                        throw e;
                                    }
                                }
                            }
                            if (isFailure) {
                                setTimeout(function() {
                                    internalCallbacks.onFail(formDoc.body.innerHTML, fileUrl);
                                    cleanUp(true);
                                }, 100);
                                return;
                            }
                        }
                    } catch (err) {
                        internalCallbacks.onFail("", fileUrl, err);
                        cleanUp(true);
                        return;
                    }
                }
                setTimeout(checkFileDownloadComplete, settings.checkInterval);
            }
            function getiframeDocument($iframe) {
                var iframeDoc = $iframe[0].contentWindow || $iframe[0].contentDocument;
                if (iframeDoc.document) {
                    iframeDoc = iframeDoc.document;
                }
                return iframeDoc;
            }
            function cleanUp(isFailure) {
                setTimeout(function() {
                    if (downloadWindow) {
                        if (isAndroid) {
                            downloadWindow.close();
                        }
                        if (isIos) {
                            if (downloadWindow.focus) {
                                downloadWindow.focus();
                                if (isFailure) {
                                    downloadWindow.close();
                                }
                            }
                        }
                    }
                }, 0);
            }
            function htmlSpecialCharsEntityEncode(str) {
                return str.replace(htmlSpecialCharsRegEx, function(match) {
                    return "&" + htmlSpecialCharsPlaceHolders[match];
                });
            }
            var promise = deferred.promise();
            promise.abort = function() {
                cleanUp();
                $iframe.attr("src", "").html("");
                internalCallbacks.onAbort(fileUrl);
            };
            return promise;
        }
    });
})(jQuery, this || window);

(function($) {
    "use strict";
    var tmpl = function(str, data) {
        var f = !/[^\w\-\.:]/.test(str) ? tmpl.cache[str] = tmpl.cache[str] || tmpl(tmpl.load(str)) : new Function(tmpl.arg + ",tmpl", "var _e=tmpl.encode" + tmpl.helper + ",_s='" + str.replace(tmpl.regexp, tmpl.func) + "';return _s;");
        return data ? f(data, tmpl) : function(data) {
            return f(data, tmpl);
        };
    };
    tmpl.cache = {};
    tmpl.load = function(id) {
        return document.getElementById(id).innerHTML;
    };
    tmpl.regexp = /([\s'\\])(?!(?:[^{]|\{(?!%))*%\})|(?:\{%(=|#)([\s\S]+?)%\})|(\{%)|(%\})/g;
    tmpl.func = function(s, p1, p2, p3, p4, p5) {
        if (p1) {
            return {
                "\n": "\\n",
                "\r": "\\r",
                "\t": "\\t",
                " ": " "
            }[p1] || "\\" + p1;
        }
        if (p2) {
            if (p2 === "=") {
                return "'+_e(" + p3 + ")+'";
            }
            return "'+(" + p3 + "==null?'':" + p3 + ")+'";
        }
        if (p4) {
            return "';";
        }
        if (p5) {
            return "_s+='";
        }
    };
    tmpl.encReg = /[<>&"'\x00]/g;
    tmpl.encMap = {
        "<": "&lt;",
        ">": "&gt;",
        "&": "&amp;",
        '"': "&quot;",
        "'": "&#39;"
    };
    tmpl.encode = function(s) {
        return (s == null ? "" : "" + s).replace(tmpl.encReg, function(c) {
            return tmpl.encMap[c] || "";
        });
    };
    tmpl.arg = "o";
    tmpl.helper = ",print=function(s,e){_s+=e?(s==null?'':s):_e(s);}" + ",include=function(s,d){_s+=tmpl(s,d);}";
    if (typeof define === "function" && define.amd) {
        define(function() {
            return tmpl;
        });
    } else if (typeof module === "object" && module.exports) {
        module.exports = tmpl;
    } else {
        $.tmpl = tmpl;
    }
})(this);

(function(root, factory) {
    if (typeof define === "function" && define.amd) {
        define([], function() {
            return root.toast = factory();
        });
    } else if (typeof exports === "object") {
        module.exports = factory();
    } else {
        root.toast = factory();
    }
})(this, function() {
    var handled_resources = {};
    function Toast() {
        var head = document.getElementsByTagName("head")[0], loadResources = function(resources) {
            if (!head) {
                setTimeout(function() {
                    loadResources(resources);
                }, 50);
            } else if (resources.length) {
                var i = -1, resource, callback;
                while (resource = resources[++i]) {
                    if (typeof resource == "string") {
                        loadResource(resource);
                    } else if (typeof resource == "function") {
                        callback = resource;
                        break;
                    }
                }
                watchResources(callback, Array.prototype.slice.call(resources, i + 1));
            }
        }, loadResource = function(resource) {
            var implicit_type = /\.(\w+)$/.exec(resource), explicit_type = /^\[(\w+)\](.+)/.exec(resource), type, node;
            if (explicit_type !== null) {
                type = explicit_type[1];
                resource = explicit_type[2];
            } else if (implicit_type !== null) {
                type = implicit_type[1];
            } else {
                return;
            }
            if (resource in handled_resources) {
                return;
            }
            handled_resources[resource] = false;
            switch (type) {
              case "js":
                node = document.createElement("script");
                node.src = resource;
                node.async = false;
                head.appendChild(node);
                var version = navigator.appVersion.match(/MSIE (\d)/);
                if (version !== null && parseInt(version[1], 10) < 9) {
                    node.onreadystatechange = function() {
                        if (/ded|co/.test(this.readyState)) {
                            handled_resources[resource] = true;
                            node.onreadystatechange = null;
                        }
                    };
                } else {
                    node.onload = function() {
                        handled_resources[resource] = true;
                        node.onload = null;
                    };
                }
                break;

              case "css":
                node = document.createElement("link");
                node.rel = "styleSheet";
                node.href = resource;
                head.appendChild(node);
                watchStylesheet(node, resource);
                break;

              default:
                delete handled_resources[resource];
                return;
            }
        }, watchResources = function(callback, resourcesToLoad) {
            for (var resource in handled_resources) {
                if (!handled_resources[resource]) {
                    setTimeout(function() {
                        watchResources(callback, resourcesToLoad);
                    }, 50);
                    return;
                }
            }
            if (typeof callback == "function") {
                callback();
            }
            loadResources(resourcesToLoad);
        }, watchStylesheet = function(node, resource) {
            if (node.sheet || node.styleSheet) {
                handled_resources[resource] = true;
            } else {
                setTimeout(function() {
                    watchStylesheet(node, resource);
                }, 50);
            }
        };
        loadResources(arguments);
    }
    return Toast;
});

(function(root, factory) {
    if (typeof define === "function" && define.amd) {
        define(factory);
    } else if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = factory();
    } else {
        root.Cldr = factory();
    }
})(this, function() {
    var arrayIsArray = Array.isArray || function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
    };
    var pathNormalize = function(path, attributes) {
        if (arrayIsArray(path)) {
            path = path.join("/");
        }
        if (typeof path !== "string") {
            throw new Error('invalid path "' + path + '"');
        }
        path = path.replace(/^\//, "").replace(/^cldr\//, "");
        path = path.replace(/{[a-zA-Z]+}/g, function(name) {
            name = name.replace(/^{([^}]*)}$/, "$1");
            return attributes[name];
        });
        return path.split("/");
    };
    var arraySome = function(array, callback) {
        var i, length;
        if (array.some) {
            return array.some(callback);
        }
        for (i = 0, length = array.length; i < length; i++) {
            if (callback(array[i], i, array)) {
                return true;
            }
        }
        return false;
    };
    var coreLikelySubtags = function(Cldr, cldr, subtags, options) {
        var match, matchFound, language = subtags[0], script = subtags[1], sep = Cldr.localeSep, territory = subtags[2], variants = subtags.slice(3, 4);
        options = options || {};
        if (language !== "und" && script !== "Zzzz" && territory !== "ZZ") {
            return [ language, script, territory ].concat(variants);
        }
        if (typeof cldr.get("supplemental/likelySubtags") === "undefined") {
            return;
        }
        matchFound = arraySome([ [ language, script, territory ], [ language, territory ], [ language, script ], [ language ], [ "und", script ] ], function(test) {
            return match = !/\b(Zzzz|ZZ)\b/.test(test.join(sep)) && cldr.get([ "supplemental/likelySubtags", test.join(sep) ]);
        });
        if (matchFound) {
            match = match.split(sep);
            return [ language !== "und" ? language : match[0], script !== "Zzzz" ? script : match[1], territory !== "ZZ" ? territory : match[2] ].concat(variants);
        } else if (options.force) {
            return cldr.get("supplemental/likelySubtags/und").split(sep);
        } else {
            return;
        }
    };
    var coreRemoveLikelySubtags = function(Cldr, cldr, maxLanguageId) {
        var match, matchFound, language = maxLanguageId[0], script = maxLanguageId[1], territory = maxLanguageId[2], variants = maxLanguageId[3];
        matchFound = arraySome([ [ [ language, "Zzzz", "ZZ" ], [ language ] ], [ [ language, "Zzzz", territory ], [ language, territory ] ], [ [ language, script, "ZZ" ], [ language, script ] ] ], function(test) {
            var result = coreLikelySubtags(Cldr, cldr, test[0]);
            match = test[1];
            return result && result[0] === maxLanguageId[0] && result[1] === maxLanguageId[1] && result[2] === maxLanguageId[2];
        });
        if (matchFound) {
            if (variants) {
                match.push(variants);
            }
            return match;
        }
        return maxLanguageId;
    };
    var coreSubtags = function(locale) {
        var aux, unicodeLanguageId, subtags = [];
        locale = locale.replace(/_/, "-");
        aux = locale.split("-u-");
        if (aux[1]) {
            aux[1] = aux[1].split("-t-");
            locale = aux[0] + (aux[1][1] ? "-t-" + aux[1][1] : "");
            subtags[4] = aux[1][0];
        }
        unicodeLanguageId = locale.split("-t-")[0];
        aux = unicodeLanguageId.match(/^(([a-z]{2,3})(-([A-Z][a-z]{3}))?(-([A-Z]{2}|[0-9]{3}))?)((-([a-zA-Z0-9]{5,8}|[0-9][a-zA-Z0-9]{3}))*)$|^(root)$/);
        if (aux === null) {
            return [ "und", "Zzzz", "ZZ" ];
        }
        subtags[0] = aux[10] || aux[2] || "und";
        subtags[1] = aux[4] || "Zzzz";
        subtags[2] = aux[6] || "ZZ";
        if (aux[7] && aux[7].length) {
            subtags[3] = aux[7].slice(1);
        }
        return subtags;
    };
    var arrayForEach = function(array, callback) {
        var i, length;
        if (array.forEach) {
            return array.forEach(callback);
        }
        for (i = 0, length = array.length; i < length; i++) {
            callback(array[i], i, array);
        }
    };
    var bundleLookup = function(Cldr, cldr, minLanguageId) {
        var availableBundleMap = Cldr._availableBundleMap, availableBundleMapQueue = Cldr._availableBundleMapQueue;
        if (availableBundleMapQueue.length) {
            arrayForEach(availableBundleMapQueue, function(bundle) {
                var existing, maxBundle, minBundle, subtags;
                subtags = coreSubtags(bundle);
                maxBundle = coreLikelySubtags(Cldr, cldr, subtags);
                minBundle = coreRemoveLikelySubtags(Cldr, cldr, maxBundle);
                minBundle = minBundle.join(Cldr.localeSep);
                existing = availableBundleMapQueue[minBundle];
                if (existing && existing.length < bundle.length) {
                    return;
                }
                availableBundleMap[minBundle] = bundle;
            });
            Cldr._availableBundleMapQueue = [];
        }
        return availableBundleMap[minLanguageId] || null;
    };
    var objectKeys = function(object) {
        var i, result = [];
        if (Object.keys) {
            return Object.keys(object);
        }
        for (i in object) {
            result.push(i);
        }
        return result;
    };
    var createError = function(code, attributes) {
        var error, message;
        message = code + (attributes && JSON ? ": " + JSON.stringify(attributes) : "");
        error = new Error(message);
        error.code = code;
        arrayForEach(objectKeys(attributes), function(attribute) {
            error[attribute] = attributes[attribute];
        });
        return error;
    };
    var validate = function(code, check, attributes) {
        if (!check) {
            throw createError(code, attributes);
        }
    };
    var validatePresence = function(value, name) {
        validate("E_MISSING_PARAMETER", typeof value !== "undefined", {
            name: name
        });
    };
    var validateType = function(value, name, check, expected) {
        validate("E_INVALID_PAR_TYPE", check, {
            expected: expected,
            name: name,
            value: value
        });
    };
    var validateTypePath = function(value, name) {
        validateType(value, name, typeof value === "string" || arrayIsArray(value), "String or Array");
    };
    var isPlainObject = function(obj) {
        return obj !== null && "" + obj === "[object Object]";
    };
    var validateTypePlainObject = function(value, name) {
        validateType(value, name, typeof value === "undefined" || isPlainObject(value), "Plain Object");
    };
    var validateTypeString = function(value, name) {
        validateType(value, name, typeof value === "string", "a string");
    };
    var resourceGet = function(data, path) {
        var i, node = data, length = path.length;
        for (i = 0; i < length - 1; i++) {
            node = node[path[i]];
            if (!node) {
                return undefined;
            }
        }
        return node[path[i]];
    };
    var coreSetAvailableBundles = function(Cldr, json) {
        var bundle, availableBundleMapQueue = Cldr._availableBundleMapQueue, main = resourceGet(json, [ "main" ]);
        if (main) {
            for (bundle in main) {
                if (main.hasOwnProperty(bundle) && bundle !== "root" && availableBundleMapQueue.indexOf(bundle) === -1) {
                    availableBundleMapQueue.push(bundle);
                }
            }
        }
    };
    var alwaysArray = function(somethingOrArray) {
        return arrayIsArray(somethingOrArray) ? somethingOrArray : [ somethingOrArray ];
    };
    var jsonMerge = function() {
        var merge = function() {
            var destination = {}, sources = [].slice.call(arguments, 0);
            arrayForEach(sources, function(source) {
                var prop;
                for (prop in source) {
                    if (prop in destination && typeof destination[prop] === "object" && !arrayIsArray(destination[prop])) {
                        destination[prop] = merge(destination[prop], source[prop]);
                    } else {
                        destination[prop] = source[prop];
                    }
                }
            });
            return destination;
        };
        return merge;
    }();
    var coreLoad = function(Cldr, source, jsons) {
        var i, j, json;
        validatePresence(jsons[0], "json");
        for (i = 0; i < jsons.length; i++) {
            json = alwaysArray(jsons[i]);
            for (j = 0; j < json.length; j++) {
                validateTypePlainObject(json[j], "json");
                source = jsonMerge(source, json[j]);
                coreSetAvailableBundles(Cldr, json[j]);
            }
        }
        return source;
    };
    var itemGetResolved = function(Cldr, path, attributes) {
        var normalizedPath = pathNormalize(path, attributes);
        return resourceGet(Cldr._resolved, normalizedPath);
    };
    var Cldr = function(locale) {
        this.init(locale);
    };
    Cldr._alwaysArray = alwaysArray;
    Cldr._coreLoad = coreLoad;
    Cldr._createError = createError;
    Cldr._itemGetResolved = itemGetResolved;
    Cldr._jsonMerge = jsonMerge;
    Cldr._pathNormalize = pathNormalize;
    Cldr._resourceGet = resourceGet;
    Cldr._validatePresence = validatePresence;
    Cldr._validateType = validateType;
    Cldr._validateTypePath = validateTypePath;
    Cldr._validateTypePlainObject = validateTypePlainObject;
    Cldr._availableBundleMap = {};
    Cldr._availableBundleMapQueue = [];
    Cldr._resolved = {};
    Cldr.localeSep = "-";
    Cldr.load = function() {
        Cldr._resolved = coreLoad(Cldr, Cldr._resolved, arguments);
    };
    Cldr.prototype.init = function(locale) {
        var attributes, language, maxLanguageId, minLanguageId, script, subtags, territory, unicodeLocaleExtensions, variant, sep = Cldr.localeSep, unicodeLocaleExtensionsRaw = "";
        validatePresence(locale, "locale");
        validateTypeString(locale, "locale");
        subtags = coreSubtags(locale);
        if (subtags.length === 5) {
            unicodeLocaleExtensions = subtags.pop();
            unicodeLocaleExtensionsRaw = sep + "u" + sep + unicodeLocaleExtensions;
            if (!subtags[3]) {
                subtags.pop();
            }
        }
        variant = subtags[3];
        maxLanguageId = coreLikelySubtags(Cldr, this, subtags, {
            force: true
        }) || subtags;
        language = maxLanguageId[0];
        script = maxLanguageId[1];
        territory = maxLanguageId[2];
        minLanguageId = coreRemoveLikelySubtags(Cldr, this, maxLanguageId).join(sep);
        this.attributes = attributes = {
            bundle: bundleLookup(Cldr, this, minLanguageId),
            minLanguageId: minLanguageId + unicodeLocaleExtensionsRaw,
            maxLanguageId: maxLanguageId.join(sep) + unicodeLocaleExtensionsRaw,
            language: language,
            script: script,
            territory: territory,
            region: territory,
            variant: variant
        };
        unicodeLocaleExtensions && ("-" + unicodeLocaleExtensions).replace(/-[a-z]{3,8}|(-[a-z]{2})-([a-z]{3,8})/g, function(attribute, key, type) {
            if (key) {
                attributes["u" + key] = type;
            } else {
                attributes["u" + attribute] = true;
            }
        });
        this.locale = locale;
    };
    Cldr.prototype.get = function(path) {
        validatePresence(path, "path");
        validateTypePath(path, "path");
        return itemGetResolved(Cldr, path, this.attributes);
    };
    Cldr.prototype.main = function(path) {
        validatePresence(path, "path");
        validateTypePath(path, "path");
        validate("E_MISSING_BUNDLE", this.attributes.bundle !== null, {
            locale: this.locale
        });
        path = alwaysArray(path);
        return this.get([ "main/{bundle}" ].concat(path));
    };
    return Cldr;
});

(function(factory) {
    if (typeof define === "function" && define.amd) {
        define([ "../cldr" ], factory);
    } else if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = factory(require("../cldr"));
    } else {
        factory(Cldr);
    }
})(function(Cldr) {
    var pathNormalize = Cldr._pathNormalize, validatePresence = Cldr._validatePresence, validateType = Cldr._validateType;
    var EventEmitter;
    EventEmitter = function() {
        function EventEmitter() {}
        var proto = EventEmitter.prototype;
        var exports = {};
        function indexOfListener(listeners, listener) {
            var i = listeners.length;
            while (i--) {
                if (listeners[i].listener === listener) {
                    return i;
                }
            }
            return -1;
        }
        function alias(name) {
            return function aliasClosure() {
                return this[name].apply(this, arguments);
            };
        }
        proto.getListeners = function getListeners(evt) {
            var events = this._getEvents();
            var response;
            var key;
            if (evt instanceof RegExp) {
                response = {};
                for (key in events) {
                    if (events.hasOwnProperty(key) && evt.test(key)) {
                        response[key] = events[key];
                    }
                }
            } else {
                response = events[evt] || (events[evt] = []);
            }
            return response;
        };
        proto.flattenListeners = function flattenListeners(listeners) {
            var flatListeners = [];
            var i;
            for (i = 0; i < listeners.length; i += 1) {
                flatListeners.push(listeners[i].listener);
            }
            return flatListeners;
        };
        proto.getListenersAsObject = function getListenersAsObject(evt) {
            var listeners = this.getListeners(evt);
            var response;
            if (listeners instanceof Array) {
                response = {};
                response[evt] = listeners;
            }
            return response || listeners;
        };
        proto.addListener = function addListener(evt, listener) {
            var listeners = this.getListenersAsObject(evt);
            var listenerIsWrapped = typeof listener === "object";
            var key;
            for (key in listeners) {
                if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
                    listeners[key].push(listenerIsWrapped ? listener : {
                        listener: listener,
                        once: false
                    });
                }
            }
            return this;
        };
        proto.on = alias("addListener");
        proto.addOnceListener = function addOnceListener(evt, listener) {
            return this.addListener(evt, {
                listener: listener,
                once: true
            });
        };
        proto.once = alias("addOnceListener");
        proto.defineEvent = function defineEvent(evt) {
            this.getListeners(evt);
            return this;
        };
        proto.defineEvents = function defineEvents(evts) {
            for (var i = 0; i < evts.length; i += 1) {
                this.defineEvent(evts[i]);
            }
            return this;
        };
        proto.removeListener = function removeListener(evt, listener) {
            var listeners = this.getListenersAsObject(evt);
            var index;
            var key;
            for (key in listeners) {
                if (listeners.hasOwnProperty(key)) {
                    index = indexOfListener(listeners[key], listener);
                    if (index !== -1) {
                        listeners[key].splice(index, 1);
                    }
                }
            }
            return this;
        };
        proto.off = alias("removeListener");
        proto.addListeners = function addListeners(evt, listeners) {
            return this.manipulateListeners(false, evt, listeners);
        };
        proto.removeListeners = function removeListeners(evt, listeners) {
            return this.manipulateListeners(true, evt, listeners);
        };
        proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
            var i;
            var value;
            var single = remove ? this.removeListener : this.addListener;
            var multiple = remove ? this.removeListeners : this.addListeners;
            if (typeof evt === "object" && !(evt instanceof RegExp)) {
                for (i in evt) {
                    if (evt.hasOwnProperty(i) && (value = evt[i])) {
                        if (typeof value === "function") {
                            single.call(this, i, value);
                        } else {
                            multiple.call(this, i, value);
                        }
                    }
                }
            } else {
                i = listeners.length;
                while (i--) {
                    single.call(this, evt, listeners[i]);
                }
            }
            return this;
        };
        proto.removeEvent = function removeEvent(evt) {
            var type = typeof evt;
            var events = this._getEvents();
            var key;
            if (type === "string") {
                delete events[evt];
            } else if (evt instanceof RegExp) {
                for (key in events) {
                    if (events.hasOwnProperty(key) && evt.test(key)) {
                        delete events[key];
                    }
                }
            } else {
                delete this._events;
            }
            return this;
        };
        proto.removeAllListeners = alias("removeEvent");
        proto.emitEvent = function emitEvent(evt, args) {
            var listeners = this.getListenersAsObject(evt);
            var listener;
            var i;
            var key;
            var response;
            for (key in listeners) {
                if (listeners.hasOwnProperty(key)) {
                    i = listeners[key].length;
                    while (i--) {
                        listener = listeners[key][i];
                        if (listener.once === true) {
                            this.removeListener(evt, listener.listener);
                        }
                        response = listener.listener.apply(this, args || []);
                        if (response === this._getOnceReturnValue()) {
                            this.removeListener(evt, listener.listener);
                        }
                    }
                }
            }
            return this;
        };
        proto.trigger = alias("emitEvent");
        proto.emit = function emit(evt) {
            var args = Array.prototype.slice.call(arguments, 1);
            return this.emitEvent(evt, args);
        };
        proto.setOnceReturnValue = function setOnceReturnValue(value) {
            this._onceReturnValue = value;
            return this;
        };
        proto._getOnceReturnValue = function _getOnceReturnValue() {
            if (this.hasOwnProperty("_onceReturnValue")) {
                return this._onceReturnValue;
            } else {
                return true;
            }
        };
        proto._getEvents = function _getEvents() {
            return this._events || (this._events = {});
        };
        EventEmitter.noConflict = function noConflict() {
            exports.EventEmitter = originalGlobalValue;
            return EventEmitter;
        };
        return EventEmitter;
    }();
    var validateTypeFunction = function(value, name) {
        validateType(value, name, typeof value === "undefined" || typeof value === "function", "Function");
    };
    var superGet, superInit, globalEe = new EventEmitter();
    function validateTypeEvent(value, name) {
        validateType(value, name, typeof value === "string" || value instanceof RegExp, "String or RegExp");
    }
    function validateThenCall(method, self) {
        return function(event, listener) {
            validatePresence(event, "event");
            validateTypeEvent(event, "event");
            validatePresence(listener, "listener");
            validateTypeFunction(listener, "listener");
            return self[method].apply(self, arguments);
        };
    }
    function off(self) {
        return validateThenCall("off", self);
    }
    function on(self) {
        return validateThenCall("on", self);
    }
    function once(self) {
        return validateThenCall("once", self);
    }
    Cldr.off = off(globalEe);
    Cldr.on = on(globalEe);
    Cldr.once = once(globalEe);
    superInit = Cldr.prototype.init;
    Cldr.prototype.init = function() {
        var ee;
        this.ee = ee = new EventEmitter();
        this.off = off(ee);
        this.on = on(ee);
        this.once = once(ee);
        superInit.apply(this, arguments);
    };
    function getOverload() {
        superGet = Cldr.prototype.get;
        Cldr.prototype.get = function(path) {
            var value = superGet.apply(this, arguments);
            path = pathNormalize(path, this.attributes).join("/");
            globalEe.trigger("get", [ path, value ]);
            this.ee.trigger("get", [ path, value ]);
            return value;
        };
    }
    Cldr._eventInit = getOverload;
    getOverload();
    return Cldr;
});

(function(factory) {
    if (typeof define === "function" && define.amd) {
        define([ "../cldr" ], factory);
    } else if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = factory(require("../cldr"));
    } else {
        factory(Cldr);
    }
})(function(Cldr) {
    var alwaysArray = Cldr._alwaysArray;
    var supplementalMain = function(cldr) {
        var prepend, supplemental;
        prepend = function(prepend) {
            return function(path) {
                path = alwaysArray(path);
                return cldr.get([ prepend ].concat(path));
            };
        };
        supplemental = prepend("supplemental");
        supplemental.weekData = prepend("supplemental/weekData");
        supplemental.weekData.firstDay = function() {
            return cldr.get("supplemental/weekData/firstDay/{territory}") || cldr.get("supplemental/weekData/firstDay/001");
        };
        supplemental.weekData.minDays = function() {
            var minDays = cldr.get("supplemental/weekData/minDays/{territory}") || cldr.get("supplemental/weekData/minDays/001");
            return parseInt(minDays, 10);
        };
        supplemental.timeData = prepend("supplemental/timeData");
        supplemental.timeData.allowed = function() {
            return cldr.get("supplemental/timeData/{territory}/_allowed") || cldr.get("supplemental/timeData/001/_allowed");
        };
        supplemental.timeData.preferred = function() {
            return cldr.get("supplemental/timeData/{territory}/_preferred") || cldr.get("supplemental/timeData/001/_preferred");
        };
        return supplemental;
    };
    var initSuper = Cldr.prototype.init;
    Cldr.prototype.init = function() {
        initSuper.apply(this, arguments);
        this.supplemental = supplementalMain(this);
    };
    return Cldr;
});

(function(root, factory) {
    if (typeof define === "function" && define.amd) {
        define([ "cldr", "cldr/event" ], factory);
    } else if (typeof exports === "object") {
        module.exports = factory(require("cldrjs"));
    } else {
        root.Globalize = factory(root.Cldr);
    }
})(this, function(Cldr) {
    var toString = function(variable) {
        return typeof variable === "string" ? variable : typeof variable === "number" ? "" + variable : JSON.stringify(variable);
    };
    var formatMessage = function(message, data) {
        message = message.replace(/{[0-9a-zA-Z-_. ]+}/g, function(name) {
            name = name.replace(/^{([^}]*)}$/, "$1");
            return toString(data[name]);
        });
        return message;
    };
    var objectExtend = function() {
        var destination = arguments[0], sources = [].slice.call(arguments, 1);
        sources.forEach(function(source) {
            var prop;
            for (prop in source) {
                destination[prop] = source[prop];
            }
        });
        return destination;
    };
    var createError = function(code, message, attributes) {
        var error;
        message = code + (message ? ": " + formatMessage(message, attributes) : "");
        error = new Error(message);
        error.code = code;
        objectExtend(error, attributes);
        return error;
    };
    var stringHash = function(str) {
        return [].reduce.call(str, function(hash, i) {
            var chr = i.charCodeAt(0);
            hash = (hash << 5) - hash + chr;
            return hash | 0;
        }, 0);
    };
    var runtimeKey = function(fnName, locale, args, argsStr) {
        var hash;
        argsStr = argsStr || JSON.stringify(args);
        hash = stringHash(fnName + locale + argsStr);
        return hash > 0 ? "a" + hash : "b" + Math.abs(hash);
    };
    var functionName = function(fn) {
        if (fn.name !== undefined) {
            return fn.name;
        }
        var matches = /^function\s+([\w\$]+)\s*\(/.exec(fn.toString());
        if (matches && matches.length > 0) {
            return matches[1];
        }
    };
    var runtimeBind = function(args, cldr, fn, runtimeArgs) {
        var argsStr = JSON.stringify(args), fnName = functionName(fn), locale = cldr.locale;
        if (!fnName) {
            return fn;
        }
        fn.runtimeKey = runtimeKey(fnName, locale, null, argsStr);
        fn.generatorString = function() {
            return 'Globalize("' + locale + '").' + fnName + "(" + argsStr.slice(1, -1) + ")";
        };
        fn.runtimeArgs = runtimeArgs;
        return fn;
    };
    var validate = function(code, message, check, attributes) {
        if (!check) {
            throw createError(code, message, attributes);
        }
    };
    var alwaysArray = function(stringOrArray) {
        return Array.isArray(stringOrArray) ? stringOrArray : stringOrArray ? [ stringOrArray ] : [];
    };
    var validateCldr = function(path, value, options) {
        var skipBoolean;
        options = options || {};
        skipBoolean = alwaysArray(options.skip).some(function(pathRe) {
            return pathRe.test(path);
        });
        validate("E_MISSING_CLDR", "Missing required CLDR content `{path}`.", value || skipBoolean, {
            path: path
        });
    };
    var validateDefaultLocale = function(value) {
        validate("E_DEFAULT_LOCALE_NOT_DEFINED", "Default locale has not been defined.", value !== undefined, {});
    };
    var validateParameterPresence = function(value, name) {
        validate("E_MISSING_PARAMETER", "Missing required parameter `{name}`.", value !== undefined, {
            name: name
        });
    };
    var validateParameterRange = function(value, name, minimum, maximum) {
        validate("E_PAR_OUT_OF_RANGE", "Parameter `{name}` has value `{value}` out of range [{minimum}, {maximum}].", value === undefined || value >= minimum && value <= maximum, {
            maximum: maximum,
            minimum: minimum,
            name: name,
            value: value
        });
    };
    var validateParameterType = function(value, name, check, expected) {
        validate("E_INVALID_PAR_TYPE", "Invalid `{name}` parameter ({value}). {expected} expected.", check, {
            expected: expected,
            name: name,
            value: value
        });
    };
    var validateParameterTypeLocale = function(value, name) {
        validateParameterType(value, name, value === undefined || typeof value === "string" || value instanceof Cldr, "String or Cldr instance");
    };
    var isPlainObject = function(obj) {
        return obj !== null && "" + obj === "[object Object]";
    };
    var validateParameterTypePlainObject = function(value, name) {
        validateParameterType(value, name, value === undefined || isPlainObject(value), "Plain Object");
    };
    var alwaysCldr = function(localeOrCldr) {
        return localeOrCldr instanceof Cldr ? localeOrCldr : new Cldr(localeOrCldr);
    };
    var regexpEscape = function(string) {
        return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
    };
    var stringPad = function(str, count, right) {
        var length;
        if (typeof str !== "string") {
            str = String(str);
        }
        for (length = str.length; length < count; length += 1) {
            str = right ? str + "0" : "0" + str;
        }
        return str;
    };
    function validateLikelySubtags(cldr) {
        cldr.once("get", validateCldr);
        cldr.get("supplemental/likelySubtags");
    }
    function Globalize(locale) {
        if (!(this instanceof Globalize)) {
            return new Globalize(locale);
        }
        validateParameterPresence(locale, "locale");
        validateParameterTypeLocale(locale, "locale");
        this.cldr = alwaysCldr(locale);
        validateLikelySubtags(this.cldr);
    }
    Globalize.load = function() {
        Cldr.load.apply(Cldr, arguments);
    };
    Globalize.locale = function(locale) {
        validateParameterTypeLocale(locale, "locale");
        if (arguments.length) {
            this.cldr = alwaysCldr(locale);
            validateLikelySubtags(this.cldr);
        }
        return this.cldr;
    };
    Globalize._alwaysArray = alwaysArray;
    Globalize._createError = createError;
    Globalize._formatMessage = formatMessage;
    Globalize._isPlainObject = isPlainObject;
    Globalize._objectExtend = objectExtend;
    Globalize._regexpEscape = regexpEscape;
    Globalize._runtimeBind = runtimeBind;
    Globalize._stringPad = stringPad;
    Globalize._validate = validate;
    Globalize._validateCldr = validateCldr;
    Globalize._validateDefaultLocale = validateDefaultLocale;
    Globalize._validateParameterPresence = validateParameterPresence;
    Globalize._validateParameterRange = validateParameterRange;
    Globalize._validateParameterTypePlainObject = validateParameterTypePlainObject;
    Globalize._validateParameterType = validateParameterType;
    return Globalize;
});

(function(root, factory) {
    if (typeof define === "function" && define.amd) {
        define([ "cldr", "../globalize", "cldr/event", "cldr/supplemental" ], factory);
    } else if (typeof exports === "object") {
        module.exports = factory(require("cldrjs"), require("../globalize"));
    } else {
        factory(root.Cldr, root.Globalize);
    }
})(this, function(Cldr, Globalize) {
    var createError = Globalize._createError, regexpEscape = Globalize._regexpEscape, runtimeBind = Globalize._runtimeBind, stringPad = Globalize._stringPad, validateCldr = Globalize._validateCldr, validateDefaultLocale = Globalize._validateDefaultLocale, validateParameterPresence = Globalize._validateParameterPresence, validateParameterRange = Globalize._validateParameterRange, validateParameterType = Globalize._validateParameterType, validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;
    var createErrorUnsupportedFeature = function(feature) {
        return createError("E_UNSUPPORTED", "Unsupported {feature}.", {
            feature: feature
        });
    };
    var validateParameterTypeNumber = function(value, name) {
        validateParameterType(value, name, value === undefined || typeof value === "number", "Number");
    };
    var validateParameterTypeString = function(value, name) {
        validateParameterType(value, name, value === undefined || typeof value === "string", "a string");
    };
    var numberFormatGroupingSeparator = function(number, primaryGroupingSize, secondaryGroupingSize) {
        var index, currentGroupingSize = primaryGroupingSize, ret = "", sep = ",", switchToSecondary = secondaryGroupingSize ? true : false;
        number = String(number).split(".");
        index = number[0].length;
        while (index > currentGroupingSize) {
            ret = number[0].slice(index - currentGroupingSize, index) + (ret.length ? sep : "") + ret;
            index -= currentGroupingSize;
            if (switchToSecondary) {
                currentGroupingSize = secondaryGroupingSize;
                switchToSecondary = false;
            }
        }
        number[0] = number[0].slice(0, index) + (ret.length ? sep : "") + ret;
        return number.join(".");
    };
    var numberFormatIntegerFractionDigits = function(number, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, round, roundIncrement) {
        if (maximumFractionDigits) {
            if (roundIncrement) {
                number = round(number, roundIncrement);
            } else {
                number = round(number, {
                    exponent: -maximumFractionDigits
                });
            }
        } else {
            number = round(number);
        }
        number = String(number);
        if (maximumFractionDigits && /e-/.test(number)) {
            number = (+number).toFixed(maximumFractionDigits).replace(/0+$/, "").replace(/\.$/, "");
        }
        if (minimumFractionDigits) {
            number = number.split(".");
            number[1] = stringPad(number[1] || "", minimumFractionDigits, true);
            number = number.join(".");
        }
        if (minimumIntegerDigits) {
            number = number.split(".");
            number[0] = stringPad(number[0], minimumIntegerDigits);
            number = number.join(".");
        }
        return number;
    };
    var numberToPrecision = function(number, precision, round) {
        var roundOrder;
        number = number.toPrecision(precision + 2);
        roundOrder = Math.ceil(Math.log(Math.abs(number)) / Math.log(10));
        roundOrder -= precision;
        return round(number, {
            exponent: roundOrder
        });
    };
    var numberFormatSignificantDigits = function(number, minimumSignificantDigits, maximumSignificantDigits, round) {
        var atMinimum, atMaximum;
        if (minimumSignificantDigits > maximumSignificantDigits) {
            maximumSignificantDigits = minimumSignificantDigits;
        }
        atMinimum = numberToPrecision(number, minimumSignificantDigits, round);
        atMaximum = numberToPrecision(number, maximumSignificantDigits, round);
        number = +atMinimum === +atMaximum ? atMinimum : atMaximum;
        number = (+number).toString(10);
        if (/e/.test(number)) {
            throw createErrorUnsupportedFeature({
                feature: "integers out of (1e21, 1e-7)"
            });
        }
        if (minimumSignificantDigits - number.replace(/^0+|\./g, "").length > 0) {
            number = number.split(".");
            number[1] = stringPad(number[1] || "", minimumSignificantDigits - number[0].replace(/^0+/, "").length, true);
            number = number.join(".");
        }
        return number;
    };
    var removeLiteralQuotes = function(string) {
        if (string[0] + string[string.length - 1] !== "''") {
            return string;
        }
        if (string === "''") {
            return "";
        }
        return string.replace(/''/g, "'").slice(1, -1);
    };
    var numberFormat = function(number, properties) {
        var infinitySymbol, maximumFractionDigits, maximumSignificantDigits, minimumFractionDigits, minimumIntegerDigits, minimumSignificantDigits, nanSymbol, nuDigitsMap, padding, prefix, primaryGroupingSize, pattern, ret, round, roundIncrement, secondaryGroupingSize, suffix, symbolMap;
        padding = properties[1];
        minimumIntegerDigits = properties[2];
        minimumFractionDigits = properties[3];
        maximumFractionDigits = properties[4];
        minimumSignificantDigits = properties[5];
        maximumSignificantDigits = properties[6];
        roundIncrement = properties[7];
        primaryGroupingSize = properties[8];
        secondaryGroupingSize = properties[9];
        round = properties[15];
        infinitySymbol = properties[16];
        nanSymbol = properties[17];
        symbolMap = properties[18];
        nuDigitsMap = properties[19];
        if (isNaN(number)) {
            return nanSymbol;
        }
        if (number < 0) {
            pattern = properties[12];
            prefix = properties[13];
            suffix = properties[14];
        } else {
            pattern = properties[11];
            prefix = properties[0];
            suffix = properties[10];
        }
        if (!isFinite(number)) {
            return prefix + infinitySymbol + suffix;
        }
        ret = prefix;
        if (pattern.indexOf("%") !== -1) {
            number *= 100;
        } else if (pattern.indexOf("‰") !== -1) {
            number *= 1e3;
        }
        if (!isNaN(minimumSignificantDigits * maximumSignificantDigits)) {
            number = numberFormatSignificantDigits(number, minimumSignificantDigits, maximumSignificantDigits, round);
        } else {
            number = numberFormatIntegerFractionDigits(number, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, round, roundIncrement);
        }
        number = number.replace(/^-/, "");
        if (primaryGroupingSize) {
            number = numberFormatGroupingSeparator(number, primaryGroupingSize, secondaryGroupingSize);
        }
        ret += number;
        ret += suffix;
        return ret.replace(/('([^']|'')+'|'')|./g, function(character, literal) {
            if (literal) {
                return removeLiteralQuotes(literal);
            }
            character = character.replace(/[.,\-+E%\u2030]/, function(symbol) {
                return symbolMap[symbol];
            });
            if (nuDigitsMap) {
                character = character.replace(/[0-9]/, function(digit) {
                    return nuDigitsMap[+digit];
                });
            }
            return character;
        });
    };
    var numberFormatterFn = function(properties) {
        return function numberFormatter(value) {
            validateParameterPresence(value, "value");
            validateParameterTypeNumber(value, "value");
            return numberFormat(value, properties);
        };
    };
    var numberNumberingSystem = function(cldr) {
        var nu = cldr.attributes["u-nu"];
        if (nu) {
            if (nu === "traditio") {
                nu = "traditional";
            }
            if ([ "native", "traditional", "finance" ].indexOf(nu) !== -1) {
                return cldr.main([ "numbers/otherNumberingSystems", nu ]);
            }
            return nu;
        }
        return cldr.main("numbers/defaultNumberingSystem");
    };
    var numberNumberingSystemDigitsMap = function(cldr) {
        var aux, nu = numberNumberingSystem(cldr);
        if (nu === "latn") {
            return;
        }
        aux = cldr.supplemental([ "numberingSystems", nu ]);
        if (aux._type !== "numeric") {
            throw createErrorUnsupportedFeature("`" + aux._type + "` numbering system");
        }
        return aux._digits;
    };
    var numberPatternRe = /^(('([^']|'')*'|[^*#@0,.E])*)(\*.)?((([#,]*[0,]*0+)(\.0*[0-9]*#*)?)|([#,]*@+#*))(E\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/;
    var numberPatternProperties = function(pattern) {
        var aux1, aux2, fractionPattern, integerFractionOrSignificantPattern, integerPattern, maximumFractionDigits, maximumSignificantDigits, minimumFractionDigits, minimumIntegerDigits, minimumSignificantDigits, padding, prefix, primaryGroupingSize, roundIncrement, scientificNotation, secondaryGroupingSize, significantPattern, suffix;
        pattern = pattern.match(numberPatternRe);
        if (!pattern) {
            throw new Error("Invalid pattern: " + pattern);
        }
        prefix = pattern[1];
        padding = pattern[4];
        integerFractionOrSignificantPattern = pattern[5];
        significantPattern = pattern[9];
        scientificNotation = pattern[10];
        suffix = pattern[11];
        if (significantPattern) {
            significantPattern.replace(/(@+)(#*)/, function(match, minimumSignificantDigitsMatch, maximumSignificantDigitsMatch) {
                minimumSignificantDigits = minimumSignificantDigitsMatch.length;
                maximumSignificantDigits = minimumSignificantDigits + maximumSignificantDigitsMatch.length;
            });
        } else {
            fractionPattern = pattern[8];
            integerPattern = pattern[7];
            if (fractionPattern) {
                fractionPattern.replace(/[0-9]+/, function(match) {
                    minimumFractionDigits = match;
                });
                if (minimumFractionDigits) {
                    roundIncrement = +("0." + minimumFractionDigits);
                    minimumFractionDigits = minimumFractionDigits.length;
                } else {
                    minimumFractionDigits = 0;
                }
                maximumFractionDigits = fractionPattern.length - 1;
            }
            integerPattern.replace(/0+$/, function(match) {
                minimumIntegerDigits = match.length;
            });
        }
        if (scientificNotation) {
            throw createErrorUnsupportedFeature({
                feature: "scientific notation (not implemented)"
            });
        }
        if (padding) {
            throw createErrorUnsupportedFeature({
                feature: "padding (not implemented)"
            });
        }
        if ((aux1 = integerFractionOrSignificantPattern.lastIndexOf(",")) !== -1) {
            aux2 = integerFractionOrSignificantPattern.split(".")[0];
            primaryGroupingSize = aux2.length - aux1 - 1;
            if ((aux2 = integerFractionOrSignificantPattern.lastIndexOf(",", aux1 - 1)) !== -1) {
                secondaryGroupingSize = aux1 - 1 - aux2;
            }
        }
        return [ prefix, padding, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, minimumSignificantDigits, maximumSignificantDigits, roundIncrement, primaryGroupingSize, secondaryGroupingSize, suffix ];
    };
    var numberSymbol = function(name, cldr) {
        return cldr.main([ "numbers/symbols-numberSystem-" + numberNumberingSystem(cldr), name ]);
    };
    var numberSymbolName = {
        ".": "decimal",
        ",": "group",
        "%": "percentSign",
        "+": "plusSign",
        "-": "minusSign",
        E: "exponential",
        "‰": "perMille"
    };
    var numberSymbolMap = function(cldr) {
        var symbol, symbolMap = {};
        for (symbol in numberSymbolName) {
            symbolMap[symbol] = numberSymbol(numberSymbolName[symbol], cldr);
        }
        return symbolMap;
    };
    var numberTruncate = function(value) {
        if (isNaN(value)) {
            return NaN;
        }
        return Math[value < 0 ? "ceil" : "floor"](value);
    };
    var numberRound = function(method) {
        method = method || "round";
        method = method === "truncate" ? numberTruncate : Math[method];
        return function(value, incrementOrExp) {
            var exp, increment;
            value = +value;
            if (isNaN(value)) {
                return NaN;
            }
            if (typeof incrementOrExp === "object" && incrementOrExp.exponent) {
                exp = +incrementOrExp.exponent;
                increment = 1;
                if (exp === 0) {
                    return method(value);
                }
                if (!(typeof exp === "number" && exp % 1 === 0)) {
                    return NaN;
                }
            } else {
                increment = +incrementOrExp || 1;
                if (increment === 1) {
                    return method(value);
                }
                if (isNaN(increment)) {
                    return NaN;
                }
                increment = increment.toExponential().split("e");
                exp = +increment[1];
                increment = +increment[0];
            }
            value = value.toString().split("e");
            value[0] = +value[0] / increment;
            value[1] = value[1] ? +value[1] - exp : -exp;
            value = method(+(value[0] + "e" + value[1]));
            value = value.toString().split("e");
            value[0] = +value[0] * increment;
            value[1] = value[1] ? +value[1] + exp : exp;
            return +(value[0] + "e" + value[1]);
        };
    };
    var numberFormatProperties = function(pattern, cldr, options) {
        var negativePattern, negativePrefix, negativeProperties, negativeSuffix, positivePattern, roundFn, properties;
        function getOptions(attribute, propertyIndex) {
            if (attribute in options) {
                properties[propertyIndex] = options[attribute];
            }
        }
        options = options || {};
        pattern = pattern.split(";");
        positivePattern = pattern[0];
        negativePattern = pattern[1] || "-" + positivePattern;
        negativeProperties = numberPatternProperties(negativePattern);
        negativePrefix = negativeProperties[0];
        negativeSuffix = negativeProperties[10];
        roundFn = numberRound(options.round);
        roundFn.generatorString = function() {
            return "numberRound(" + (options.round ? '"' + options.round + '"' : "") + ")";
        };
        properties = numberPatternProperties(positivePattern).concat([ positivePattern, negativePrefix + positivePattern + negativeSuffix, negativePrefix, negativeSuffix, roundFn, numberSymbol("infinity", cldr), numberSymbol("nan", cldr), numberSymbolMap(cldr), numberNumberingSystemDigitsMap(cldr) ]);
        getOptions("minimumIntegerDigits", 2);
        getOptions("minimumFractionDigits", 3);
        getOptions("maximumFractionDigits", 4);
        getOptions("minimumSignificantDigits", 5);
        getOptions("maximumSignificantDigits", 6);
        if (options.useGrouping === false) {
            properties[8] = null;
        }
        if ("minimumFractionDigits" in options && !("maximumFractionDigits" in options)) {
            properties[4] = Math.max(properties[3], properties[4]);
        } else if (!("minimumFractionDigits" in options) && "maximumFractionDigits" in options) {
            properties[3] = Math.min(properties[3], properties[4]);
        }
        return properties;
    };
    var regexpCfG = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/g;
    var regexpDashG = /[\-\u058A\u05BE\u1400\u1806\u2010-\u2015\u2E17\u2E1A\u2E3A\u2E3B\u2E40\u301C\u3030\u30A0\uFE31\uFE32\uFE58\uFE63\uFF0D\u2212]/g;
    var regexpZsG = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/g;
    var looseMatching = function(value) {
        return value.replace(regexpCfG, "").replace(regexpDashG, "-").replace(regexpZsG, " ");
    };
    var numberParse = function(value, properties) {
        var grammar, invertedNuDigitsMap, invertedSymbolMap, negative, number, prefix, prefixNSuffix, suffix, tokenizer, valid;
        grammar = [ [ "nan" ], [ "prefix", "infinity", "suffix" ], [ "prefix", "number", "suffix" ], [ "negativePrefix", "infinity", "negativeSuffix" ], [ "negativePrefix", "number", "negativeSuffix" ] ];
        invertedSymbolMap = properties[0];
        invertedNuDigitsMap = properties[1] || {};
        tokenizer = properties[2];
        value = looseMatching(value);
        function parse(type) {
            return function(lexeme) {
                lexeme = lexeme.split("").map(function(character) {
                    return invertedSymbolMap[character] || invertedNuDigitsMap[character] || character;
                }).join("");
                switch (type) {
                  case "infinity":
                    number = Infinity;
                    break;

                  case "nan":
                    number = NaN;
                    break;

                  case "number":
                    lexeme = lexeme.replace(/,/g, "");
                    number = +lexeme;
                    break;

                  case "prefix":
                  case "negativePrefix":
                    prefix = lexeme;
                    break;

                  case "suffix":
                    suffix = lexeme;
                    break;

                  case "negativeSuffix":
                    suffix = lexeme;
                    negative = true;
                    break;

                  default:
                    throw new Error("Internal error");
                }
                return "";
            };
        }
        function tokenizeNParse(_value, grammar) {
            return grammar.some(function(statement) {
                var value = _value;
                return statement.every(function(type) {
                    if (value.match(tokenizer[type]) === null) {
                        return false;
                    }
                    value = value.replace(tokenizer[type], parse(type));
                    return true;
                }) && !value.length;
            });
        }
        valid = tokenizeNParse(value, grammar);
        if (!valid || isNaN(number)) {
            return NaN;
        }
        prefixNSuffix = "" + prefix + suffix;
        if (prefixNSuffix.indexOf("%") !== -1) {
            number /= 100;
        } else if (prefixNSuffix.indexOf("‰") !== -1) {
            number /= 1e3;
        }
        if (negative) {
            number *= -1;
        }
        return number;
    };
    var numberParserFn = function(properties) {
        return function numberParser(value) {
            validateParameterPresence(value, "value");
            validateParameterTypeString(value, "value");
            return numberParse(value, properties);
        };
    };
    var numberSymbolInvertedMap = function(cldr) {
        var symbol, symbolMap = {};
        for (symbol in numberSymbolName) {
            symbolMap[numberSymbol(numberSymbolName[symbol], cldr)] = symbol;
        }
        return symbolMap;
    };
    var objectMap = function(object, fn) {
        return Object.keys(object).map(function(key) {
            return fn([ key, object[key] ]);
        }).reduce(function(object, pair) {
            object[pair[0]] = pair[1];
            return object;
        }, {});
    };
    var numberParseProperties = function(pattern, cldr, options) {
        var aux, decimalSymbolRe, digitsRe, groupingSeparatorRe, infinitySymbol, invertedNuDigitsMap, invertedSymbolMap, maximumFractionDigits, maximumSignificantDigits, minimumSignificantDigits, nanSymbol, negativePrefix, negativeSuffix, nuDigitsMap, numberTokenizer, prefix, primaryGroupingSize, secondaryGroupingSize, suffix, symbolMap, formatProperties = numberFormatProperties(pattern, cldr, options);
        prefix = looseMatching(formatProperties[0]);
        maximumFractionDigits = formatProperties[4];
        minimumSignificantDigits = formatProperties[5];
        maximumSignificantDigits = formatProperties[6];
        primaryGroupingSize = formatProperties[8];
        secondaryGroupingSize = formatProperties[9];
        suffix = looseMatching(formatProperties[10]);
        negativePrefix = looseMatching(formatProperties[13]);
        negativeSuffix = looseMatching(formatProperties[14]);
        infinitySymbol = looseMatching(formatProperties[16]);
        nanSymbol = looseMatching(formatProperties[17]);
        symbolMap = objectMap(formatProperties[18], function(pair) {
            return [ pair[0], looseMatching(pair[1]) ];
        });
        nuDigitsMap = formatProperties[19];
        invertedSymbolMap = objectMap(numberSymbolInvertedMap(cldr), function(pair) {
            return [ looseMatching(pair[0]), pair[1] ];
        });
        digitsRe = nuDigitsMap ? "[" + nuDigitsMap + "]" : "\\d";
        groupingSeparatorRe = regexpEscape(symbolMap[","]);
        decimalSymbolRe = regexpEscape(symbolMap["."]);
        if (nuDigitsMap) {
            invertedNuDigitsMap = nuDigitsMap.split("").reduce(function(object, localizedDigit, i) {
                object[localizedDigit] = String(i);
                return object;
            }, {});
        }
        aux = [ prefix, suffix, negativePrefix, negativeSuffix ].map(function(value) {
            return value.replace(/('([^']|'')+'|'')|./g, function(character, literal) {
                if (literal) {
                    return removeLiteralQuotes(literal);
                }
                character = character.replace(/[\-+E%\u2030]/, function(symbol) {
                    return symbolMap[symbol];
                });
                return character;
            });
        });
        prefix = aux[0];
        suffix = aux[1];
        negativePrefix = aux[2];
        negativeSuffix = aux[3];
        numberTokenizer = digitsRe + "+";
        if (primaryGroupingSize) {
            if (secondaryGroupingSize) {
                aux = digitsRe + "{1," + secondaryGroupingSize + "}((" + groupingSeparatorRe + digitsRe + "{" + secondaryGroupingSize + "})*(" + groupingSeparatorRe + digitsRe + "{" + primaryGroupingSize + "}))";
            } else {
                aux = digitsRe + "{1," + primaryGroupingSize + "}(" + groupingSeparatorRe + digitsRe + "{" + primaryGroupingSize + "})+";
            }
            numberTokenizer = "(" + aux + "|" + numberTokenizer + ")";
        }
        if (!isNaN(minimumSignificantDigits * maximumSignificantDigits) || maximumFractionDigits) {
            aux = decimalSymbolRe + digitsRe + "+";
            numberTokenizer = numberTokenizer + "(" + aux + "|" + decimalSymbolRe + ")?" + "|(" + numberTokenizer + ")?" + aux;
            numberTokenizer = "(" + numberTokenizer + ")";
        }
        return [ invertedSymbolMap, invertedNuDigitsMap, {
            infinity: new RegExp("^" + regexpEscape(infinitySymbol)),
            nan: new RegExp("^" + regexpEscape(nanSymbol)),
            negativePrefix: new RegExp("^" + regexpEscape(negativePrefix)),
            negativeSuffix: new RegExp("^" + regexpEscape(negativeSuffix)),
            number: new RegExp("^" + numberTokenizer),
            prefix: new RegExp("^" + regexpEscape(prefix)),
            suffix: new RegExp("^" + regexpEscape(suffix))
        } ];
    };
    var numberPattern = function(style, cldr) {
        if (style !== "decimal" && style !== "percent") {
            throw new Error("Invalid style");
        }
        return cldr.main([ "numbers", style + "Formats-numberSystem-" + numberNumberingSystem(cldr), "standard" ]);
    };
    function validateDigits(properties) {
        var minimumIntegerDigits = properties[2], minimumFractionDigits = properties[3], maximumFractionDigits = properties[4], minimumSignificantDigits = properties[5], maximumSignificantDigits = properties[6];
        if (!isNaN(minimumSignificantDigits * maximumSignificantDigits)) {
            validateParameterRange(minimumSignificantDigits, "minimumSignificantDigits", 1, 21);
            validateParameterRange(maximumSignificantDigits, "maximumSignificantDigits", minimumSignificantDigits, 21);
        } else if (!isNaN(minimumSignificantDigits) || !isNaN(maximumSignificantDigits)) {
            throw new Error("Neither or both the minimum and maximum significant digits must be " + "present");
        } else {
            validateParameterRange(minimumIntegerDigits, "minimumIntegerDigits", 1, 21);
            validateParameterRange(minimumFractionDigits, "minimumFractionDigits", 0, 20);
            validateParameterRange(maximumFractionDigits, "maximumFractionDigits", minimumFractionDigits, 20);
        }
    }
    Globalize.numberFormatter = Globalize.prototype.numberFormatter = function(options) {
        var args, cldr, pattern, properties, returnFn;
        validateParameterTypePlainObject(options, "options");
        options = options || {};
        cldr = this.cldr;
        args = [ options ];
        validateDefaultLocale(cldr);
        cldr.on("get", validateCldr);
        if (options.raw) {
            pattern = options.raw;
        } else {
            pattern = numberPattern(options.style || "decimal", cldr);
        }
        properties = numberFormatProperties(pattern, cldr, options);
        cldr.off("get", validateCldr);
        validateDigits(properties);
        returnFn = numberFormatterFn(properties);
        runtimeBind(args, cldr, returnFn, [ properties ]);
        return returnFn;
    };
    Globalize.numberParser = Globalize.prototype.numberParser = function(options) {
        var args, cldr, pattern, properties, returnFn;
        validateParameterTypePlainObject(options, "options");
        options = options || {};
        cldr = this.cldr;
        args = [ options ];
        validateDefaultLocale(cldr);
        cldr.on("get", validateCldr);
        if (options.raw) {
            pattern = options.raw;
        } else {
            pattern = numberPattern(options.style || "decimal", cldr);
        }
        properties = numberParseProperties(pattern, cldr, options);
        cldr.off("get", validateCldr);
        returnFn = numberParserFn(properties);
        runtimeBind(args, cldr, returnFn, [ properties ]);
        return returnFn;
    };
    Globalize.formatNumber = Globalize.prototype.formatNumber = function(value, options) {
        validateParameterPresence(value, "value");
        validateParameterTypeNumber(value, "value");
        return this.numberFormatter(options)(value);
    };
    Globalize.parseNumber = Globalize.prototype.parseNumber = function(value, options) {
        validateParameterPresence(value, "value");
        validateParameterTypeString(value, "value");
        return this.numberParser(options)(value);
    };
    Globalize._createErrorUnsupportedFeature = createErrorUnsupportedFeature;
    Globalize._numberNumberingSystem = numberNumberingSystem;
    Globalize._numberNumberingSystemDigitsMap = numberNumberingSystemDigitsMap;
    Globalize._numberPattern = numberPattern;
    Globalize._numberSymbol = numberSymbol;
    Globalize._looseMatching = looseMatching;
    Globalize._removeLiteralQuotes = removeLiteralQuotes;
    Globalize._stringPad = stringPad;
    Globalize._validateParameterTypeNumber = validateParameterTypeNumber;
    Globalize._validateParameterTypeString = validateParameterTypeString;
    return Globalize;
});

(function(root, factory) {
    if (typeof define === "function" && define.amd) {
        define([ "cldr", "../globalize", "./number", "cldr/event", "cldr/supplemental" ], factory);
    } else if (typeof exports === "object") {
        module.exports = factory(require("cldrjs"), require("../globalize"));
    } else {
        factory(root.Cldr, root.Globalize);
    }
})(this, function(Cldr, Globalize) {
    var createError = Globalize._createError, createErrorUnsupportedFeature = Globalize._createErrorUnsupportedFeature, formatMessage = Globalize._formatMessage, isPlainObject = Globalize._isPlainObject, looseMatching = Globalize._looseMatching, numberNumberingSystemDigitsMap = Globalize._numberNumberingSystemDigitsMap, numberSymbol = Globalize._numberSymbol, regexpEscape = Globalize._regexpEscape, removeLiteralQuotes = Globalize._removeLiteralQuotes, runtimeBind = Globalize._runtimeBind, stringPad = Globalize._stringPad, validate = Globalize._validate, validateCldr = Globalize._validateCldr, validateDefaultLocale = Globalize._validateDefaultLocale, validateParameterPresence = Globalize._validateParameterPresence, validateParameterType = Globalize._validateParameterType, validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject, validateParameterTypeString = Globalize._validateParameterTypeString;
    var validateParameterTypeDate = function(value, name) {
        validateParameterType(value, name, value === undefined || value instanceof Date, "Date");
    };
    var createErrorInvalidParameterValue = function(name, value) {
        return createError("E_INVALID_PAR_VALUE", "Invalid `{name}` value ({value}).", {
            name: name,
            value: value
        });
    };
    var validateSkeletonFieldsPosMap = "GyYuUrQqMLlwWEecdDFghHKkmsSAzZOvVXx".split("").reduce(function(memo, item, i) {
        memo[item] = i;
        return memo;
    }, {});
    var validateSkeleton = function validateSkeleton(skeleton) {
        var last, fieldsPosMap = validateSkeletonFieldsPosMap;
        skeleton.replace(/[^GyYuUrQqMLlwWEecdDFghHKkmsSAzZOvVXx]/, function(field) {
            throw createError("E_INVALID_OPTIONS", "Invalid field `{invalidField}` of skeleton `{value}`", {
                invalidField: field,
                type: "skeleton",
                value: skeleton
            });
        });
        skeleton.split("").every(function(field) {
            if (fieldsPosMap[field] < last) {
                throw createError("E_INVALID_OPTIONS", "Invalid order `{invalidField}` of skeleton `{value}`", {
                    invalidField: field,
                    type: "skeleton",
                    value: skeleton
                });
            }
            last = fieldsPosMap[field];
            return true;
        });
    };
    var objectInvert = function(object, fn) {
        fn = fn || function(object, key, value) {
            object[value] = key;
            return object;
        };
        return Object.keys(object).reduce(function(newObject, key) {
            return fn(newObject, key, object[key]);
        }, {});
    };
    var dateExpandPatternSimilarFieldsMap = objectInvert({
        e: "eEc",
        L: "ML"
    }, function(object, key, value) {
        value.split("").forEach(function(field) {
            object[field] = key;
        });
        return object;
    });
    var dateExpandPatternNormalizePatternType = function(character) {
        return dateExpandPatternSimilarFieldsMap[character] || character;
    };
    var datePatternRe = /([a-z])\1*|'([^']|'')+'|''|./gi;
    var stringRepeat = function(str, count) {
        var i, result = "";
        for (i = 0; i < count; i++) {
            result = result + str;
        }
        return result;
    };
    var dateExpandPatternAugmentFormat = function(requestedSkeleton, bestMatchFormat) {
        var i, j, matchedType, matchedLength, requestedType, requestedLength, normalizePatternType = dateExpandPatternNormalizePatternType;
        requestedSkeleton = requestedSkeleton.match(datePatternRe);
        bestMatchFormat = bestMatchFormat.match(datePatternRe);
        for (i = 0; i < bestMatchFormat.length; i++) {
            matchedType = bestMatchFormat[i].charAt(0);
            matchedLength = bestMatchFormat[i].length;
            for (j = 0; j < requestedSkeleton.length; j++) {
                requestedType = requestedSkeleton[j].charAt(0);
                requestedLength = requestedSkeleton[j].length;
                if (normalizePatternType(matchedType) === normalizePatternType(requestedType) && matchedLength < requestedLength) {
                    bestMatchFormat[i] = stringRepeat(matchedType, requestedLength);
                }
            }
        }
        return bestMatchFormat.join("");
    };
    var dateExpandPatternCompareFormats = function(formatA, formatB) {
        var a, b, distance, lenA, lenB, typeA, typeB, i, j, normalizePatternType = dateExpandPatternNormalizePatternType;
        if (formatA === formatB) {
            return 0;
        }
        formatA = formatA.match(datePatternRe);
        formatB = formatB.match(datePatternRe);
        if (formatA.length !== formatB.length) {
            return -1;
        }
        distance = 1;
        for (i = 0; i < formatA.length; i++) {
            a = formatA[i].charAt(0);
            typeA = normalizePatternType(a);
            typeB = null;
            for (j = 0; j < formatB.length; j++) {
                b = formatB[j].charAt(0);
                typeB = normalizePatternType(b);
                if (typeA === typeB) {
                    break;
                } else {
                    typeB = null;
                }
            }
            if (typeB === null) {
                return -1;
            }
            lenA = formatA[i].length;
            lenB = formatB[j].length;
            distance = distance + Math.abs(lenA - lenB);
            if (a !== b) {
                distance += 1;
            }
            if (lenA < 3 && lenB >= 3 || lenA >= 3 && lenB < 3) {
                distance += 20;
            }
        }
        return distance;
    };
    var dateExpandPatternGetBestMatchPattern = function(cldr, askedSkeleton) {
        var availableFormats, pattern, ratedFormats, skeleton, path = "dates/calendars/gregorian/dateTimeFormats/availableFormats", augmentFormat = dateExpandPatternAugmentFormat, compareFormats = dateExpandPatternCompareFormats;
        pattern = cldr.main([ path, askedSkeleton ]);
        if (askedSkeleton && !pattern) {
            availableFormats = cldr.main([ path ]);
            ratedFormats = [];
            for (skeleton in availableFormats) {
                ratedFormats.push({
                    skeleton: skeleton,
                    pattern: availableFormats[skeleton],
                    rate: compareFormats(askedSkeleton, skeleton)
                });
            }
            ratedFormats = ratedFormats.filter(function(format) {
                return format.rate > -1;
            }).sort(function(formatA, formatB) {
                return formatA.rate - formatB.rate;
            });
            if (ratedFormats.length) {
                pattern = augmentFormat(askedSkeleton, ratedFormats[0].pattern);
            }
        }
        return pattern;
    };
    var dateExpandPattern = function(options, cldr) {
        var dateSkeleton, result, skeleton, timeSkeleton, type, getBestMatchPattern = dateExpandPatternGetBestMatchPattern;
        function combineDateTime(type, datePattern, timePattern) {
            return formatMessage(cldr.main([ "dates/calendars/gregorian/dateTimeFormats", type ]), [ timePattern, datePattern ]);
        }
        switch (true) {
          case "skeleton" in options:
            skeleton = options.skeleton;
            skeleton = skeleton.replace(/j/g, function() {
                return cldr.supplemental.timeData.preferred();
            });
            validateSkeleton(skeleton);
            result = getBestMatchPattern(cldr, skeleton);
            if (result) {
                break;
            }
            timeSkeleton = skeleton.split(/[^hHKkmsSAzZOvVXx]/).slice(-1)[0];
            dateSkeleton = skeleton.split(/[^GyYuUrQqMLlwWdDFgEec]/)[0];
            dateSkeleton = getBestMatchPattern(cldr, dateSkeleton);
            timeSkeleton = getBestMatchPattern(cldr, timeSkeleton);
            if (/(MMMM|LLLL).*[Ec]/.test(dateSkeleton)) {
                type = "full";
            } else if (/MMMM|LLLL/.test(dateSkeleton)) {
                type = "long";
            } else if (/MMM|LLL/.test(dateSkeleton)) {
                type = "medium";
            } else {
                type = "short";
            }
            if (dateSkeleton && timeSkeleton) {
                result = combineDateTime(type, dateSkeleton, timeSkeleton);
            } else {
                result = dateSkeleton || timeSkeleton;
            }
            break;

          case "date" in options:
          case "time" in options:
            result = cldr.main([ "dates/calendars/gregorian", "date" in options ? "dateFormats" : "timeFormats", options.date || options.time ]);
            break;

          case "datetime" in options:
            result = combineDateTime(options.datetime, cldr.main([ "dates/calendars/gregorian/dateFormats", options.datetime ]), cldr.main([ "dates/calendars/gregorian/timeFormats", options.datetime ]));
            break;

          case "raw" in options:
            result = options.raw;
            break;

          default:
            throw createErrorInvalidParameterValue({
                name: "options",
                value: options
            });
        }
        return result;
    };
    var dateWeekDays = [ "sun", "mon", "tue", "wed", "thu", "fri", "sat" ];
    var dateFirstDayOfWeek = function(cldr) {
        return dateWeekDays.indexOf(cldr.supplemental.weekData.firstDay());
    };
    var dateGetTimeZoneName = function(length, type, timeZone, cldr) {
        var metaZone, result;
        if (!timeZone) {
            return;
        }
        result = cldr.main([ "dates/timeZoneNames/zone", timeZone, length < 4 ? "short" : "long", type ]);
        if (result) {
            return result;
        }
        metaZone = cldr.supplemental([ "metaZones/metazoneInfo/timezone", timeZone, 0, "usesMetazone/_mzone" ]);
        return cldr.main([ "dates/timeZoneNames/metazone", metaZone, length < 4 ? "short" : "long", type ]);
    };
    var dateTimezoneHourFormatH = function(hourFormat) {
        return hourFormat.split(";").map(function(format) {
            return format.slice(0, format.indexOf("H") + 1);
        }).join(";");
    };
    var dateTimezoneHourFormatHm = function(hourFormat, hFormat) {
        return hourFormat.split(";").map(function(format) {
            var parts = format.split(/H+/);
            parts.splice(1, 0, hFormat);
            return parts.join("");
        }).join(";");
    };
    var runtimeCacheDataBind = function(key, data) {
        var fn = function() {
            return data;
        };
        fn.dataCacheKey = key;
        return fn;
    };
    var dateFormatProperties = function(pattern, cldr, timeZone) {
        var properties = {
            numberFormatters: {},
            pattern: pattern,
            timeSeparator: numberSymbol("timeSeparator", cldr)
        }, widths = [ "abbreviated", "wide", "narrow" ];
        function setNumberFormatterPattern(pad) {
            properties.numberFormatters[pad] = stringPad("", pad);
        }
        if (timeZone) {
            properties.timeZoneData = runtimeCacheDataBind("iana/" + timeZone, {
                offsets: cldr.get([ "globalize-iana/zoneData", timeZone, "offsets" ]),
                untils: cldr.get([ "globalize-iana/zoneData", timeZone, "untils" ]),
                isdsts: cldr.get([ "globalize-iana/zoneData", timeZone, "isdsts" ])
            });
        }
        pattern.replace(datePatternRe, function(current) {
            var aux, chr, daylightTzName, formatNumber, genericTzName, length, standardTzName;
            chr = current.charAt(0);
            length = current.length;
            if (chr === "j") {
                properties.preferredTime = chr = cldr.supplemental.timeData.preferred();
            }
            if (chr === "Z" && length === 4) {
                chr = "O";
                length = 4;
            }
            if (chr === "z") {
                standardTzName = dateGetTimeZoneName(length, "standard", timeZone, cldr);
                daylightTzName = dateGetTimeZoneName(length, "daylight", timeZone, cldr);
                if (standardTzName) {
                    properties.standardTzName = standardTzName;
                }
                if (daylightTzName) {
                    properties.daylightTzName = daylightTzName;
                }
                if (!standardTzName || !daylightTzName) {
                    chr = "O";
                    if (length < 4) {
                        length = 1;
                    }
                }
            }
            if (chr === "v") {
                genericTzName = dateGetTimeZoneName(length, "generic", timeZone, cldr);
                if (!genericTzName) {
                    chr = "V";
                    length = 4;
                }
            }
            switch (chr) {
              case "G":
                properties.eras = cldr.main([ "dates/calendars/gregorian/eras", length <= 3 ? "eraAbbr" : length === 4 ? "eraNames" : "eraNarrow" ]);
                break;

              case "y":
                formatNumber = true;
                break;

              case "Y":
                properties.firstDay = dateFirstDayOfWeek(cldr);
                properties.minDays = cldr.supplemental.weekData.minDays();
                formatNumber = true;
                break;

              case "u":
              case "U":
                throw createErrorUnsupportedFeature({
                    feature: "year pattern `" + chr + "`"
                });

              case "Q":
              case "q":
                if (length > 2) {
                    if (!properties.quarters) {
                        properties.quarters = {};
                    }
                    if (!properties.quarters[chr]) {
                        properties.quarters[chr] = {};
                    }
                    properties.quarters[chr][length] = cldr.main([ "dates/calendars/gregorian/quarters", chr === "Q" ? "format" : "stand-alone", widths[length - 3] ]);
                } else {
                    formatNumber = true;
                }
                break;

              case "M":
              case "L":
                if (length > 2) {
                    if (!properties.months) {
                        properties.months = {};
                    }
                    if (!properties.months[chr]) {
                        properties.months[chr] = {};
                    }
                    properties.months[chr][length] = cldr.main([ "dates/calendars/gregorian/months", chr === "M" ? "format" : "stand-alone", widths[length - 3] ]);
                } else {
                    formatNumber = true;
                }
                break;

              case "w":
              case "W":
                properties.firstDay = dateFirstDayOfWeek(cldr);
                properties.minDays = cldr.supplemental.weekData.minDays();
                formatNumber = true;
                break;

              case "d":
              case "D":
              case "F":
                formatNumber = true;
                break;

              case "g":
                throw createErrorUnsupportedFeature({
                    feature: "Julian day pattern `g`"
                });

              case "e":
              case "c":
                if (length <= 2) {
                    properties.firstDay = dateFirstDayOfWeek(cldr);
                    formatNumber = true;
                    break;
                }

              case "E":
                if (!properties.days) {
                    properties.days = {};
                }
                if (!properties.days[chr]) {
                    properties.days[chr] = {};
                }
                if (length === 6) {
                    properties.days[chr][length] = cldr.main([ "dates/calendars/gregorian/days", chr === "c" ? "stand-alone" : "format", "short" ]) || cldr.main([ "dates/calendars/gregorian/days", chr === "c" ? "stand-alone" : "format", "abbreviated" ]);
                } else {
                    properties.days[chr][length] = cldr.main([ "dates/calendars/gregorian/days", chr === "c" ? "stand-alone" : "format", widths[length < 3 ? 0 : length - 3] ]);
                }
                break;

              case "a":
                properties.dayPeriods = {
                    am: cldr.main("dates/calendars/gregorian/dayPeriods/format/wide/am"),
                    pm: cldr.main("dates/calendars/gregorian/dayPeriods/format/wide/pm")
                };
                break;

              case "h":
              case "H":
              case "K":
              case "k":
              case "m":
              case "s":
              case "S":
              case "A":
                formatNumber = true;
                break;

              case "v":
                if (length !== 1 && length !== 4) {
                    throw createErrorUnsupportedFeature({
                        feature: "timezone pattern `" + pattern + "`"
                    });
                }
                properties.genericTzName = genericTzName;
                break;

              case "V":
                if (length === 1) {
                    throw createErrorUnsupportedFeature({
                        feature: "timezone pattern `" + pattern + "`"
                    });
                }
                if (timeZone) {
                    if (length === 2) {
                        properties.timeZoneName = timeZone;
                        break;
                    }
                    var timeZoneName, exemplarCity = cldr.main([ "dates/timeZoneNames/zone", timeZone, "exemplarCity" ]);
                    if (length === 3) {
                        if (!exemplarCity) {
                            exemplarCity = cldr.main([ "dates/timeZoneNames/zone/Etc/Unknown/exemplarCity" ]);
                        }
                        timeZoneName = exemplarCity;
                    }
                    if (exemplarCity && length === 4) {
                        timeZoneName = formatMessage(cldr.main("dates/timeZoneNames/regionFormat"), [ exemplarCity ]);
                    }
                    if (timeZoneName) {
                        properties.timeZoneName = timeZoneName;
                        break;
                    }
                }
                if (current === "v") {
                    length = 1;
                }

              case "O":
                properties.gmtFormat = cldr.main("dates/timeZoneNames/gmtFormat");
                properties.gmtZeroFormat = cldr.main("dates/timeZoneNames/gmtZeroFormat");
                aux = cldr.main("dates/timeZoneNames/hourFormat");
                properties.hourFormat = length < 4 ? [ dateTimezoneHourFormatH(aux), dateTimezoneHourFormatHm(aux, "H") ] : dateTimezoneHourFormatHm(aux, "HH");

              case "Z":
              case "X":
              case "x":
                setNumberFormatterPattern(1);
                setNumberFormatterPattern(2);
                break;
            }
            if (formatNumber) {
                setNumberFormatterPattern(length);
            }
        });
        return properties;
    };
    var dateFormatterFn = function(dateToPartsFormatter) {
        return function dateFormatter(value) {
            return dateToPartsFormatter(value).map(function(part) {
                return part.value;
            }).join("");
        };
    };
    var dateParseProperties = function(cldr, timeZone) {
        var properties = {
            preferredTimeData: cldr.supplemental.timeData.preferred()
        };
        if (timeZone) {
            properties.timeZoneData = runtimeCacheDataBind("iana/" + timeZone, {
                offsets: cldr.get([ "globalize-iana/zoneData", timeZone, "offsets" ]),
                untils: cldr.get([ "globalize-iana/zoneData", timeZone, "untils" ]),
                isdsts: cldr.get([ "globalize-iana/zoneData", timeZone, "isdsts" ])
            });
        }
        return properties;
    };
    var ZonedDateTime = function() {
        function definePrivateProperty(object, property, value) {
            Object.defineProperty(object, property, {
                value: value
            });
        }
        function getUntilsIndex(original, untils) {
            var index = 0;
            var originalTime = original.getTime();
            while (index < untils.length - 1 && originalTime >= untils[index]) {
                index++;
            }
            return index;
        }
        function setWrap(fn) {
            var offset1 = this.getTimezoneOffset();
            var ret = fn();
            this.original.setTime(new Date(this.getTime()));
            var offset2 = this.getTimezoneOffset();
            if (offset2 - offset1) {
                this.original.setMinutes(this.original.getMinutes() + offset2 - offset1);
            }
            return ret;
        }
        var ZonedDateTime = function(date, timeZoneData) {
            definePrivateProperty(this, "original", new Date(date.getTime()));
            definePrivateProperty(this, "local", new Date(date.getTime()));
            definePrivateProperty(this, "timeZoneData", timeZoneData);
            definePrivateProperty(this, "setWrap", setWrap);
            if (!(timeZoneData.untils && timeZoneData.offsets && timeZoneData.isdsts)) {
                throw new Error("Invalid IANA data");
            }
            this.setTime(this.local.getTime() - this.getTimezoneOffset() * 60 * 1e3);
        };
        ZonedDateTime.prototype.clone = function() {
            return new ZonedDateTime(this.original, this.timeZoneData);
        };
        [ "getFullYear", "getMonth", "getDate", "getDay", "getHours", "getMinutes", "getSeconds", "getMilliseconds" ].forEach(function(method) {
            var utcMethod = "getUTC" + method.substr(3);
            ZonedDateTime.prototype[method] = function() {
                return this.local[utcMethod]();
            };
        });
        ZonedDateTime.prototype.valueOf = ZonedDateTime.prototype.getTime = function() {
            return this.local.getTime() + this.getTimezoneOffset() * 60 * 1e3;
        };
        ZonedDateTime.prototype.getTimezoneOffset = function() {
            var index = getUntilsIndex(this.original, this.timeZoneData.untils);
            return this.timeZoneData.offsets[index];
        };
        [ "setFullYear", "setMonth", "setDate", "setHours", "setMinutes", "setSeconds", "setMilliseconds" ].forEach(function(method) {
            var utcMethod = "setUTC" + method.substr(3);
            ZonedDateTime.prototype[method] = function(value) {
                var local = this.local;
                return this.setWrap(function() {
                    return local[utcMethod](value);
                });
            };
        });
        ZonedDateTime.prototype.setTime = function(time) {
            return this.local.setTime(time);
        };
        ZonedDateTime.prototype.isDST = function() {
            var index = getUntilsIndex(this.original, this.timeZoneData.untils);
            return Boolean(this.timeZoneData.isdsts[index]);
        };
        ZonedDateTime.prototype.inspect = function() {
            var index = getUntilsIndex(this.original, this.timeZoneData.untils);
            var abbrs = this.timeZoneData.abbrs;
            return this.local.toISOString().replace(/Z$/, "") + " " + (abbrs && abbrs[index] + " " || this.getTimezoneOffset() * -1 + " ") + (this.isDST() ? "(daylight savings)" : "");
        };
        ZonedDateTime.prototype.toDate = function() {
            return new Date(this.getTime());
        };
        [ "toISOString", "toJSON", "toUTCString" ].forEach(function(method) {
            ZonedDateTime.prototype[method] = function() {
                return this.toDate()[method]();
            };
        });
        return ZonedDateTime;
    }();
    var dateIsLeapYear = function(year) {
        return new Date(year, 1, 29).getMonth() === 1;
    };
    var dateLastDayOfMonth = function(date) {
        return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
    };
    var dateStartOf = function(date, unit) {
        date = date instanceof ZonedDateTime ? date.clone() : new Date(date.getTime());
        switch (unit) {
          case "year":
            date.setMonth(0);

          case "month":
            date.setDate(1);

          case "day":
            date.setHours(0);

          case "hour":
            date.setMinutes(0);

          case "minute":
            date.setSeconds(0);

          case "second":
            date.setMilliseconds(0);
        }
        return date;
    };
    var dateSetDate = function(date, day) {
        var lastDay = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
        date.setDate(day < 1 ? 1 : day < lastDay ? day : lastDay);
    };
    var dateSetMonth = function(date, month) {
        var originalDate = date.getDate();
        date.setDate(1);
        date.setMonth(month);
        dateSetDate(date, originalDate);
    };
    var outOfRange = function(value, low, high) {
        return value < low || value > high;
    };
    var dateParse = function(value, tokens, properties) {
        var amPm, day, daysOfYear, month, era, hour, hour12, timezoneOffset, valid, YEAR = 0, MONTH = 1, DAY = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECONDS = 6, date = new Date(), truncateAt = [], units = [ "year", "month", "day", "hour", "minute", "second", "milliseconds" ];
        if (properties.timeZoneData) {
            date = new ZonedDateTime(date, properties.timeZoneData());
        }
        if (!tokens.length) {
            return null;
        }
        valid = tokens.every(function(token) {
            var century, chr, value, length;
            if (token.type === "literal") {
                return true;
            }
            chr = token.type.charAt(0);
            length = token.type.length;
            if (chr === "j") {
                chr = properties.preferredTimeData;
            }
            switch (chr) {
              case "G":
                truncateAt.push(YEAR);
                era = +token.value;
                break;

              case "y":
                value = token.value;
                if (length === 2) {
                    if (outOfRange(value, 0, 99)) {
                        return false;
                    }
                    century = Math.floor(date.getFullYear() / 100) * 100;
                    value += century;
                    if (value > date.getFullYear() + 20) {
                        value -= 100;
                    }
                }
                date.setFullYear(value);
                truncateAt.push(YEAR);
                break;

              case "Y":
                throw createErrorUnsupportedFeature({
                    feature: "year pattern `" + chr + "`"
                });

              case "Q":
              case "q":
                break;

              case "M":
              case "L":
                if (length <= 2) {
                    value = token.value;
                } else {
                    value = +token.value;
                }
                if (outOfRange(value, 1, 12)) {
                    return false;
                }
                month = value;
                truncateAt.push(MONTH);
                break;

              case "w":
              case "W":
                break;

              case "d":
                day = token.value;
                truncateAt.push(DAY);
                break;

              case "D":
                daysOfYear = token.value;
                truncateAt.push(DAY);
                break;

              case "F":
                break;

              case "e":
              case "c":
              case "E":
                break;

              case "a":
                amPm = token.value;
                break;

              case "h":
                value = token.value;
                if (outOfRange(value, 1, 12)) {
                    return false;
                }
                hour = hour12 = true;
                date.setHours(value === 12 ? 0 : value);
                truncateAt.push(HOUR);
                break;

              case "K":
                value = token.value;
                if (outOfRange(value, 0, 11)) {
                    return false;
                }
                hour = hour12 = true;
                date.setHours(value);
                truncateAt.push(HOUR);
                break;

              case "k":
                value = token.value;
                if (outOfRange(value, 1, 24)) {
                    return false;
                }
                hour = true;
                date.setHours(value === 24 ? 0 : value);
                truncateAt.push(HOUR);
                break;

              case "H":
                value = token.value;
                if (outOfRange(value, 0, 23)) {
                    return false;
                }
                hour = true;
                date.setHours(value);
                truncateAt.push(HOUR);
                break;

              case "m":
                value = token.value;
                if (outOfRange(value, 0, 59)) {
                    return false;
                }
                date.setMinutes(value);
                truncateAt.push(MINUTE);
                break;

              case "s":
                value = token.value;
                if (outOfRange(value, 0, 59)) {
                    return false;
                }
                date.setSeconds(value);
                truncateAt.push(SECOND);
                break;

              case "A":
                date.setHours(0);
                date.setMinutes(0);
                date.setSeconds(0);

              case "S":
                value = Math.round(token.value * Math.pow(10, 3 - length));
                date.setMilliseconds(value);
                truncateAt.push(MILLISECONDS);
                break;

              case "z":
              case "Z":
              case "O":
              case "v":
              case "V":
              case "X":
              case "x":
                if (typeof token.value === "number") {
                    timezoneOffset = token.value;
                }
                break;
            }
            return true;
        });
        if (!valid) {
            return null;
        }
        if (hour && !(!amPm ^ hour12)) {
            return null;
        }
        if (era === 0) {
            date.setFullYear(date.getFullYear() * -1 + 1);
        }
        if (month !== undefined) {
            dateSetMonth(date, month - 1);
        }
        if (day !== undefined) {
            if (outOfRange(day, 1, dateLastDayOfMonth(date))) {
                return null;
            }
            date.setDate(day);
        } else if (daysOfYear !== undefined) {
            if (outOfRange(daysOfYear, 1, dateIsLeapYear(date.getFullYear()) ? 366 : 365)) {
                return null;
            }
            date.setMonth(0);
            date.setDate(daysOfYear);
        }
        if (hour12 && amPm === "pm") {
            date.setHours(date.getHours() + 12);
        }
        if (timezoneOffset !== undefined) {
            date.setMinutes(date.getMinutes() + timezoneOffset - date.getTimezoneOffset());
        }
        truncateAt = Math.max.apply(null, truncateAt);
        date = dateStartOf(date, units[truncateAt]);
        if (date instanceof ZonedDateTime) {
            date = date.toDate();
        }
        return date;
    };
    var dateTokenizer = function(value, numberParser, properties) {
        var digitsRe, valid, tokens = [], widths = [ "abbreviated", "wide", "narrow" ];
        digitsRe = properties.digitsRe;
        value = looseMatching(value);
        valid = properties.pattern.match(datePatternRe).every(function(current) {
            var aux, chr, length, numeric, tokenRe, token = {};
            function hourFormatParse(tokenRe, numberParser) {
                var aux, isPositive, match = value.match(tokenRe);
                numberParser = numberParser || function(value) {
                    return +value;
                };
                if (!match) {
                    return false;
                }
                isPositive = match[1];
                if (match.length < 6) {
                    aux = isPositive ? 1 : 3;
                    token.value = numberParser(match[aux]) * 60;
                } else if (match.length < 10) {
                    aux = isPositive ? [ 1, 3 ] : [ 5, 7 ];
                    token.value = numberParser(match[aux[0]]) * 60 + numberParser(match[aux[1]]);
                } else {
                    aux = isPositive ? [ 1, 3, 5 ] : [ 7, 9, 11 ];
                    token.value = numberParser(match[aux[0]]) * 60 + numberParser(match[aux[1]]) + numberParser(match[aux[2]]) / 60;
                }
                if (isPositive) {
                    token.value *= -1;
                }
                return true;
            }
            function oneDigitIfLengthOne() {
                if (length === 1) {
                    numeric = true;
                    return tokenRe = digitsRe;
                }
            }
            function oneOrTwoDigitsIfLengthOne() {
                if (length === 1) {
                    numeric = true;
                    return tokenRe = new RegExp("^(" + digitsRe.source + "){1,2}");
                }
            }
            function oneOrTwoDigitsIfLengthOneOrTwo() {
                if (length === 1 || length === 2) {
                    numeric = true;
                    return tokenRe = new RegExp("^(" + digitsRe.source + "){1,2}");
                }
            }
            function twoDigitsIfLengthTwo() {
                if (length === 2) {
                    numeric = true;
                    return tokenRe = new RegExp("^(" + digitsRe.source + "){2}");
                }
            }
            function lookup(path) {
                var array = properties[path.join("/")];
                if (!array) {
                    return null;
                }
                array.some(function(item) {
                    var valueRe = item[1];
                    if (valueRe.test(value)) {
                        token.value = item[0];
                        tokenRe = item[1];
                        return true;
                    }
                });
                return null;
            }
            token.type = current;
            chr = current.charAt(0);
            length = current.length;
            if (chr === "Z") {
                if (length < 4) {
                    chr = "x";
                    length = 4;
                } else if (length < 5) {
                    chr = "O";
                    length = 4;
                } else {
                    chr = "X";
                    length = 5;
                }
            }
            if (chr === "z") {
                if (properties.standardOrDaylightTzName) {
                    token.value = null;
                    tokenRe = properties.standardOrDaylightTzName;
                }
            }
            if (chr === "v") {
                if (properties.genericTzName) {
                    token.value = null;
                    tokenRe = properties.genericTzName;
                } else {
                    chr = "V";
                    length = 4;
                }
            }
            if (chr === "V" && properties.timeZoneName) {
                token.value = length === 2 ? properties.timeZoneName : null;
                tokenRe = properties.timeZoneNameRe;
            }
            switch (chr) {
              case "G":
                lookup([ "gregorian/eras", length <= 3 ? "eraAbbr" : length === 4 ? "eraNames" : "eraNarrow" ]);
                break;

              case "y":
              case "Y":
                numeric = true;
                if (length === 1) {
                    tokenRe = new RegExp("^(" + digitsRe.source + ")+");
                } else if (length === 2) {
                    tokenRe = new RegExp("^(" + digitsRe.source + "){1,2}");
                } else {
                    tokenRe = new RegExp("^(" + digitsRe.source + "){" + length + ",}");
                }
                break;

              case "Q":
              case "q":
                oneDigitIfLengthOne() || twoDigitsIfLengthTwo() || lookup([ "gregorian/quarters", chr === "Q" ? "format" : "stand-alone", widths[length - 3] ]);
                break;

              case "M":
              case "L":
                oneOrTwoDigitsIfLengthOneOrTwo() || lookup([ "gregorian/months", chr === "M" ? "format" : "stand-alone", widths[length - 3] ]);
                break;

              case "D":
                if (length <= 3) {
                    numeric = true;
                    tokenRe = new RegExp("^(" + digitsRe.source + "){" + length + ",3}");
                }
                break;

              case "W":
              case "F":
                oneDigitIfLengthOne();
                break;

              case "e":
              case "c":
                if (length <= 2) {
                    oneDigitIfLengthOne() || twoDigitsIfLengthTwo();
                    break;
                }

              case "E":
                if (length === 6) {
                    lookup([ "gregorian/days", [ chr === "c" ? "stand-alone" : "format" ], "short" ]) || lookup([ "gregorian/days", [ chr === "c" ? "stand-alone" : "format" ], "abbreviated" ]);
                } else {
                    lookup([ "gregorian/days", [ chr === "c" ? "stand-alone" : "format" ], widths[length < 3 ? 0 : length - 3] ]);
                }
                break;

              case "a":
                lookup([ "gregorian/dayPeriods/format/wide" ]);
                break;

              case "w":
                oneOrTwoDigitsIfLengthOne() || twoDigitsIfLengthTwo();
                break;

              case "d":
              case "h":
              case "H":
              case "K":
              case "k":
              case "j":
              case "m":
              case "s":
                oneOrTwoDigitsIfLengthOneOrTwo();
                break;

              case "S":
                numeric = true;
                tokenRe = new RegExp("^(" + digitsRe.source + "){" + length + "}");
                break;

              case "A":
                numeric = true;
                tokenRe = new RegExp("^(" + digitsRe.source + "){" + (length + 5) + "}");
                break;

              case "v":
              case "V":
              case "z":
                if (tokenRe && tokenRe.test(value)) {
                    break;
                }
                if (chr === "V" && length === 2) {
                    break;
                }

              case "O":
                if (value === properties["timeZoneNames/gmtZeroFormat"]) {
                    token.value = 0;
                    tokenRe = properties["timeZoneNames/gmtZeroFormatRe"];
                } else {
                    aux = properties["timeZoneNames/hourFormat"].some(function(hourFormatRe) {
                        if (hourFormatParse(hourFormatRe, numberParser)) {
                            tokenRe = hourFormatRe;
                            return true;
                        }
                    });
                    if (!aux) {
                        return null;
                    }
                }
                break;

              case "X":
                if (value === "Z") {
                    token.value = 0;
                    tokenRe = /^Z/;
                    break;
                }

              case "x":
                aux = properties.x.some(function(hourFormatRe) {
                    if (hourFormatParse(hourFormatRe)) {
                        tokenRe = hourFormatRe;
                        return true;
                    }
                });
                if (!aux) {
                    return null;
                }
                break;

              case "'":
                token.type = "literal";
                tokenRe = new RegExp("^" + regexpEscape(removeLiteralQuotes(current)));
                break;

              default:
                token.type = "literal";
                tokenRe = new RegExp("^" + regexpEscape(current));
            }
            if (!tokenRe) {
                return false;
            }
            value = value.replace(tokenRe, function(lexeme) {
                token.lexeme = lexeme;
                if (numeric) {
                    token.value = numberParser(lexeme);
                }
                return "";
            });
            if (!token.lexeme) {
                return false;
            }
            if (numeric && isNaN(token.value)) {
                return false;
            }
            tokens.push(token);
            return true;
        });
        if (value !== "") {
            valid = false;
        }
        return valid ? tokens : [];
    };
    var dateParserFn = function(numberParser, parseProperties, tokenizerProperties) {
        return function dateParser(value) {
            var tokens;
            validateParameterPresence(value, "value");
            validateParameterTypeString(value, "value");
            tokens = dateTokenizer(value, numberParser, tokenizerProperties);
            return dateParse(value, tokens, parseProperties) || null;
        };
    };
    var objectFilter = function(object, testRe) {
        var key, copy = {};
        for (key in object) {
            if (testRe.test(key)) {
                copy[key] = object[key];
            }
        }
        return copy;
    };
    var dateTokenizerProperties = function(pattern, cldr, timeZone) {
        var digitsReSource, properties = {
            pattern: looseMatching(pattern)
        }, timeSeparator = numberSymbol("timeSeparator", cldr), widths = [ "abbreviated", "wide", "narrow" ];
        digitsReSource = numberNumberingSystemDigitsMap(cldr);
        digitsReSource = digitsReSource ? "[" + digitsReSource + "]" : "\\d";
        properties.digitsRe = new RegExp(digitsReSource);
        function hourFormatRe(hourFormat, gmtFormat, digitsReSource, timeSeparator) {
            var re;
            if (!digitsReSource) {
                digitsReSource = "\\d";
            }
            if (!gmtFormat) {
                gmtFormat = "{0}";
            }
            re = hourFormat.replace("+", "\\+").replace(/HH|mm|ss/g, "((" + digitsReSource + "){2})").replace(/H|m/g, "((" + digitsReSource + "){1,2})");
            if (timeSeparator) {
                re = re.replace(/:/g, timeSeparator);
            }
            re = re.split(";").map(function(part) {
                return gmtFormat.replace("{0}", part);
            }).join("|");
            return new RegExp("^" + re);
        }
        function populateProperties(path, value) {
            var skipRe = /(timeZoneNames\/zone|supplemental\/metaZones|timeZoneNames\/metazone|timeZoneNames\/regionFormat|timeZoneNames\/gmtFormat)/;
            if (skipRe.test(path)) {
                return;
            }
            if (!value) {
                return;
            }
            path = path.replace(/^.*\/dates\//, "").replace(/calendars\//, "");
            if (path === "gregorian/dayPeriods/format/wide") {
                value = objectFilter(value, /^am|^pm/);
            }
            if (isPlainObject(value)) {
                value = Object.keys(value).map(function(key) {
                    return [ key, new RegExp("^" + regexpEscape(looseMatching(value[key]))) ];
                }).sort(function(a, b) {
                    return b[1].source.length - a[1].source.length;
                });
            } else {
                value = looseMatching(value);
            }
            properties[path] = value;
        }
        function regexpSourceSomeTerm(terms) {
            return "(" + terms.filter(function(item) {
                return item;
            }).reduce(function(memo, item) {
                return memo + "|" + item;
            }) + ")";
        }
        cldr.on("get", populateProperties);
        pattern.match(datePatternRe).forEach(function(current) {
            var aux, chr, daylightTzName, gmtFormat, length, standardTzName;
            chr = current.charAt(0);
            length = current.length;
            if (chr === "Z") {
                if (length < 5) {
                    chr = "O";
                    length = 4;
                } else {
                    chr = "X";
                    length = 5;
                }
            }
            if (chr === "z") {
                standardTzName = dateGetTimeZoneName(length, "standard", timeZone, cldr);
                daylightTzName = dateGetTimeZoneName(length, "daylight", timeZone, cldr);
                if (standardTzName) {
                    standardTzName = regexpEscape(looseMatching(standardTzName));
                }
                if (daylightTzName) {
                    daylightTzName = regexpEscape(looseMatching(daylightTzName));
                }
                if (standardTzName || daylightTzName) {
                    properties.standardOrDaylightTzName = new RegExp("^" + regexpSourceSomeTerm([ standardTzName, daylightTzName ]));
                }
                if (!standardTzName || !daylightTzName) {
                    chr = "O";
                    if (length < 4) {
                        length = 1;
                    }
                }
            }
            if (chr === "v") {
                if (length !== 1 && length !== 4) {
                    throw createErrorUnsupportedFeature({
                        feature: "timezone pattern `" + pattern + "`"
                    });
                }
                var genericTzName = dateGetTimeZoneName(length, "generic", timeZone, cldr);
                if (genericTzName) {
                    properties.genericTzName = new RegExp("^" + regexpEscape(looseMatching(genericTzName)));
                    chr = "O";
                } else {
                    chr = "V";
                    length = 4;
                }
            }
            switch (chr) {
              case "G":
                cldr.main([ "dates/calendars/gregorian/eras", length <= 3 ? "eraAbbr" : length === 4 ? "eraNames" : "eraNarrow" ]);
                break;

              case "u":
              case "U":
                throw createErrorUnsupportedFeature({
                    feature: "year pattern `" + chr + "`"
                });

              case "Q":
              case "q":
                if (length > 2) {
                    cldr.main([ "dates/calendars/gregorian/quarters", chr === "Q" ? "format" : "stand-alone", widths[length - 3] ]);
                }
                break;

              case "M":
              case "L":
                if (length > 2) {
                    cldr.main([ "dates/calendars/gregorian/months", chr === "M" ? "format" : "stand-alone", widths[length - 3] ]);
                }
                break;

              case "g":
                throw createErrorUnsupportedFeature({
                    feature: "Julian day pattern `g`"
                });

              case "e":
              case "c":
                if (length <= 2) {
                    break;
                }

              case "E":
                if (length === 6) {
                    cldr.main([ "dates/calendars/gregorian/days", [ chr === "c" ? "stand-alone" : "format" ], "short" ]) || cldr.main([ "dates/calendars/gregorian/days", [ chr === "c" ? "stand-alone" : "format" ], "abbreviated" ]);
                } else {
                    cldr.main([ "dates/calendars/gregorian/days", [ chr === "c" ? "stand-alone" : "format" ], widths[length < 3 ? 0 : length - 3] ]);
                }
                break;

              case "a":
                cldr.main("dates/calendars/gregorian/dayPeriods/format/wide");
                break;

              case "V":
                if (length === 1) {
                    throw createErrorUnsupportedFeature({
                        feature: "timezone pattern `" + pattern + "`"
                    });
                }
                if (timeZone) {
                    if (length === 2) {
                        properties.timeZoneName = timeZone;
                        properties.timeZoneNameRe = new RegExp("^" + regexpEscape(timeZone));
                        break;
                    }
                    var timeZoneName, exemplarCity = cldr.main([ "dates/timeZoneNames/zone", timeZone, "exemplarCity" ]);
                    if (length === 3) {
                        if (!exemplarCity) {
                            exemplarCity = cldr.main([ "dates/timeZoneNames/zone/Etc/Unknown/exemplarCity" ]);
                        }
                        timeZoneName = exemplarCity;
                    }
                    if (exemplarCity && length === 4) {
                        timeZoneName = formatMessage(cldr.main("dates/timeZoneNames/regionFormat"), [ exemplarCity ]);
                    }
                    if (timeZoneName) {
                        timeZoneName = looseMatching(timeZoneName);
                        properties.timeZoneName = timeZoneName;
                        properties.timeZoneNameRe = new RegExp("^" + regexpEscape(timeZoneName));
                    }
                }
                if (current === "v") {
                    length = 1;
                }

              case "z":
              case "O":
                gmtFormat = cldr.main("dates/timeZoneNames/gmtFormat");
                cldr.main("dates/timeZoneNames/gmtZeroFormat");
                cldr.main("dates/timeZoneNames/hourFormat");
                properties["timeZoneNames/gmtZeroFormatRe"] = new RegExp("^" + regexpEscape(properties["timeZoneNames/gmtZeroFormat"]));
                aux = properties["timeZoneNames/hourFormat"];
                properties["timeZoneNames/hourFormat"] = (length < 4 ? [ dateTimezoneHourFormatHm(aux, "H"), dateTimezoneHourFormatH(aux) ] : [ dateTimezoneHourFormatHm(aux, "HH") ]).map(function(hourFormat) {
                    return hourFormatRe(hourFormat, gmtFormat, digitsReSource, timeSeparator);
                });

              case "X":
              case "x":
                properties.x = [ [ "+HHmm;-HHmm", "+HH;-HH" ], [ "+HHmm;-HHmm" ], [ "+HH:mm;-HH:mm" ], [ "+HHmmss;-HHmmss", "+HHmm;-HHmm" ], [ "+HH:mm:ss;-HH:mm:ss", "+HH:mm;-HH:mm" ] ][length - 1].map(function(hourFormat) {
                    return hourFormatRe(hourFormat);
                });
            }
        });
        cldr.off("get", populateProperties);
        return properties;
    };
    var dateDayOfWeek = function(date, firstDay) {
        return (date.getDay() - firstDay + 7) % 7;
    };
    var dateDistanceInDays = function(from, to) {
        var inDays = 864e5;
        return (to.getTime() - from.getTime()) / inDays;
    };
    var dateDayOfYear = function(date) {
        return Math.floor(dateDistanceInDays(dateStartOf(date, "year"), date));
    };
    var dateFieldsMap = objectInvert({
        era: "G",
        year: "yY",
        quarter: "qQ",
        month: "ML",
        week: "wW",
        day: "dDF",
        weekday: "ecE",
        dayperiod: "a",
        hour: "hHkK",
        minute: "m",
        second: "sSA",
        zone: "zvVOxX"
    }, function(object, key, value) {
        value.split("").forEach(function(symbol) {
            object[symbol] = key;
        });
        return object;
    });
    var dateMillisecondsInDay = function(date) {
        return date - dateStartOf(date, "day");
    };
    var dateTimezoneHourFormat = function(date, format, timeSeparator, formatNumber) {
        var absOffset, offset = date.getTimezoneOffset();
        absOffset = Math.abs(offset);
        formatNumber = formatNumber || {
            1: function(value) {
                return stringPad(value, 1);
            },
            2: function(value) {
                return stringPad(value, 2);
            }
        };
        return format.split(";")[offset > 0 ? 1 : 0].replace(":", timeSeparator).replace(/HH?/, function(match) {
            return formatNumber[match.length](Math.floor(absOffset / 60));
        }).replace(/mm/, function() {
            return formatNumber[2](Math.floor(absOffset % 60));
        }).replace(/ss/, function() {
            return formatNumber[2](Math.floor(absOffset % 1 * 60));
        });
    };
    var dateFormat = function(date, numberFormatters, properties) {
        var parts = [];
        var timeSeparator = properties.timeSeparator;
        if (properties.timeZoneData) {
            date = new ZonedDateTime(date, properties.timeZoneData());
        }
        properties.pattern.replace(datePatternRe, function(current) {
            var aux, dateField, type, value, chr = current.charAt(0), length = current.length;
            if (chr === "j") {
                chr = properties.preferredTime;
            }
            if (chr === "Z") {
                if (length < 4) {
                    chr = "x";
                    length = 4;
                } else if (length < 5) {
                    chr = "O";
                    length = 4;
                } else {
                    chr = "X";
                    length = 5;
                }
            }
            if (chr === "z") {
                if (date.isDST) {
                    value = date.isDST() ? properties.daylightTzName : properties.standardTzName;
                }
                if (!value) {
                    chr = "O";
                    if (length < 4) {
                        length = 1;
                    }
                }
            }
            switch (chr) {
              case "G":
                value = properties.eras[date.getFullYear() < 0 ? 0 : 1];
                break;

              case "y":
                value = date.getFullYear();
                if (length === 2) {
                    value = String(value);
                    value = +value.substr(value.length - 2);
                }
                break;

              case "Y":
                value = new Date(date.getTime());
                value.setDate(value.getDate() + 7 - dateDayOfWeek(date, properties.firstDay) - properties.firstDay - properties.minDays);
                value = value.getFullYear();
                if (length === 2) {
                    value = String(value);
                    value = +value.substr(value.length - 2);
                }
                break;

              case "Q":
              case "q":
                value = Math.ceil((date.getMonth() + 1) / 3);
                if (length > 2) {
                    value = properties.quarters[chr][length][value];
                }
                break;

              case "M":
              case "L":
                value = date.getMonth() + 1;
                if (length > 2) {
                    value = properties.months[chr][length][value];
                }
                break;

              case "w":
                value = dateDayOfWeek(dateStartOf(date, "year"), properties.firstDay);
                value = Math.ceil((dateDayOfYear(date) + value) / 7) - (7 - value >= properties.minDays ? 0 : 1);
                break;

              case "W":
                value = dateDayOfWeek(dateStartOf(date, "month"), properties.firstDay);
                value = Math.ceil((date.getDate() + value) / 7) - (7 - value >= properties.minDays ? 0 : 1);
                break;

              case "d":
                value = date.getDate();
                break;

              case "D":
                value = dateDayOfYear(date) + 1;
                break;

              case "F":
                value = Math.floor(date.getDate() / 7) + 1;
                break;

              case "e":
              case "c":
                if (length <= 2) {
                    value = dateDayOfWeek(date, properties.firstDay) + 1;
                    break;
                }

              case "E":
                value = dateWeekDays[date.getDay()];
                value = properties.days[chr][length][value];
                break;

              case "a":
                value = properties.dayPeriods[date.getHours() < 12 ? "am" : "pm"];
                break;

              case "h":
                value = date.getHours() % 12 || 12;
                break;

              case "H":
                value = date.getHours();
                break;

              case "K":
                value = date.getHours() % 12;
                break;

              case "k":
                value = date.getHours() || 24;
                break;

              case "m":
                value = date.getMinutes();
                break;

              case "s":
                value = date.getSeconds();
                break;

              case "S":
                value = Math.round(date.getMilliseconds() * Math.pow(10, length - 3));
                break;

              case "A":
                value = Math.round(dateMillisecondsInDay(date) * Math.pow(10, length - 3));
                break;

              case "z":
                break;

              case "v":
                if (properties.genericTzName) {
                    value = properties.genericTzName;
                    break;
                }

              case "V":
                if (properties.timeZoneName) {
                    value = properties.timeZoneName;
                    break;
                }
                if (current === "v") {
                    length = 1;
                }

              case "O":
                if (date.getTimezoneOffset() === 0) {
                    value = properties.gmtZeroFormat;
                } else {
                    if (length < 4) {
                        aux = date.getTimezoneOffset();
                        aux = properties.hourFormat[aux % 60 - aux % 1 === 0 ? 0 : 1];
                    } else {
                        aux = properties.hourFormat;
                    }
                    value = dateTimezoneHourFormat(date, aux, timeSeparator, numberFormatters);
                    value = properties.gmtFormat.replace(/\{0\}/, value);
                }
                break;

              case "X":
                if (date.getTimezoneOffset() === 0) {
                    value = "Z";
                    break;
                }

              case "x":
                aux = date.getTimezoneOffset();
                if (length === 1 && aux % 60 - aux % 1 !== 0) {
                    length += 1;
                }
                if ((length === 4 || length === 5) && aux % 1 === 0) {
                    length -= 2;
                }
                value = [ "+HH;-HH", "+HHmm;-HHmm", "+HH:mm;-HH:mm", "+HHmmss;-HHmmss", "+HH:mm:ss;-HH:mm:ss" ][length - 1];
                value = dateTimezoneHourFormat(date, value, ":");
                break;

              case ":":
                value = timeSeparator;
                break;

              case "'":
                value = removeLiteralQuotes(current);
                break;

              default:
                value = current;
            }
            if (typeof value === "number") {
                value = numberFormatters[length](value);
            }
            dateField = dateFieldsMap[chr];
            type = dateField ? dateField : "literal";
            if (type === "literal" && parts.length && parts[parts.length - 1].type === "literal") {
                parts[parts.length - 1].value += value;
                return;
            }
            parts.push({
                type: type,
                value: value
            });
        });
        return parts;
    };
    var dateToPartsFormatterFn = function(numberFormatters, properties) {
        return function dateToPartsFormatter(value) {
            validateParameterPresence(value, "value");
            validateParameterTypeDate(value, "value");
            return dateFormat(value, numberFormatters, properties);
        };
    };
    function optionsHasStyle(options) {
        return options.skeleton !== undefined || options.date !== undefined || options.time !== undefined || options.datetime !== undefined || options.raw !== undefined;
    }
    function validateRequiredCldr(path, value) {
        validateCldr(path, value, {
            skip: [ /dates\/calendars\/gregorian\/dateTimeFormats\/availableFormats/, /dates\/calendars\/gregorian\/days\/.*\/short/, /dates\/timeZoneNames\/zone/, /dates\/timeZoneNames\/metazone/, /globalize-iana/, /supplemental\/metaZones/, /supplemental\/timeData\/(?!001)/, /supplemental\/weekData\/(?!001)/ ]
        });
    }
    function validateOptionsPreset(options) {
        validateOptionsPresetEach("date", options);
        validateOptionsPresetEach("time", options);
        validateOptionsPresetEach("datetime", options);
    }
    function validateOptionsPresetEach(type, options) {
        var value = options[type];
        validate("E_INVALID_OPTIONS", 'Invalid `{{type}: "{value}"}`.', value === undefined || [ "short", "medium", "long", "full" ].indexOf(value) !== -1, {
            type: type,
            value: value
        });
    }
    function validateOptionsSkeleton(pattern, skeleton) {
        validate("E_INVALID_OPTIONS", 'Invalid `{skeleton: "{value}"}` based on provided CLDR.', skeleton === undefined || typeof pattern === "string" && pattern, {
            type: "skeleton",
            value: skeleton
        });
    }
    function validateRequiredIana(timeZone) {
        return function(path, value) {
            if (!/globalize-iana/.test(path)) {
                return;
            }
            validate("E_MISSING_IANA_TZ", "Missing required IANA timezone content for `{timeZone}`: `{path}`.", value, {
                path: path.replace(/globalize-iana\//, ""),
                timeZone: timeZone
            });
        };
    }
    Globalize.loadTimeZone = function(json) {
        var customData = {
            "globalize-iana": json
        };
        validateParameterPresence(json, "json");
        validateParameterTypePlainObject(json, "json");
        Cldr.load(customData);
    };
    Globalize.dateFormatter = Globalize.prototype.dateFormatter = function(options) {
        var args, dateToPartsFormatter, returnFn;
        validateParameterTypePlainObject(options, "options");
        options = options || {};
        if (!optionsHasStyle(options)) {
            options.skeleton = "yMd";
        }
        args = [ options ];
        dateToPartsFormatter = this.dateToPartsFormatter(options);
        returnFn = dateFormatterFn(dateToPartsFormatter);
        runtimeBind(args, this.cldr, returnFn, [ dateToPartsFormatter ]);
        return returnFn;
    };
    Globalize.dateToPartsFormatter = Globalize.prototype.dateToPartsFormatter = function(options) {
        var args, cldr, numberFormatters, pad, pattern, properties, returnFn, timeZone;
        validateParameterTypePlainObject(options, "options");
        cldr = this.cldr;
        options = options || {};
        if (!optionsHasStyle(options)) {
            options.skeleton = "yMd";
        }
        validateOptionsPreset(options);
        validateDefaultLocale(cldr);
        timeZone = options.timeZone;
        validateParameterTypeString(timeZone, "options.timeZone");
        args = [ options ];
        cldr.on("get", validateRequiredCldr);
        if (timeZone) {
            cldr.on("get", validateRequiredIana(timeZone));
        }
        pattern = dateExpandPattern(options, cldr);
        validateOptionsSkeleton(pattern, options.skeleton);
        properties = dateFormatProperties(pattern, cldr, timeZone);
        cldr.off("get", validateRequiredCldr);
        if (timeZone) {
            cldr.off("get", validateRequiredIana(timeZone));
        }
        numberFormatters = properties.numberFormatters;
        delete properties.numberFormatters;
        for (pad in numberFormatters) {
            numberFormatters[pad] = this.numberFormatter({
                raw: numberFormatters[pad]
            });
        }
        returnFn = dateToPartsFormatterFn(numberFormatters, properties);
        runtimeBind(args, cldr, returnFn, [ numberFormatters, properties ]);
        return returnFn;
    };
    Globalize.dateParser = Globalize.prototype.dateParser = function(options) {
        var args, cldr, numberParser, parseProperties, pattern, returnFn, timeZone, tokenizerProperties;
        validateParameterTypePlainObject(options, "options");
        cldr = this.cldr;
        options = options || {};
        if (!optionsHasStyle(options)) {
            options.skeleton = "yMd";
        }
        validateOptionsPreset(options);
        validateDefaultLocale(cldr);
        timeZone = options.timeZone;
        validateParameterTypeString(timeZone, "options.timeZone");
        args = [ options ];
        cldr.on("get", validateRequiredCldr);
        if (timeZone) {
            cldr.on("get", validateRequiredIana(timeZone));
        }
        pattern = dateExpandPattern(options, cldr);
        validateOptionsSkeleton(pattern, options.skeleton);
        tokenizerProperties = dateTokenizerProperties(pattern, cldr, timeZone);
        parseProperties = dateParseProperties(cldr, timeZone);
        cldr.off("get", validateRequiredCldr);
        if (timeZone) {
            cldr.off("get", validateRequiredIana(timeZone));
        }
        numberParser = this.numberParser({
            raw: "0"
        });
        returnFn = dateParserFn(numberParser, parseProperties, tokenizerProperties);
        runtimeBind(args, cldr, returnFn, [ numberParser, parseProperties, tokenizerProperties ]);
        return returnFn;
    };
    Globalize.formatDate = Globalize.prototype.formatDate = function(value, options) {
        validateParameterPresence(value, "value");
        validateParameterTypeDate(value, "value");
        return this.dateFormatter(options)(value);
    };
    Globalize.formatDateToParts = Globalize.prototype.formatDateToParts = function(value, options) {
        validateParameterPresence(value, "value");
        validateParameterTypeDate(value, "value");
        return this.dateToPartsFormatter(options)(value);
    };
    Globalize.parseDate = Globalize.prototype.parseDate = function(value, options) {
        validateParameterPresence(value, "value");
        validateParameterTypeString(value, "value");
        return this.dateParser(options)(value);
    };
    return Globalize;
});

(function(factory) {
    if (typeof define === "function" && define.amd) {
        define(factory);
    } else {
        window.purl = factory();
    }
})(function() {
    var tag2attr = {
        a: "href",
        img: "src",
        form: "action",
        base: "href",
        script: "src",
        iframe: "src",
        link: "href",
        embed: "src",
        object: "data"
    }, key = [ "source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "fragment" ], aliases = {
        anchor: "fragment"
    }, parser = {
        strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
        loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
    }, isint = /^[0-9]+$/;
    function parseUri(url, strictMode) {
        var str = decodeURI(url), res = parser[strictMode || false ? "strict" : "loose"].exec(str), uri = {
            attr: {},
            param: {},
            seg: {}
        }, i = 14;
        while (i--) {
            uri.attr[key[i]] = res[i] || "";
        }
        uri.param["query"] = parseString(uri.attr["query"]);
        uri.param["fragment"] = parseString(uri.attr["fragment"]);
        uri.seg["path"] = uri.attr.path.replace(/^\/+|\/+$/g, "").split("/");
        uri.seg["fragment"] = uri.attr.fragment.replace(/^\/+|\/+$/g, "").split("/");
        uri.attr["base"] = uri.attr.host ? (uri.attr.protocol ? uri.attr.protocol + "://" + uri.attr.host : uri.attr.host) + (uri.attr.port ? ":" + uri.attr.port : "") : "";
        return uri;
    }
    function getAttrName(elm) {
        var tn = elm.tagName;
        if (typeof tn !== "undefined") return tag2attr[tn.toLowerCase()];
        return tn;
    }
    function promote(parent, key) {
        if (parent[key].length === 0) return parent[key] = {};
        var t = {};
        for (var i in parent[key]) t[i] = parent[key][i];
        parent[key] = t;
        return t;
    }
    function parse(parts, parent, key, val) {
        var part = parts.shift();
        if (!part) {
            if (isArray(parent[key])) {
                parent[key].push(val);
            } else if ("object" == typeof parent[key]) {
                parent[key] = val;
            } else if ("undefined" == typeof parent[key]) {
                parent[key] = val;
            } else {
                parent[key] = [ parent[key], val ];
            }
        } else {
            var obj = parent[key] = parent[key] || [];
            if ("]" == part) {
                if (isArray(obj)) {
                    if ("" !== val) obj.push(val);
                } else if ("object" == typeof obj) {
                    obj[keys(obj).length] = val;
                } else {
                    obj = parent[key] = [ parent[key], val ];
                }
            } else if (~part.indexOf("]")) {
                part = part.substr(0, part.length - 1);
                if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
                parse(parts, obj, part, val);
            } else {
                if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
                parse(parts, obj, part, val);
            }
        }
    }
    function merge(parent, key, val) {
        if (~key.indexOf("]")) {
            var parts = key.split("[");
            parse(parts, parent, "base", val);
        } else {
            if (!isint.test(key) && isArray(parent.base)) {
                var t = {};
                for (var k in parent.base) t[k] = parent.base[k];
                parent.base = t;
            }
            if (key !== "") {
                set(parent.base, key, val);
            }
        }
        return parent;
    }
    function parseString(str) {
        return reduce(String(str).split(/&|;/), function(ret, pair) {
            try {
                pair = decodeURIComponent(pair.replace(/\+/g, " "));
            } catch (e) {}
            var eql = pair.indexOf("="), brace = lastBraceInKey(pair), key = pair.substr(0, brace || eql), val = pair.substr(brace || eql, pair.length);
            val = val.substr(val.indexOf("=") + 1, val.length);
            if (key === "") {
                key = pair;
                val = "";
            }
            return merge(ret, key, val);
        }, {
            base: {}
        }).base;
    }
    function set(obj, key, val) {
        var v = obj[key];
        if (typeof v === "undefined") {
            obj[key] = val;
        } else if (isArray(v)) {
            v.push(val);
        } else {
            obj[key] = [ v, val ];
        }
    }
    function lastBraceInKey(str) {
        var len = str.length, brace, c;
        for (var i = 0; i < len; ++i) {
            c = str[i];
            if ("]" == c) brace = false;
            if ("[" == c) brace = true;
            if ("=" == c && !brace) return i;
        }
    }
    function reduce(obj, accumulator) {
        var i = 0, l = obj.length >> 0, curr = arguments[2];
        while (i < l) {
            if (i in obj) curr = accumulator.call(undefined, curr, obj[i], i, obj);
            ++i;
        }
        return curr;
    }
    function isArray(vArg) {
        return Object.prototype.toString.call(vArg) === "[object Array]";
    }
    function keys(obj) {
        var key_array = [];
        for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) key_array.push(prop);
        }
        return key_array;
    }
    function purl(url, strictMode) {
        if (arguments.length === 1 && url === true) {
            strictMode = true;
            url = undefined;
        }
        strictMode = strictMode || false;
        url = url || window.location.toString();
        return {
            data: parseUri(url, strictMode),
            attr: function(attr) {
                attr = aliases[attr] || attr;
                return typeof attr !== "undefined" ? this.data.attr[attr] : this.data.attr;
            },
            param: function(param) {
                return typeof param !== "undefined" ? this.data.param.query[param] : this.data.param.query;
            },
            fparam: function(param) {
                return typeof param !== "undefined" ? this.data.param.fragment[param] : this.data.param.fragment;
            },
            segment: function(seg) {
                if (typeof seg === "undefined") {
                    return this.data.seg.path;
                } else {
                    seg = seg < 0 ? this.data.seg.path.length + seg : seg - 1;
                    return this.data.seg.path[seg];
                }
            },
            fsegment: function(seg) {
                if (typeof seg === "undefined") {
                    return this.data.seg.fragment;
                } else {
                    seg = seg < 0 ? this.data.seg.fragment.length + seg : seg - 1;
                    return this.data.seg.fragment[seg];
                }
            }
        };
    }
    purl.jQuery = function($) {
        if ($ != null) {
            $.fn.url = function(strictMode) {
                var url = "";
                if (this.length) {
                    url = $(this).attr(getAttrName(this[0])) || "";
                }
                return purl(url, strictMode);
            };
            $.url = purl;
        }
    };
    purl.jQuery(window.jQuery);
    return purl;
});
//# sourceMappingURL=libs-main.js.map